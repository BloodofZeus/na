{"file_contents":{"README.md":{"content":"# Shawarma Boss POS - PERN Stack\n\nA modern, full-stack Point of Sale (POS) system built with the PERN stack (PostgreSQL, Express.js, React, Node.js). Originally a vanilla JavaScript PWA, now transformed into a powerful, scalable web application optimized for cloud deployment on Replit.\n\n## üöÄ Features\n\n### Core POS Functionality\n- **User Authentication**: Secure login system with role-based access (Admin/Staff)\n- **Menu Management**: Dynamic menu with real-time stock tracking\n- **Order Processing**: Complete order workflow with cart management\n- **Receipt Generation**: Print and PDF receipt capabilities\n- **Sales Tracking**: Comprehensive sales reporting and analytics\n- **Stock Management**: Real-time inventory tracking with low-stock alerts\n\n### Modern Architecture\n- **React Frontend**: Component-based UI with modern hooks and context\n- **Express.js Backend**: RESTful API with proper error handling\n- **PostgreSQL Database**: Robust relational database with ACID compliance\n- **PWA-Ready Design**: Progressive Web App with modern navbar and mobile optimization\n- **Real-Time Notifications**: Built-in notification system for orders, system updates, and alerts\n- **Mobile-First Responsive**: Touch-friendly interface with hamburger navigation for mobile devices\n- **Hot Reloading**: Development server with automatic rebuilds\n\n### Enhanced Admin Features\n- **Advanced Staff Management**: Add/view staff with role assignment and sales performance tracking\n- **Real-time Menu Management**: Create menu items and update stock levels instantly with visual status indicators\n- **Comprehensive Sales Analytics**: Dashboard with total/daily sales, order counts, and staff performance metrics\n- **Enhanced Stock Management**: Inline stock updates with immediate feedback and low-stock alerts\n- **Professional UI/UX**: Bootstrap 5 integration with success/error notifications and responsive design\n- **Data Export & Reports**: JSON/CSV export functionality with comprehensive order history\n- **Visual Stock Alerts**: Real-time notifications for low inventory with status badges (OK/Low/Out)\n\n### Modern PWA Navigation & Mobile Experience\n- **Professional PWA Navbar**: Clean, light-themed navigation with tabbed interface and brand integration\n- **Mobile Hamburger Menu**: Touch-friendly slide-out navigation with user profile and role display\n- **Notification UI Center**: Mock notification system with badge counts and categorized alerts (ready for real-time integration)\n- **Responsive User Interface**: Adaptive layout that works seamlessly on desktop, tablet, and mobile devices\n- **Touch-Optimized Controls**: Minimum 44px touch targets for optimal mobile usability\n- **Accessibility Support**: Screen reader compatible with ARIA attributes and keyboard navigation\n- **Modern CSS Framework**: Responsive design with CSS Grid, Flexbox, and modern styling patterns\n- **Cross-Device Compatibility**: Optimized for various screen sizes and input methods\n\n## üõ†Ô∏è Technology Stack\n\n### Frontend\n- **React 18** - Component-based UI library\n- **React Router** - Client-side routing\n- **Axios** - HTTP client for API calls\n- **CSS3** - Modern styling with Flexbox/Grid\n- **Bootstrap 5** - Responsive component library\n\n### Backend\n- **Node.js** - JavaScript runtime\n- **Express.js** - Web application framework\n- **PostgreSQL** - Relational database\n- **CORS** - Cross-origin resource sharing\n- **dotenv** - Environment variable management\n\n### Build Tools\n- **Webpack** - Module bundler\n- **Babel** - JavaScript transpiler\n- **npm** - Package manager\n\n## üìã Prerequisites\n\n### For Local Development\n- Node.js 18+ \n- PostgreSQL 12+\n- npm or yarn\n\n### For Replit (Recommended)\n- No local installations required - add a PostgreSQL database via the Database tab\n\n## üöÄ Quick Start\n\n### Option A: Replit (Recommended)\n\n1. **Fork this repository** on Replit or import from GitHub\n2. **Add PostgreSQL Database**: Use the \"Database\" tab in Replit to add a PostgreSQL database (automatically sets DATABASE_URL)\n3. **Install dependencies**: Dependencies will be automatically installed on first run\n4. **Click Run** - The application will build and start automatically\n5. **Access the app** via the Replit webview\n\n**Note**: The PostgreSQL database and tables will be automatically created and seeded with default data on first run.\n\n### Option B: Local Development\n\n#### 1. Clone and Install Dependencies\n\n```bash\n# Clone the repository\ngit clone <repository-url>\ncd shawarma-boss-mern\n\n# Install dependencies\nnpm install\n```\n\n#### 2. Database Setup\n\n```bash\n# Create database\ncreatedb shawarma_boss\n\n# Copy environment file (create .env file)\necho \"PGHOST=localhost\nPGPORT=5432\nPGUSER=postgres\nPGPASSWORD=your_password\nPGDATABASE=shawarma_boss\" > .env\n```\n\n#### 3. Start the Application\n\n```bash\n# Production mode (builds React app and starts server)\nnpm start\n\n# Development mode (for development only)\nnpm run dev\n\n# Build production assets only\nnpm run build\n```\n\nThe application will be available at `http://localhost:5000`\n\n## üìÅ Project Structure\n\n```\nshawarma-boss-mern/\n‚îú‚îÄ‚îÄ src/                    # React frontend source\n‚îÇ   ‚îú‚îÄ‚îÄ components/         # React components\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Login.js       # Authentication component\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ POS.js         # Main POS interface\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Admin.js       # Admin dashboard\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Header.js      # Navigation header\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Cart.js        # Shopping cart\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ MenuGrid.js    # Menu display\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ OrderModal.js  # Order receipt modal\n‚îÇ   ‚îú‚îÄ‚îÄ services/          # API and state management\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ api.js         # API client\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ AuthContext.js # Authentication context\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ CartContext.js # Cart state management\n‚îÇ   ‚îú‚îÄ‚îÄ App.js             # Main React component\n‚îÇ   ‚îú‚îÄ‚îÄ App.css            # Application styles\n‚îÇ   ‚îú‚îÄ‚îÄ index.js           # React entry point\n‚îÇ   ‚îî‚îÄ‚îÄ index.css          # Global styles and utilities\n‚îú‚îÄ‚îÄ public/                # Static assets\n‚îÇ   ‚îî‚îÄ‚îÄ index.html         # HTML template\n‚îú‚îÄ‚îÄ dist/                  # Built React application (auto-generated)\n‚îú‚îÄ‚îÄ icons/                 # Application icons and logo\n‚îú‚îÄ‚îÄ server.js              # Unified Express.js server (frontend + API)\n‚îú‚îÄ‚îÄ webpack.config.js      # Webpack configuration\n‚îú‚îÄ‚îÄ package.json           # Dependencies and scripts\n‚îú‚îÄ‚îÄ replit.md             # Project documentation and architecture\n‚îî‚îÄ‚îÄ README.md             # This file\n```\n\n## üîå API Endpoints\n\n### Authentication\n- `POST /api/login` - User authentication\n- `GET /api/health` - Server health check\n\n### User Management\n- `GET /api/staff` - Get all staff members\n- `POST /api/staff` - Add new staff member\n\n### Menu Management\n- `GET /api/menu` - Get menu items\n- `POST /api/menu` - Add menu item\n- `PUT /api/menu/:id/stock` - Update item stock\n\n### Orders\n- `GET /api/orders` - Get order history\n- `POST /api/orders` - Create new order\n\n## üë• Default Users\n\nThe application comes with default users for testing:\n\n| Username | Password | Role |\n|----------|----------|------|\n| admin | admin123 | admin |\n| staff1 | staff123 | staff |\n\n## üóÉÔ∏è Database Schema\n\n### Users Table\n```sql\nCREATE TABLE users (\n    username VARCHAR(50) PRIMARY KEY,\n    password VARCHAR(255) NOT NULL,\n    role VARCHAR(20) DEFAULT 'staff',\n    meta JSONB,\n    created_at TIMESTAMP DEFAULT NOW(),\n    updated_at TIMESTAMP DEFAULT NOW()\n);\n```\n\n### Menu Table\n```sql\nCREATE TABLE menu (\n    id VARCHAR(50) PRIMARY KEY,\n    name VARCHAR(255) NOT NULL,\n    price DECIMAL(10,2) NOT NULL DEFAULT 0,\n    stock INTEGER NOT NULL DEFAULT 0,\n    meta JSONB,\n    created_at TIMESTAMP DEFAULT NOW(),\n    updated_at TIMESTAMP DEFAULT NOW()\n);\n```\n\n### Orders Table\n```sql\nCREATE TABLE orders (\n    id VARCHAR(50) PRIMARY KEY,\n    staff VARCHAR(50),\n    timestamp TIMESTAMP DEFAULT NOW(),\n    total DECIMAL(10,2) NOT NULL DEFAULT 0,\n    payload JSONB,\n    server_received_at TIMESTAMP DEFAULT NOW(),\n    FOREIGN KEY (staff) REFERENCES users(username)\n);\n```\n\n## üöÄ Deployment\n\n### Replit Deployment (Recommended)\nThis application is fully optimized for Replit deployment:\n\n1. **Database Setup**: Add PostgreSQL database via Replit's Database tab (sets DATABASE_URL automatically)\n2. **One-Click Deploy**: Use the \"Deploy\" button in Replit for instant production deployment\n3. **Autoscale Configuration**: Configure autoscale target in Replit's Deploy settings for automatic scaling\n4. **Build Process**: `npm run build` ‚Üí `node server.js`\n5. **CORS Enabled**: Properly configured for Replit's proxy environment\n\n### Manual Deployment\nFor other platforms, ensure the following environment variables are set:\n\n```bash\nNODE_ENV=production\nDATABASE_URL=your_postgresql_connection_string\nPORT=5000\nPGHOST=your_host\nPGPORT=5432\nPGUSER=your_user\nPGPASSWORD=your_password\nPGDATABASE=your_database\n```\n\n## üîß Development\n\n### Available Scripts\n\n- `npm start` - Build and start production server (used by Replit)\n- `npm run dev` - Start development server (development only)\n- `npm run build` - Build React app for production\n- `npm run build:dev` - Build React app for development\n\n### Development Workflow\n\n#### On Replit (Recommended)\n1. Make changes to React components in `src/` or backend in `server.js`\n2. The app automatically rebuilds and restarts\n3. View changes instantly in the Replit webview\n\n#### Local Development\n1. Start the development server: `npm run dev`\n2. Make changes to React components in `src/`\n3. The build process automatically rebuilds the app\n4. Server restarts automatically on backend changes\n\n### Important Notes\n- **Price Handling**: All price values from PostgreSQL are strings and must be converted with `parseFloat()` before using `.toFixed()`\n- **CORS**: Application is configured to work with Replit's proxy environment\n- **Database**: Automatic table creation and seeding on first run\n\n## üìä Features in Detail\n\n### Role-Based Access Control\n- **Staff**: Can only view their own sales and process orders\n- **Admin**: Full access to all features including user management and analytics\n\n### Advanced Real-Time Stock Management\n- **Inline Stock Updates**: Administrators can update stock levels directly from the menu management panel\n- **Visual Stock Indicators**: Color-coded badges showing stock status (Green=OK, Yellow=Low, Red=Out)\n- **Automatic Stock Deduction**: Stock levels automatically decrease when orders are processed\n- **Low Stock Alerts**: Immediate notifications when items reach ‚â§5 units with dedicated alerts section\n- **Real-time Feedback**: Success/error notifications for all stock operations with auto-dismissing alerts\n- **Stock Status Prevention**: System prevents orders when items are out of stock\n\n### Sales Analytics\n- Real-time sales dashboard\n- Sales by staff member\n- Daily/total sales tracking\n- Order history with detailed breakdown\n\n### Data Export\n- JSON export of all data (users, menu, orders)\n- CSV export of orders for external analysis\n- Data backup capabilities for external storage\n\n## üîí Security Features\n\n- Password-based authentication\n- Role-based route protection\n- SQL injection prevention with parameterized queries\n- CORS configuration for secure cross-origin requests\n- Input validation and sanitization\n\n## ü§ù Contributing\n\n1. Fork the repository\n2. Create a feature branch: `git checkout -b feature/amazing-feature`\n3. Commit your changes: `git commit -m 'Add amazing feature'`\n4. Push to the branch: `git push origin feature/amazing-feature`\n5. Open a Pull Request\n\n## üìù License\n\nThis project is licensed under the ISC License.\n\n## üìû Support\n\nFor support, please open an issue in the GitHub repository or contact the development team.\n\n## ‚úÖ Recent Enhancements (Latest Update)\n\n### v2.2.0 - Modern PWA Navbar & Mobile Experience\n- [x] **Modern PWA-Style Navigation**: Clean light theme with professional tab-based navigation\n- [x] **Mobile-First Responsive Design**: Touch-friendly hamburger menu with slide-out navigation\n- [x] **Notification UI System**: Mock notification center with badge counts and categorized alerts (demo ready)\n- [x] **Enhanced User Experience**: User avatars, role badges, and improved dropdown menus\n- [x] **Mobile Optimization**: Touch targets and mobile-optimized layouts\n- [x] **Accessibility Features**: Screen reader support, keyboard navigation, and ARIA attributes\n- [x] **Responsive Design**: Automatic layout adaptation based on screen size\n- [x] **Modern CSS Framework**: Enhanced styling with modern CSS patterns and animations\n\n### v2.1.0 - Replit Optimization & Bug Fixes\n- [x] **Replit Environment Optimization**: Fully configured for seamless deployment on Replit\n- [x] **Critical Bug Fixes**: Resolved PostgreSQL DECIMAL string handling causing blank pages\n- [x] **Price Formatting**: Fixed all `.toFixed()` errors with proper `parseFloat()` handling\n- [x] **Logo Optimization**: Improved login page logo sizing and layout\n- [x] **Database Integration**: Automatic PostgreSQL setup with proper environment configuration\n- [x] **CORS Configuration**: Optimized for Replit's proxy environment\n- [x] **Error Handling**: Comprehensive error handling for all price calculations\n\n### v2.0.0 - Enhanced Admin Dashboard\n- [x] **Enhanced Admin Dashboard**: Complete redesign with Bootstrap 5 integration\n- [x] **Real-time Stock Updates**: Inline stock modification with immediate visual feedback\n- [x] **Advanced Notification System**: Success/error alerts with auto-dismiss functionality\n- [x] **Improved Stock Management**: Visual status indicators and comprehensive alerts\n- [x] **Professional UI/UX**: Modern responsive design with Font Awesome icons\n- [x] **Enhanced Sales Analytics**: Comprehensive dashboard with staff performance tracking\n\n## üêõ Known Issues & Solutions\n\n### Troubleshooting\n- **Blank Page Issues**: If you encounter blank pages, ensure all price values are properly handled with `parseFloat()` before `.toFixed()`\n- **Database Connection**: PostgreSQL connection is automatic on Replit; for local development, ensure PostgreSQL is running\n- **Build Errors**: Run `npm install` to ensure all dependencies are installed\n- **CORS Issues**: The app is pre-configured for Replit's proxy environment\n\n## üéØ Future Roadmap\n\n- [ ] JWT-based authentication with refresh tokens\n- [ ] Password hashing with bcrypt\n- [ ] Real-time WebSocket notifications\n- [ ] Multi-location support\n- [ ] Advanced reporting with charts and graphs\n- [ ] Mobile app (React Native)\n- [ ] Integration with payment processors (Stripe, PayPal)\n- [ ] Barcode scanning support\n- [ ] Inventory forecasting and automated reordering\n- [ ] Multi-currency support\n- [ ] Dark mode theme\n\n---\n\n**Built with ‚ù§Ô∏è using the PERN Stack**","size_bytes":14879},"app.js":{"content":"/* app.js - Shawarma Boss POS (updated with role-based sales & staff filter)\n   ‚úÖ Admin sees all sales OR filter by staff\n   ‚úÖ Staff sees only their own sales\n   ‚úÖ Menu shared for all users\n*/\n\n// ---------- Helpers & storage compatibility ----------\nconst DB_KEY = 'shawarma_boss_db_v1';\nconst LEGACY_KEYS = {\n  menu: ['shawarma_boss_menu','menu','items'],\n  staff: ['shawarma_boss_staff','staff'],\n  sales: ['shawarma_boss_sales','sales','shawarma_sales'],\n  quick: ['shawarma_boss_quick_sales','quickSales'],\n  currentUser: ['shawarma_boss_current_user','loggedIn']\n};\n\nfunction safeParse(key, fallback=null) {\n  try {\n    const raw = localStorage.getItem(key);\n    return raw ? JSON.parse(raw) : fallback;\n  } catch (e) { return fallback; }\n}\n\nfunction writeLegacy(keyName, value) {\n  const arr = LEGACY_KEYS[keyName] || [];\n  arr.forEach(k => {\n    try { localStorage.setItem(k, JSON.stringify(value)); } catch(e){ /* ignore */ }\n  });\n}\n\nfunction loadDB() {\n  const dbFromMain = safeParse(DB_KEY, null);\n  if (dbFromMain && typeof dbFromMain === 'object') return dbFromMain;\n  return {\n    users: safeParse(LEGACY_KEYS.staff[0], null),\n    menu: safeParse(LEGACY_KEYS.menu[0], null),\n    orders: safeParse(LEGACY_KEYS.sales[0], null),\n    quick: safeParse(LEGACY_KEYS.quick[0], null),\n    currentUser: safeParse(LEGACY_KEYS.currentUser[0], null)\n  };\n}\n\nfunction ensureDefaults(db) {\n  if (!Array.isArray(db.users) || db.users.length === 0) {\n    db.users = [\n      { username: 'admin', password: 'admin123', role: 'admin' },\n      { username: 'staff1', password: 'staff123', role: 'staff' }\n    ];\n  }\n  if (!Array.isArray(db.menu) || db.menu.length === 0) {\n    db.menu = [\n      { id: 'm-1', name: 'Shawarma Wrap', price: 20, stock: 25 },\n      { id: 'm-2', name: 'Chicken Shawarma', price: 25, stock: 20 },\n      { id: 'm-3', name: 'Beef Shawarma', price: 28, stock: 18 }\n    ];\n  }\n  if (!Array.isArray(db.orders)) db.orders = [];\n  if (!Array.isArray(db.quick)) db.quick = [];\n  return db;\n}\n\nfunction saveDB(db) {\n  try {\n    localStorage.setItem(DB_KEY, JSON.stringify(db));\n  } catch(e){}\n  writeLegacy('menu', db.menu);\n  writeLegacy('staff', db.users);\n  writeLegacy('sales', db.orders);\n  writeLegacy('quick', db.quick);\n  if (db.currentUser) writeLegacy('currentUser', db.currentUser);\n}\n\n// ---------- Initialize ----------\nlet db = ensureDefaults(loadDB() || {});\nsaveDB(db);\n\nlet runtime = {\n  user: safeParse('shawarma_boss_current_user', null) || db.currentUser || null,\n  cart: []\n};\n\n// DOM helpers\nconst $ = s => document.querySelector(s);\nconst $$ = s => Array.from(document.querySelectorAll(s));\n\n// ---------- AUTH ----------\nfunction showLogin() {\n  $('#loginScreen')?.classList.remove('d-none');\n  $('#appRoot')?.classList.add('d-none');\n  $('#adminPanel')?.classList.add('d-none');\n  $('#headerControls').innerHTML = '';\n}\n\nfunction showAppForUser() {\n  $('#loginScreen')?.classList.add('d-none');\n  $('#appRoot')?.classList.remove('d-none');\n\n  const h = $('#headerControls');\n  if (runtime.user) {\n    h.innerHTML = `<div class=\"text-end small pe-2\">Logged in: <strong>${runtime.user.username}</strong> \n      <button id=\"logoutBtnHeader\" class=\"btn btn-sm btn-outline-light ms-2\">Logout</button></div>`;\n    $('#logoutBtnHeader')?.addEventListener('click', () => logout());\n  }\n\n  const isAdmin = runtime.user && runtime.user.role === 'admin';\n  if (isAdmin) $('#adminPanel')?.classList.remove('d-none');\n  else $('#adminPanel')?.classList.add('d-none');\n\n  renderMenuGrid();\n  renderCart();\n  renderRecentSales();\n  renderSalesReport();\n  renderAdminPanel();\n}\n\nfunction loginAttempt() {\n  $('#loginErr')?.classList.add('d-none');\n  const u = ($('#loginUsername')?.value || '').trim();\n  const p = ($('#loginPassword')?.value || '').trim();\n  const found = db.users.find(x => x.username === u && x.password === p);\n  if (!found) return $('#loginErr')?.classList.remove('d-none');\n  runtime.user = found;\n  db.currentUser = found;\n  saveDB(db);\n  showAppForUser();\n}\n\nfunction logout() {\n  runtime.user = null;\n  db.currentUser = null;\n  try { localStorage.removeItem('shawarma_boss_current_user'); } catch(e){}\n  saveDB(db);\n  showLogin();\n}\n\n// ---------- MENU & CART ----------\nfunction renderMenuGrid() {\n  const container = $('#menuGrid');\n  if (!container) return;\n  container.innerHTML = '';\n  const tpl = document.getElementById('menuCardTpl');\n  db.menu.forEach((item, idx) => {\n    const node = tpl.content.cloneNode(true);\n    node.querySelector('.item-name').textContent = item.name;\n    node.querySelector('.item-price-badge').textContent = `GHS ${Number(item.price).toFixed(2)}`;\n    node.querySelector('.item-stock').textContent = `Stock: ${item.stock}`;\n    const qtyInput = node.querySelector('.qty-input');\n    qtyInput.value = 1;\n    node.querySelector('.add-to-cart').addEventListener('click', () => {\n      const q = Math.max(1, parseInt(qtyInput.value) || 1);\n      if (item.stock < q) return alert('Not enough stock');\n      addToCart(item.id || ('id-' + idx), q);\n    });\n    container.appendChild(node);\n  });\n}\n\nfunction addToCart(id, qty) {\n  const item = db.menu.find(m => m.id === id);\n  if (!item) return;\n  const existing = runtime.cart.find(c => c.id === id);\n  if (existing) existing.qty += qty;\n  else runtime.cart.push({ id: id, name: item.name, price: Number(item.price), qty });\n  renderCart();\n}\n\nfunction renderCart() {\n  const list = $('#cartList');\n  if (!list) return;\n  list.innerHTML = '';\n  if (!runtime.cart.length) {\n    list.innerHTML = '<div class=\"small text-muted\">Cart is empty</div>';\n    $('#cartTotal').textContent = 'GHS 0.00';\n    return;\n  }\n  let total = 0;\n  runtime.cart.forEach((it, idx) => {\n    total += it.qty * it.price;\n    const row = document.createElement('div');\n    row.className = 'd-flex justify-content-between align-items-center py-2 border-bottom';\n    row.innerHTML = `<div><strong>${it.name}</strong><div class=\"small text-muted\">${it.qty} √ó GHS ${it.price.toFixed(2)}</div></div>\n      <div class=\"text-end\"><div class=\"fw-bold\">GHS ${(it.qty*it.price).toFixed(2)}</div>\n        <button class=\"btn btn-sm btn-outline-danger remove-item\" data-idx=\"${idx}\">Del</button></div>`;\n    list.appendChild(row);\n  });\n  $('#cartTotal').textContent = `GHS ${total.toFixed(2)}`;\n  $$('.remove-item').forEach(b => b.addEventListener('click', e => {\n    runtime.cart.splice(parseInt(e.currentTarget.dataset.idx),1);\n    renderCart();\n  }));\n}\n\nfunction clearCart() { runtime.cart = []; renderCart(); }\n\n// ---------- ORDERS ----------\nfunction confirmOrder() {\n  if (!runtime.cart.length) return alert('Cart empty');\n  if (!runtime.user) return alert('Please login');\n\n  const order = {\n    id: 'O' + Date.now(),\n    staff: runtime.user.username,\n    items: JSON.parse(JSON.stringify(runtime.cart)),\n    total: runtime.cart.reduce((s,i)=>s + i.qty*i.price, 0),\n    timestamp: new Date().toISOString()\n  };\n\n  order.items.forEach(it => {\n    const m = db.menu.find(x => x.id === it.id);\n    if (m) m.stock = Math.max(0, m.stock - it.qty);\n  });\n\n  db.orders.push(order);\n  db.quick.push(order);\n  saveDB(db);\n\n  runtime.cart = [];\n  renderCart();\n  renderMenuGrid();\n  renderRecentSales();\n  renderSalesReport();\n  renderAdminPanel();\n}\n\n// ---------- ADMIN PANEL ----------\nfunction renderAdminPanel() {\n  if (!(runtime.user && runtime.user.role === 'admin')) return;\n  renderStaffList();\n  renderMenuManage();\n  renderStockAlerts();\n\n  // Sales filter dropdown\n  let filter = $('#salesFilter');\n  if (filter) {\n    filter.innerHTML = '<option value=\"all\">All staff</option>';\n    db.users.filter(u=>u.role==='staff').forEach(s=>{\n      const opt = document.createElement('option');\n      opt.value = s.username; opt.textContent = s.username;\n      filter.appendChild(opt);\n    });\n  }\n}\n\nfunction renderStaffList() {\n  const root = $('#staffList'); if (!root) return;\n  root.innerHTML = '';\n  db.users.filter(u=>u.role==='staff').forEach(s => {\n    const div = document.createElement('div');\n    div.className = 'd-flex justify-content-between align-items-center mb-1';\n    div.innerHTML = `<div>${s.username}</div>\n      <button class=\"btn btn-sm btn-outline-danger remove-staff\" data-username=\"${s.username}\">Remove</button>`;\n    root.appendChild(div);\n  });\n  $$('.remove-staff').forEach(b => b.addEventListener('click', e => {\n    const name = e.currentTarget.dataset.username;\n    db.users = db.users.filter(u => u.username !== name);\n    saveDB(db); renderStaffList();\n  }));\n}\n\nfunction addStaffFromUI() {\n  const u = $('#newStaffUser')?.value.trim();\n  const p = $('#newStaffPass')?.value.trim();\n  if (!u || !p) return alert('Enter username & password');\n  db.users.push({ username: u, password: p, role: 'staff' });\n  saveDB(db); renderStaffList();\n}\n\n// Menu manage\nfunction renderMenuManage() {\n  const root = $('#menuManage'); if (!root) return;\n  root.innerHTML = '';\n  db.menu.forEach((m,i) => {\n    const div = document.createElement('div');\n    div.className = 'd-flex justify-content-between align-items-center mb-1';\n    div.innerHTML = `<div><strong>${m.name}</strong><div class=\"small text-muted\">GHS ${m.price} ‚Ä¢ stock: ${m.stock}</div></div>\n      <button class=\"btn btn-sm btn-outline-danger delete-item\" data-idx=\"${i}\">Del</button>`;\n    root.appendChild(div);\n  });\n  $$('.delete-item').forEach(b => b.addEventListener('click', e => {\n    db.menu.splice(parseInt(e.currentTarget.dataset.idx),1);\n    saveDB(db); renderMenuGrid(); renderMenuManage();\n  }));\n}\n\nfunction addMenuItemFromUI() {\n  const name = $('#newItemName')?.value.trim(); \n  const price = parseFloat($('#newItemPrice')?.value); \n  const stock = parseInt($('#newItemStock')?.value);\n  if (!name || isNaN(price) || isNaN(stock)) return alert('Invalid item data');\n  db.menu.push({ id: 'm-' + Date.now(), name, price, stock });\n  saveDB(db);\n  renderMenuGrid(); renderMenuManage();\n}\n\nfunction renderStockAlerts() {\n  const low = db.menu.filter(m => m.stock < 5);\n  $('#stockAlerts').innerHTML = low.length ? low.map(m => `<div>${m.name} low (${m.stock})</div>`).join('') : 'No alerts';\n}\n\n// ---------- SALES REPORT ----------\nfunction renderRecentSales() {\n  const root = $('#recentSales'); if (!root) return;\n  root.innerHTML = '';\n\n  let orders = db.orders || [];\n  if (runtime.user.role === 'staff') {\n    orders = orders.filter(o => o.staff === runtime.user.username);\n  }\n\n  const last = orders.slice(-5).reverse();\n  if (!last.length) { root.textContent = 'No sales yet.'; return; }\n\n  last.forEach(o => {\n    const div = document.createElement('div'); div.className = 'mb-1 small';\n    div.innerHTML = `${o.id} ‚Ä¢ ${o.staff} ‚Ä¢ GHS ${o.total.toFixed(2)} ‚Ä¢ ${new Date(o.timestamp).toLocaleString()}`;\n    root.appendChild(div);\n  });\n}\n\nfunction renderSalesReport() {\n  const root = $('#salesReport'); if (!root) return;\n  let orders = db.orders || [];\n\n  if (runtime.user.role === 'staff') {\n    orders = orders.filter(o => o.staff === runtime.user.username);\n  } else {\n    const filterVal = $('#salesFilter')?.value || 'all';\n    if (filterVal !== 'all') orders = orders.filter(o => o.staff === filterVal);\n  }\n\n  root.innerHTML = '';\n  if (!orders.length) { root.innerHTML = '<div class=\"small text-muted\">No sales</div>'; return; }\n\n  let total = 0;\n  orders.slice().reverse().forEach(o => {\n    total += o.total;\n    const div = document.createElement('div'); div.className = 'p-2 border rounded mb-2';\n    div.innerHTML = `<div class=\"d-flex justify-content-between\">\n        <div><strong>${o.id}</strong><div class=\"small text-muted\">${o.staff} ‚Ä¢ ${new Date(o.timestamp).toLocaleString()}</div></div>\n        <div><strong>GHS ${o.total.toFixed(2)}</strong></div></div>`;\n    root.appendChild(div);\n  });\n  root.appendChild(Object.assign(document.createElement('div'), {className:'fw-bold mt-2', textContent:`Total: GHS ${total.toFixed(2)}`}));\n}\n\n// ---------- Wire UI ----------\ndocument.addEventListener('DOMContentLoaded', () => {\n  $('#loginBtn')?.addEventListener('click', loginAttempt);\n  $('#clearCartBtn')?.addEventListener('click', clearCart);\n  $('#confirmOrderBtn')?.addEventListener('click', confirmOrder);\n  $('#addStaffBtn')?.addEventListener('click', addStaffFromUI);\n  $('#addItemBtn')?.addEventListener('click', addMenuItemFromUI);\n  $('#salesFilter')?.addEventListener('change', renderSalesReport);\n\n  if (runtime.user) showAppForUser(); else showLogin();\n});\n","size_bytes":12405},"replit.md":{"content":"# Overview\n\nShawarma Boss POS is a modern Point of Sale system built with the MERN stack (MongoDB/PostgreSQL, Express.js, React, Node.js). Originally developed as a vanilla JavaScript PWA stored in localStorage, it has been transformed into a full-stack application with a React frontend, Express.js backend, and PostgreSQL database. The system provides comprehensive POS functionality including user authentication, menu management, order processing, receipt generation, sales tracking, and real-time inventory management with role-based access control for admin and staff users.\n\n# User Preferences\n\nPreferred communication style: Simple, everyday language.\n\n# System Architecture\n\n## Frontend Architecture\n- **React 18** with functional components and hooks for the user interface\n- **React Router** for client-side navigation between POS and admin views\n- **Context API** for state management (AuthContext for user sessions, CartContext for shopping cart)\n- **Axios** for HTTP client communication with the backend API\n- **Component-based architecture** with reusable components (Header, Login, POS, Admin, Cart, MenuGrid, OrderModal)\n- **Responsive design** using Bootstrap 5 and custom CSS with mobile-first approach\n- **Webpack** for module bundling and build process with hot reloading in development\n\n## Backend Architecture\n- **Express.js** web server providing RESTful API endpoints\n- **PostgreSQL** as the primary database with ACID compliance\n- **Database initialization** with automatic table creation and default data seeding\n- **Role-based authentication** with admin and staff user roles\n- **CORS enabled** for cross-origin requests (required for Replit proxy)\n- **Environment variable configuration** for database connection and deployment flexibility\n- **Static file serving** for both React build artifacts and legacy PWA assets\n\n## Data Storage Architecture\n- **PostgreSQL tables**: users, menu, orders with proper relational structure\n- **Backward compatibility** with localStorage data migration for existing installations\n- **JSON metadata storage** in JSONB fields for flexible data extension\n- **Automatic timestamp tracking** for created_at and updated_at fields\n\n## Authentication & Authorization\n- **Session-based authentication** with localStorage persistence\n- **Role-based access control** (admin can access all features, staff limited to POS functionality)\n- **Token-based API authentication** for external server sync (optional)\n- **Password validation** with secure credential handling\n\n## Legacy PWA Support\n- **Service worker** for offline functionality and caching\n- **Web app manifest** for PWA installation capabilities\n- **Progressive enhancement** approach maintaining offline-first functionality\n- **Dual architecture** supporting both modern React app and legacy vanilla JavaScript\n\n# External Dependencies\n\n## Frontend Libraries\n- **Bootstrap 5** - CSS framework for responsive UI components\n- **Font Awesome** - Icon library for UI elements\n- **Chart.js** - Data visualization for sales analytics and reporting\n- **jsPDF** - PDF generation for receipts and reports\n- **QRious** - QR code generation for receipts\n\n## Backend Dependencies\n- **PostgreSQL (pg)** - Primary database driver and connection pooling\n- **CORS** - Cross-origin resource sharing middleware\n- **body-parser** - HTTP request body parsing middleware\n- **dotenv** - Environment variable configuration management\n\n## Build Tools & Development\n- **Webpack** - Module bundler with Babel transpilation\n- **Babel** - JavaScript transpiler for React JSX and modern JavaScript features\n- **React Scripts** - Create React App tooling for development workflow\n\n## Database Configuration\n- **PostgreSQL connection** with environment variable configuration\n- **SSL support** for production deployments\n- **Connection pooling** for efficient database resource management\n- **Automatic failover** to localhost development database\n\n## Deployment Support\n- **Environment-based configuration** for development and production\n- **Static file serving** for single-server deployment\n- **Port configuration** with fallback to port 5000\n- **Database URL parsing** for various hosting providers (Railway, Render, Fly.io)","size_bytes":4213},"server.js":{"content":"// Unified MERN Server - Serves both frontend and API\nrequire('dotenv').config();\nconst express = require('express');\nconst cors = require('cors');\nconst path = require('path');\nconst bodyParser = require('body-parser');\nconst { Pool } = require('pg');\n\nconst PORT = process.env.PORT || 5000;\n\n// PostgreSQL configuration\nconst DATABASE_URL = process.env.DATABASE_URL || \n  process.env.PGURL || \n  `postgresql://${process.env.PGUSER || 'postgres'}:${process.env.PGPASSWORD || 'postgres'}@${process.env.PGHOST || 'localhost'}:${process.env.PGPORT || 5432}/${process.env.PGDATABASE || 'shawarma_boss'}`;\n\nconst app = express();\n\n// Enable CORS for all origins (required for Replit proxy)\napp.use(cors({\n  origin: true,\n  credentials: true\n}));\n\napp.use(bodyParser.json({ limit: '10mb' }));\n\n// Serve static files from dist directory (built React app)\napp.use(express.static(path.join(__dirname, 'dist')));\n\n// Serve legacy static files (icons, manifest, etc.)\napp.use(express.static(path.join(__dirname)));\n\n// PostgreSQL Database setup\nconst pool = new Pool({\n  connectionString: DATABASE_URL,\n  ssl: process.env.NODE_ENV === 'production' ? { rejectUnauthorized: false } : false,\n});\n\n// Initialize database tables and default data\nasync function initializeDatabase() {\n  try {\n    // Create tables if they don't exist\n    await pool.query(`\n      CREATE TABLE IF NOT EXISTS users (\n        username VARCHAR(50) PRIMARY KEY,\n        password VARCHAR(255) NOT NULL,\n        role VARCHAR(20) DEFAULT 'staff',\n        meta JSONB,\n        created_at TIMESTAMP DEFAULT NOW(),\n        updated_at TIMESTAMP DEFAULT NOW()\n      )\n    `);\n\n    await pool.query(`\n      CREATE TABLE IF NOT EXISTS menu (\n        id VARCHAR(50) PRIMARY KEY,\n        name VARCHAR(255) NOT NULL,\n        price DECIMAL(10,2) NOT NULL DEFAULT 0,\n        stock INTEGER NOT NULL DEFAULT 0,\n        meta JSONB,\n        created_at TIMESTAMP DEFAULT NOW(),\n        updated_at TIMESTAMP DEFAULT NOW()\n      )\n    `);\n\n    await pool.query(`\n      CREATE TABLE IF NOT EXISTS orders (\n        id VARCHAR(50) PRIMARY KEY,\n        staff VARCHAR(50),\n        timestamp TIMESTAMP DEFAULT NOW(),\n        total DECIMAL(10,2) NOT NULL DEFAULT 0,\n        payload JSONB,\n        server_received_at TIMESTAMP DEFAULT NOW(),\n        FOREIGN KEY (staff) REFERENCES users(username)\n      )\n    `);\n\n    // Create indexes for better performance\n    await pool.query(`CREATE INDEX IF NOT EXISTS idx_orders_staff ON orders(staff)`);\n    await pool.query(`CREATE INDEX IF NOT EXISTS idx_orders_timestamp ON orders(timestamp)`);\n    await pool.query(`CREATE INDEX IF NOT EXISTS idx_menu_stock ON menu(stock)`);\n\n    // Insert default data if tables are empty\n    const userCount = await pool.query('SELECT COUNT(*) as count FROM users');\n    if (parseInt(userCount.rows[0].count) === 0) {\n      const defaultUsers = [\n        { username: 'admin', password: 'admin123', role: 'admin' },\n        { username: 'staff1', password: 'staff123', role: 'staff' }\n      ];\n      \n      for (const user of defaultUsers) {\n        await pool.query(\n          'INSERT INTO users (username, password, role) VALUES ($1, $2, $3)',\n          [user.username, user.password, user.role]\n        );\n      }\n      console.log('‚úÖ Default users created');\n    }\n\n    const menuCount = await pool.query('SELECT COUNT(*) as count FROM menu');\n    if (parseInt(menuCount.rows[0].count) === 0) {\n      const defaultMenu = [\n        { id: 'm-1', name: 'Shawarma Wrap', price: 20, stock: 25 },\n        { id: 'm-2', name: 'Chicken Shawarma', price: 25, stock: 20 },\n        { id: 'm-3', name: 'Beef Shawarma', price: 28, stock: 18 }\n      ];\n      \n      for (const item of defaultMenu) {\n        await pool.query(\n          'INSERT INTO menu (id, name, price, stock) VALUES ($1, $2, $3, $4)',\n          [item.id, item.name, item.price, item.stock]\n        );\n      }\n      console.log('‚úÖ Default menu items created');\n    }\n\n    console.log('üóÑÔ∏è PostgreSQL database initialized successfully');\n  } catch (error) {\n    console.error('‚ùå Database initialization error:', error);\n    throw error;\n  }\n}\n\n// Initialize database on startup\ninitializeDatabase();\n\n// Helper function for database queries\nasync function queryDB(sql, params = []) {\n  try {\n    const result = await pool.query(sql, params);\n    return result.rows;\n  } catch (error) {\n    console.error('Database query error:', error);\n    throw error;\n  }\n}\n\n// API Routes\napp.get('/api/health', async (req, res) => {\n  try {\n    // Test database connection\n    await pool.query('SELECT NOW()');\n    res.json({ \n      ok: true, \n      message: 'Shawarma Boss MERN Server Running', \n      database: 'PostgreSQL',\n      timestamp: new Date().toISOString()\n    });\n  } catch (error) {\n    res.status(500).json({ \n      ok: false, \n      message: 'Database connection failed', \n      error: error.message \n    });\n  }\n});\n\n// Login endpoint\napp.post('/api/login', async (req, res) => {\n  try {\n    const { username, password } = req.body || {};\n    if (!username || !password) {\n      return res.status(400).json({ ok: false, error: 'Username and password required' });\n    }\n    \n    const users = await queryDB('SELECT username, role FROM users WHERE username = $1 AND password = $2', \n                                [username, password]);\n    const user = users[0];\n    if (!user) {\n      return res.status(401).json({ ok: false, error: 'Invalid credentials' });\n    }\n    \n    res.json({ ok: true, username: user.username, role: user.role });\n  } catch (e) {\n    console.error(e);\n    res.status(500).json({ ok: false, error: e.message });\n  }\n});\n\n// Get staff/users\napp.get('/api/staff', async (req, res) => {\n  try {\n    const users = await queryDB('SELECT username, role, meta FROM users ORDER BY created_at');\n    const mapped = users.map(u => ({\n      username: u.username,\n      role: u.role,\n      meta: u.meta || null\n    }));\n    res.json(mapped);\n  } catch (e) {\n    res.status(500).json({ error: e.message });\n  }\n});\n\n// Add staff user\napp.post('/api/staff', async (req, res) => {\n  try {\n    const { username, password, role = 'staff' } = req.body;\n    if (!username || !password) {\n      return res.status(400).json({ error: 'Username and password required' });\n    }\n    \n    await queryDB('INSERT INTO users (username, password, role) VALUES ($1, $2, $3)', \n                   [username, password, role]);\n    res.json({ ok: true, username });\n  } catch (e) {\n    res.status(500).json({ error: e.message });\n  }\n});\n\n// Get menu\napp.get('/api/menu', async (req, res) => {\n  try {\n    const menu = await queryDB('SELECT id, name, price, stock, meta FROM menu ORDER BY created_at');\n    const mapped = menu.map(item => ({\n      id: item.id,\n      name: item.name,\n      price: item.price,\n      stock: item.stock,\n      meta: item.meta || null\n    }));\n    res.json(mapped);\n  } catch (e) {\n    res.status(500).json({ error: e.message });\n  }\n});\n\n// Add menu item\napp.post('/api/menu', async (req, res) => {\n  try {\n    const { name, price, stock } = req.body;\n    if (!name || price === undefined || stock === undefined) {\n      return res.status(400).json({ error: 'Name, price, and stock required' });\n    }\n    \n    const id = 'm-' + Date.now() + '-' + Math.floor(Math.random() * 1000);\n    await queryDB('INSERT INTO menu (id, name, price, stock) VALUES ($1, $2, $3, $4)', \n                   [id, name, parseFloat(price), parseInt(stock)]);\n    res.json({ ok: true, id, name, price, stock });\n  } catch (e) {\n    res.status(500).json({ error: e.message });\n  }\n});\n\n// Update menu item stock\napp.put('/api/menu/:id/stock', async (req, res) => {\n  try {\n    const { id } = req.params;\n    const { stock } = req.body;\n    \n    await queryDB('UPDATE menu SET stock = $1, updated_at = NOW() WHERE id = $2', [parseInt(stock), id]);\n    res.json({ ok: true });\n  } catch (e) {\n    res.status(500).json({ error: e.message });\n  }\n});\n\n// Get orders/sales\napp.get('/api/orders', async (req, res) => {\n  try {\n    const orders = await queryDB('SELECT id, staff, timestamp, total, payload, server_received_at FROM orders ORDER BY server_received_at DESC LIMIT 500');\n    const mapped = orders.map(o => ({\n      id: o.id,\n      staff: o.staff,\n      timestamp: o.timestamp,\n      total: o.total,\n      payload: o.payload || null,\n      serverReceivedAt: o.server_received_at\n    }));\n    res.json(mapped);\n  } catch (e) {\n    res.status(500).json({ error: e.message });\n  }\n});\n\n// Add order\napp.post('/api/orders', async (req, res) => {\n  try {\n    const order = req.body;\n    if (!order || !order.id) {\n      return res.status(400).json({ error: 'Order with ID required' });\n    }\n    \n    const payload = order;\n    const serverReceivedAt = new Date().toISOString();\n    \n    await queryDB('INSERT INTO orders (id, staff, timestamp, total, payload, server_received_at) VALUES ($1, $2, $3, $4, $5, $6) ON CONFLICT (id) DO NOTHING',\n                   [order.id, order.user || order.staff || '', order.timestamp || new Date().toISOString(), order.total || 0, JSON.stringify(payload), serverReceivedAt]);\n    \n    res.json({ ok: true, id: order.id });\n  } catch (e) {\n    res.status(500).json({ error: e.message });\n  }\n});\n\n// Catch-all handler for React SPA routing (must be last)\napp.use((req, res, next) => {\n  // Skip API routes\n  if (req.path.startsWith('/api/')) {\n    return next();\n  }\n  \n  // Skip static files\n  if (req.path.includes('.')) {\n    return next();\n  }\n  \n  // Serve React app\n  const distIndexPath = path.join(__dirname, 'dist', 'index.html');\n  if (require('fs').existsSync(distIndexPath)) {\n    res.sendFile(distIndexPath);\n  } else {\n    // Fallback to legacy index.html if React app not built\n    res.sendFile(path.join(__dirname, 'index.html'));\n  }\n});\n\n// Start server\napp.listen(PORT, '0.0.0.0', () => {\n  console.log(`üöÄ Shawarma Boss MERN Server running on http://0.0.0.0:${PORT}`);\n  console.log(`üóÑÔ∏è Database: PostgreSQL`);\n  console.log(`üîó API endpoints available at /api/*`);\n  console.log(`üì± React app served from /dist`);\n  console.log(`üîÑ Environment: ${process.env.NODE_ENV || 'development'}`);\n});","size_bytes":10145},"service-worker.js":{"content":"const CACHE_NAME = 'shawarma-boss-cache-v1';\nconst ASSETS = [\n  './',\n  './index.html',\n  './style.css',\n  './app.js',\n  './manifest.json',\n  './icons/icon-192.png',\n  './icons/icon-512.png',\n  './icons/logo.png'\n];\n\nself.addEventListener('install', e => {\n  e.waitUntil(caches.open(CACHE_NAME).then(c => c.addAll(ASSETS)));\n  self.skipWaiting();\n});\n\nself.addEventListener('activate', e => {\n  e.waitUntil(caches.keys().then(keys => Promise.all(keys.filter(k => k !== CACHE_NAME).map(k => caches.delete(k)))));\n  self.clients.claim();\n});\n\nself.addEventListener('fetch', e => {\n  if (e.request.method !== 'GET') return;\n  e.respondWith(caches.match(e.request).then(r => r || fetch(e.request).then(resp => {\n    return caches.open(CACHE_NAME).then(cache => { cache.put(e.request, resp.clone()); return resp; });\n  }).catch(() => caches.match('./'))));\n});\n","size_bytes":856},"style.css":{"content":"/* Shawarma Boss theme */\n:root{\n  --brand-red: #e60000;\n  --brand-black: #111111;\n  --brand-white: #ffffff;\n}\n\n/* small Tailwind-friendly tweaks */\nbody { font-family: Inter, ui-sans-serif, system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial; }\n\n/* menu card styles */\n.menu-card { border-radius: 12px; box-shadow: 0 6px 18px rgba(0,0,0,0.06); border: 1px solid rgba(0,0,0,0.06); }\n.menu-card .item-price-badge { font-weight: 700; padding: .45rem .6rem; }\n\n/* hover lift */\n.menu-card:hover { transform: translateY(-4px); transition: transform .15s ease; }\n\n/* small utility */\n.hidden { display: none !important; }\n\n/* receipt print styles (used when printing receipt window) */\n@media print {\n  body * { visibility: hidden; }\n  .receipt-print, .receipt-print * { visibility: visible; }\n  .receipt-print { position: absolute; left: 0; top: 0; width: 320px; font-family: monospace; font-size:12px; }\n}\n","size_bytes":921},"webpack.config.js":{"content":"const path = require('path');\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\n\nmodule.exports = {\n  entry: './src/index.js',\n  output: {\n    path: path.resolve(__dirname, 'dist'),\n    filename: 'bundle.[contenthash].js',\n    publicPath: '/',\n    clean: true\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.(js|jsx)$/,\n        exclude: /node_modules/,\n        use: {\n          loader: 'babel-loader',\n          options: {\n            presets: ['@babel/preset-env', '@babel/preset-react']\n          }\n        }\n      },\n      {\n        test: /\\.css$/,\n        use: ['style-loader', 'css-loader']\n      },\n      {\n        test: /\\.(png|jpg|jpeg|gif|svg)$/,\n        type: 'asset/resource'\n      }\n    ]\n  },\n  plugins: [\n    new HtmlWebpackPlugin({\n      template: './public/index.html',\n      filename: 'index.html'\n    })\n  ],\n  resolve: {\n    extensions: ['.js', '.jsx']\n  },\n  mode: process.env.NODE_ENV === 'production' ? 'production' : 'development',\n  devtool: process.env.NODE_ENV === 'production' ? 'source-map' : 'eval-source-map'\n};","size_bytes":1056},"server/README_DEPLOY.md":{"content":"Run locally:\n\n1\\. cd server\n\n2\\. npm install\n\n3\\. cp .env.example .env   (edit if you want to change SYNC\\_TOKEN)\n\n4\\. node server.js\n\n&nbsp;  -> server runs on http://localhost:4000\n\n\n\nTest endpoints:\n\n\\- GET  http://localhost:4000/health\n\n\\- POST http://localhost:4000/login   { \"username\":\"admin\",\"password\":\"admin123\" }  (only if you created staff)\n\n\\- GET  http://localhost:4000/orders\n\n\\- POST http://localhost:4000/orders  (single order JSON)\n\n\\- POST http://localhost:4000/orders/bulk  (array of orders or { orders: \\[...] })\n\n\n\nDeploy:\n\n\\- Railway / Render / Fly: create a new web service, upload repo or zip, set env vars (DB\\_FILE, SYNC\\_TOKEN), deploy.\n\n\n\n","size_bytes":668},"server/server.js":{"content":"// server.js - Shawarma Boss sync server (Express + SQLite)\nrequire('dotenv').config();\nconst express = require('express');\nconst cors = require('cors');\nconst fs = require('fs');\nconst path = require('path');\nconst bodyParser = require('body-parser');\nconst sqlite3 = require('sqlite3').verbose();\n\nconst PORT = process.env.PORT || 4000;\nconst DB_FILE = process.env.DB_FILE || 'orders.db';\nconst SYNC_TOKEN = process.env.SYNC_TOKEN || ''; // optional\n\nconst app = express();\napp.use(cors());\napp.use(bodyParser.json({ limit: '10mb' }));\n\n// require token middleware (if SYNC_TOKEN set)\nfunction requireToken(req, res, next) {\n  if (!SYNC_TOKEN) return next();\n  const auth = (req.headers['authorization'] || '');\n  if (!auth.startsWith('Bearer ') || auth.split(' ')[1] !== SYNC_TOKEN) {\n    return res.status(401).json({ error: 'Unauthorized - missing/invalid token' });\n  }\n  next();\n}\n\n// Ensure DB folder & open\nconst dbPath = path.join(__dirname, DB_FILE);\nconst dbExists = fs.existsSync(dbPath);\nconst db = new sqlite3.Database(dbPath);\n\ndb.serialize(() => {\n  // users table (staff/admin)\n  db.run(`CREATE TABLE IF NOT EXISTS users (\n    username TEXT PRIMARY KEY,\n    password TEXT,\n    role TEXT,\n    meta TEXT\n  )`);\n\n  // menu items\n  db.run(`CREATE TABLE IF NOT EXISTS menu (\n    id TEXT PRIMARY KEY,\n    name TEXT,\n    price REAL,\n    stock INTEGER,\n    meta TEXT\n  )`);\n\n  // orders (saved as payload JSON + summary fields)\n  db.run(`CREATE TABLE IF NOT EXISTS orders (\n    id TEXT PRIMARY KEY,\n    staff TEXT,\n    timestamp TEXT,\n    total REAL,\n    payload TEXT,\n    serverReceivedAt TEXT\n  )`);\n});\n\n// Helper promises\nfunction runAsync(sql, params=[]) {\n  return new Promise((resolve, reject) => db.run(sql, params, function(err){\n    if(err) return reject(err);\n    resolve(this);\n  }));\n}\nfunction allAsync(sql, params=[]) {\n  return new Promise((resolve,reject)=> db.all(sql, params, (err,rows)=> err?reject(err):resolve(rows)));\n}\nfunction getAsync(sql, params=[]) {\n  return new Promise((resolve,reject)=> db.get(sql, params, (err,row)=> err?reject(err):resolve(row)));\n}\n\n// ----- Endpoints -----\n\n// Health\napp.get('/health', (req,res)=> res.json({ ok:true, db: DB_FILE }));\n\n// LOGIN - simple check against users table\napp.post('/login', requireToken, async (req,res) => {\n  try {\n    const { username, password } = req.body || {};\n    if (!username || !password) return res.status(400).json({ ok:false, error:'username+password required' });\n    const row = await getAsync('SELECT username, role FROM users WHERE username = ? AND password = ?', [username, password]);\n    if (!row) return res.status(401).json({ ok:false, error:'invalid credentials' });\n    res.json({ ok:true, username: row.username, role: row.role });\n  } catch (e) {\n    console.error(e);\n    res.status(500).json({ ok:false, error:e.message });\n  }\n});\n\n// STAFF - GET list\napp.get('/staff', requireToken, async (req,res) => {\n  try {\n    const rows = await allAsync('SELECT username, role, meta FROM users');\n    const mapped = rows.map(r => ({ username: r.username, role: r.role, meta: r.meta ? JSON.parse(r.meta) : null }));\n    res.json(mapped);\n  } catch(e){ res.status(500).json({ error:e.message }); }\n});\n\n// STAFF BULK - upsert many\napp.post('/staff/bulk', requireToken, async (req,res) => {\n  try {\n    const list = Array.isArray(req.body) ? req.body : (req.body.users || []);\n    const accepted = [];\n    await Promise.all(list.map(async u => {\n      if (!u.username) return;\n      const meta = u.meta ? JSON.stringify(u.meta) : null;\n      // upsert\n      await runAsync(`INSERT INTO users (username,password,role,meta) VALUES (?,?,?,?)\n        ON CONFLICT(username) DO UPDATE SET password=excluded.password, role=excluded.role, meta=excluded.meta`, [u.username, u.password||'', u.role||'staff', meta]);\n      accepted.push(u.username);\n    }));\n    res.json({ accepted });\n  } catch(e){ res.status(500).json({ error:e.message }); }\n});\n\n// MENU - GET\napp.get('/menu', requireToken, async (req,res) => {\n  try {\n    const rows = await allAsync('SELECT id,name,price,stock,meta FROM menu');\n    const mapped = rows.map(r => ({ id:r.id, name:r.name, price:r.price, stock:r.stock, meta: r.meta ? JSON.parse(r.meta) : null }));\n    res.json(mapped);\n  } catch(e){ res.status(500).json({ error:e.message }); }\n});\n\n// MENU BULK - upsert\napp.post('/menu/bulk', requireToken, async (req,res) => {\n  try {\n    const list = Array.isArray(req.body) ? req.body : (req.body.menu || []);\n    const accepted = [];\n    await Promise.all(list.map(async it => {\n      const id = it.id || ('m-'+Date.now()+'-'+Math.floor(Math.random()*1000));\n      const meta = it.meta ? JSON.stringify(it.meta) : null;\n      await runAsync(`INSERT INTO menu (id,name,price,stock,meta) VALUES (?,?,?,?,?)\n        ON CONFLICT(id) DO UPDATE SET name=excluded.name, price=excluded.price, stock=excluded.stock, meta=excluded.meta`, [id, it.name||'item', it.price||0, it.stock||0, meta]);\n      accepted.push(id);\n    }));\n    res.json({ accepted });\n  } catch(e){ res.status(500).json({ error:e.message }); }\n});\n\n// ORDERS - GET (recent)\napp.get('/orders', requireToken, async (req,res) => {\n  try {\n    const rows = await allAsync('SELECT id,staff,timestamp,total,payload,serverReceivedAt FROM orders ORDER BY serverReceivedAt DESC LIMIT 500');\n    const mapped = rows.map(r => ({ id:r.id, staff:r.staff, timestamp:r.timestamp, total:r.total, payload: r.payload ? JSON.parse(r.payload) : null, serverReceivedAt: r.serverReceivedAt }));\n    res.json(mapped);\n  } catch(e){ res.status(500).json({ error:e.message }); }\n});\n\n// ORDERS - POST (single)\napp.post('/orders', requireToken, async (req,res) => {\n  try {\n    const order = req.body;\n    if (!order || !order.id) return res.status(400).json({ error:'order with id required' });\n    const payload = JSON.stringify(order);\n    const serverReceivedAt = new Date().toISOString();\n    // insert if not exists\n    await runAsync('INSERT OR IGNORE INTO orders (id,staff,timestamp,total,payload,serverReceivedAt) VALUES (?,?,?,?,?,?)',\n      [order.id, order.user || order.staff || '', order.timestamp || new Date().toISOString(), order.total || 0, payload, serverReceivedAt]);\n    res.json({ accepted: [order.id] });\n  } catch(e){ res.status(500).json({ error:e.message }); }\n});\n\n// ORDERS bulk\napp.post('/orders/bulk', requireToken, async (req,res) => {\n  try {\n    const list = Array.isArray(req.body) ? req.body : (req.body.orders || []);\n    const accepted = [];\n    await Promise.all(list.map(async o => {\n      if (!o || !o.id) return;\n      const exists = await getAsync('SELECT id FROM orders WHERE id = ?', [o.id]);\n      if (exists) return; // skip\n      const payload = JSON.stringify(o);\n      const serverReceivedAt = new Date().toISOString();\n      await runAsync('INSERT INTO orders (id,staff,timestamp,total,payload,serverReceivedAt) VALUES (?,?,?,?,?,?)',\n        [o.id, o.user || o.staff || '', o.timestamp || new Date().toISOString(), o.total || 0, payload, serverReceivedAt]);\n      accepted.push(o.id);\n    }));\n    res.json({ accepted, rejected: [] });\n  } catch(e){ res.status(500).json({ error:e.message }); }\n});\n\n// SALES endpoints - alias to orders\napp.get('/sales', requireToken, async (req,res) => {\n  try {\n    const rows = await allAsync('SELECT id,staff,timestamp,total,payload FROM orders ORDER BY serverReceivedAt DESC LIMIT 500');\n    res.json(rows.map(r => ({ id:r.id, staff:r.staff, timestamp:r.timestamp, total:r.total, payload: r.payload ? JSON.parse(r.payload) : null })));\n  } catch(e){ res.status(500).json({ error:e.message }); }\n});\napp.post('/sales/bulk', requireToken, async (req,res) => {\n  // reuse orders bulk for sales\n  return app._router.handle({ method:'POST', url:'/orders/bulk', headers:req.headers, body:req.body }, res);\n});\n\n// Simple root\napp.get('/', (req,res) => res.json({ ok:true, message:'Shawarma Boss sync server' }));\n\n// Start server\napp.listen(PORT, () => console.log(`Server listening on ${PORT} (DB: ${dbPath})`));\n","size_bytes":8009},"src/App.css":{"content":"/* App-specific styles */\n.App {\n  min-height: 100vh;\n  display: flex;\n  flex-direction: column;\n}\n\n.App main {\n  flex: 1;\n}\n\n/* Loading spinner */\n.spinner {\n  border: 4px solid #f3f3f3;\n  border-top: 4px solid #3498db;\n  border-radius: 50%;\n  width: 40px;\n  height: 40px;\n  animation: spin 2s linear infinite;\n  margin: 0 auto;\n}\n\n@keyframes spin {\n  0% { transform: rotate(0deg); }\n  100% { transform: rotate(360deg); }\n}\n\n/* Custom scrollbar */\n::-webkit-scrollbar {\n  width: 8px;\n}\n\n::-webkit-scrollbar-track {\n  background: #f1f1f1;\n}\n\n::-webkit-scrollbar-thumb {\n  background: #888;\n  border-radius: 4px;\n}\n\n::-webkit-scrollbar-thumb:hover {\n  background: #555;\n}\n\n/* Responsive utilities */\n@media (max-width: 768px) {\n  .container {\n    padding: 0 0.5rem;\n  }\n  \n  .grid-cols-3 {\n    grid-template-columns: repeat(2, 1fr);\n  }\n}\n\n@media (max-width: 480px) {\n  .grid-cols-3,\n  .md\\:grid-cols-3 {\n    grid-template-columns: 1fr;\n  }\n}\n\n/* Animation classes */\n.fade-in {\n  animation: fadeIn 0.3s ease-in;\n}\n\n@keyframes fadeIn {\n  from { opacity: 0; }\n  to { opacity: 1; }\n}\n\n.slide-up {\n  animation: slideUp 0.3s ease-out;\n}\n\n@keyframes slideUp {\n  from {\n    opacity: 0;\n    transform: translateY(20px);\n  }\n  to {\n    opacity: 1;\n    transform: translateY(0);\n  }\n}\n\n/* ===== ADMIN SIDEBAR LAYOUT ===== */\n.admin-layout {\n  min-height: calc(100vh - 100px);\n}\n\n.admin-sidebar {\n  width: 280px;\n  min-width: 280px;\n  box-shadow: 2px 0 4px rgba(0,0,0,0.1);\n}\n\n.admin-sidebar .nav-link {\n  border-radius: 8px;\n  border: none;\n  color: #6c757d;\n  font-weight: 500;\n  padding: 12px 16px;\n  transition: all 0.3s ease;\n}\n\n.admin-sidebar .nav-link:hover {\n  background-color: #f8f9fa;\n  color: #dc3545;\n  transform: translateX(4px);\n}\n\n.admin-sidebar .nav-link.active {\n  background-color: #dc3545;\n  color: white;\n  box-shadow: 0 2px 8px rgba(220, 53, 69, 0.3);\n}\n\n.admin-content {\n  background-color: #f8f9fa;\n  overflow-y: auto;\n  padding: 1.5rem;\n}\n\n/* ===== ENHANCED ADMIN LAYOUT ===== */\n.admin-layout {\n  display: flex;\n  min-height: calc(100vh - 100px);\n  background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);\n}\n\n.admin-sidebar {\n  width: 280px;\n  min-width: 280px;\n  background: white;\n  box-shadow: 2px 0 20px rgba(0,0,0,0.08);\n  display: flex;\n  flex-direction: column;\n  position: relative;\n  z-index: 100;\n}\n\n.sidebar-header {\n  padding: 1.5rem;\n  border-bottom: 1px solid #e2e8f0;\n  background: linear-gradient(135deg, #ffffff 0%, #f8fafc 100%);\n}\n\n.sidebar-brand {\n  display: flex;\n  align-items: center;\n  gap: 0.75rem;\n}\n\n.sidebar-brand i {\n  color: #dc3545;\n  font-size: 1.5rem;\n}\n\n.brand-text {\n  font-size: 1.25rem;\n  font-weight: 700;\n  color: #1e293b;\n}\n\n.sidebar-nav {\n  flex: 1;\n  padding: 1rem;\n}\n\n.nav-item {\n  display: flex;\n  align-items: center;\n  gap: 1rem;\n  width: 100%;\n  padding: 0.875rem 1rem;\n  margin-bottom: 0.5rem;\n  border: none;\n  background: none;\n  border-radius: 12px;\n  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);\n  cursor: pointer;\n  font-weight: 500;\n  color: #64748b;\n  text-align: left;\n}\n\n.nav-item:hover {\n  background: rgba(59, 130, 246, 0.1);\n  color: #3b82f6;\n  transform: translateX(4px);\n}\n\n.nav-item.active {\n  background: linear-gradient(135deg, #dc3545, #b91c1c);\n  color: white;\n  box-shadow: 0 4px 20px rgba(220, 53, 69, 0.3);\n  transform: translateX(8px);\n}\n\n.nav-icon {\n  width: 24px;\n  text-align: center;\n  font-size: 1.1rem;\n}\n\n.nav-label {\n  font-size: 0.9375rem;\n  font-weight: 600;\n}\n\n.content-header {\n  display: flex;\n  align-items: center;\n  justify-content: between;\n  margin-bottom: 2rem;\n  padding-bottom: 1rem;\n  border-bottom: 1px solid rgba(255, 255, 255, 0.2);\n}\n\n.page-title {\n  font-size: 1.875rem;\n  font-weight: 700;\n  color: #1e293b;\n  margin: 0;\n  display: flex;\n  align-items: center;\n  gap: 0.75rem;\n}\n\n.content-body {\n  flex: 1;\n}\n\n/* ===== MODERN KPI CARDS ===== */\n.kpi-grid {\n  margin-bottom: 2rem;\n}\n\n.kpi-card {\n  background: white;\n  border: 1px solid #f1f5f9;\n  border-radius: 16px;\n  padding: 1.5rem;\n  display: flex;\n  align-items: center;\n  gap: 1rem;\n  transition: all 0.3s ease;\n  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04);\n  min-width: 200px;\n}\n\n.kpi-card:hover {\n  transform: translateY(-4px);\n  box-shadow: 0 8px 25px rgba(0, 0, 0, 0.12);\n  border-color: #e2e8f0;\n}\n\n.kpi-icon {\n  width: 60px;\n  height: 60px;\n  border-radius: 16px;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  color: white;\n  font-size: 1.5rem;\n  flex-shrink: 0;\n}\n\n.kpi-content {\n  flex: 1;\n}\n\n.kpi-value {\n  font-size: 1.875rem;\n  font-weight: 700;\n  line-height: 1.2;\n  margin-bottom: 0.25rem;\n}\n\n.kpi-label {\n  font-size: 0.875rem;\n  color: #64748b;\n  font-weight: 500;\n  text-transform: uppercase;\n  letter-spacing: 0.5px;\n}\n\n/* ===== ADMIN PANELS ===== */\n.admin-panel {\n  background: white;\n  border: 1px solid #f1f5f9;\n  border-radius: 20px;\n  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);\n  overflow: hidden;\n  transition: all 0.3s ease;\n}\n\n.admin-panel:hover {\n  box-shadow: 0 8px 30px rgba(0, 0, 0, 0.12);\n  transform: translateY(-2px);\n}\n\n.panel-header {\n  background: linear-gradient(135deg, #ffffff 0%, #f8fafc 100%);\n  padding: 1.5rem;\n  border-bottom: 1px solid #f1f5f9;\n}\n\n.panel-title {\n  font-size: 1.25rem;\n  font-weight: 700;\n  color: #1e293b;\n  margin: 0;\n  display: flex;\n  align-items: center;\n  gap: 0.75rem;\n}\n\n.panel-body {\n  padding: 1.5rem;\n}\n\n/* ===== STAFF CARDS ===== */\n.staff-grid {\n  gap: 1rem;\n}\n\n.staff-card {\n  background: #f8fafc;\n  border: 1px solid #e2e8f0;\n  border-radius: 12px;\n  padding: 1rem;\n  display: flex;\n  align-items: center;\n  gap: 0.75rem;\n  transition: all 0.2s ease;\n  min-width: 200px;\n}\n\n.staff-card:hover {\n  background: white;\n  border-color: #3b82f6;\n  transform: translateY(-2px);\n  box-shadow: 0 4px 12px rgba(59, 130, 246, 0.15);\n}\n\n.staff-avatar {\n  width: 40px;\n  height: 40px;\n  background: linear-gradient(135deg, #3b82f6, #1d4ed8);\n  border-radius: 10px;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  color: white;\n  font-size: 1.1rem;\n  flex-shrink: 0;\n}\n\n.staff-avatar.large {\n  width: 48px;\n  height: 48px;\n  font-size: 1.25rem;\n}\n\n.staff-info {\n  flex: 1;\n}\n\n.staff-name {\n  font-size: 0.9375rem;\n  font-weight: 600;\n  color: #1e293b;\n  margin-bottom: 0.125rem;\n}\n\n.staff-role {\n  font-size: 0.75rem;\n  color: #64748b;\n  text-transform: uppercase;\n  letter-spacing: 0.5px;\n}\n\n.staff-stats {\n  text-align: right;\n  font-size: 0.8125rem;\n}\n\n.stat-orders {\n  font-weight: 600;\n  color: #1e293b;\n}\n\n.stat-sales {\n  font-weight: 600;\n}\n\n/* ===== STAFF MANAGEMENT CARDS ===== */\n.staff-management-grid {\n  gap: 1.25rem;\n}\n\n.staff-management-card {\n  background: white;\n  border: 1px solid #f1f5f9;\n  border-radius: 16px;\n  padding: 1.25rem;\n  transition: all 0.3s ease;\n  min-width: 240px;\n  position: relative;\n}\n\n.staff-management-card:hover {\n  transform: translateY(-4px);\n  box-shadow: 0 8px 25px rgba(0, 0, 0, 0.12);\n  border-color: #e2e8f0;\n}\n\n.staff-card-header {\n  display: flex;\n  justify-content: space-between;\n  align-items: flex-start;\n  margin-bottom: 1rem;\n}\n\n.staff-badge {\n  position: absolute;\n  top: 1rem;\n  right: 1rem;\n}\n\n.staff-card-body {\n  margin-bottom: 1rem;\n}\n\n.staff-performance {\n  display: flex;\n  flex-direction: column;\n  gap: 0.5rem;\n  margin-top: 0.75rem;\n}\n\n.performance-item {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  font-size: 0.8125rem;\n}\n\n.performance-label {\n  color: #64748b;\n  font-weight: 500;\n}\n\n.performance-value {\n  font-weight: 600;\n  color: #1e293b;\n}\n\n.staff-card-actions {\n  display: flex;\n  gap: 0.5rem;\n  justify-content: flex-end;\n}\n\n/* ===== STOCK ALERTS ===== */\n.no-alerts {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  gap: 0.75rem;\n  padding: 2rem;\n  text-align: center;\n  color: #10b981;\n  font-weight: 600;\n  background: #f0fdf4;\n  border-radius: 12px;\n  border: 2px dashed #bbf7d0;\n}\n\n.no-alerts i {\n  font-size: 1.5rem;\n  color: #10b981;\n}\n\n.stock-alerts {\n  max-height: 300px;\n  overflow-y: auto;\n}\n\n.stock-alert {\n  display: flex;\n  align-items: center;\n  gap: 0.75rem;\n  padding: 0.875rem 1rem;\n  border-radius: 12px;\n  transition: all 0.2s ease;\n}\n\n.stock-alert.warning {\n  background: #fffbeb;\n  border: 1px solid #fde68a;\n}\n\n.stock-alert.critical {\n  background: #fef2f2;\n  border: 1px solid #fecaca;\n}\n\n.stock-alert:hover {\n  transform: translateX(4px);\n}\n\n.alert-icon {\n  width: 32px;\n  height: 32px;\n  border-radius: 8px;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  font-size: 1rem;\n  flex-shrink: 0;\n}\n\n.stock-alert.warning .alert-icon {\n  background: #fbbf24;\n  color: white;\n}\n\n.stock-alert.critical .alert-icon {\n  background: #ef4444;\n  color: white;\n}\n\n.alert-content {\n  flex: 1;\n}\n\n.alert-title {\n  font-weight: 600;\n  color: #1e293b;\n  margin-bottom: 0.125rem;\n}\n\n.alert-message {\n  font-size: 0.8125rem;\n  color: #64748b;\n}\n\n/* ===== FORM STYLING ===== */\n.add-staff-form .form-group {\n  margin-bottom: 1.25rem;\n}\n\n.form-label {\n  display: block;\n  font-size: 0.875rem;\n  font-weight: 600;\n  color: #374151;\n  margin-bottom: 0.5rem;\n}\n\n.form-control {\n  border-radius: 8px;\n  border: 1px solid #d1d5db;\n  transition: all 0.2s ease;\n}\n\n.form-control:focus {\n  border-color: #3b82f6;\n  box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);\n}\n\n/* ===== MOBILE ADMIN LAYOUT ===== */\n.admin-layout.mobile {\n  display: flex;\n  flex-direction: column;\n  min-height: 100vh;\n  background: #f8fafc;\n}\n\n.mobile-hidden {\n  display: none !important;\n}\n\n/* ===== MOBILE HEADER ===== */\n.mobile-header {\n  position: sticky;\n  top: 0;\n  z-index: 200;\n  background: white;\n  border-bottom: 1px solid #e2e8f0;\n  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);\n}\n\n.mobile-header-content {\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n  padding: 1rem 1.25rem;\n  max-width: 100%;\n}\n\n.mobile-menu-toggle {\n  width: 44px;\n  height: 44px;\n  border: none;\n  background: #f1f5f9;\n  border-radius: 12px;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  color: #475569;\n  font-size: 1.25rem;\n  transition: all 0.2s ease;\n  cursor: pointer;\n  touch-action: manipulation;\n}\n\n.mobile-menu-toggle:hover,\n.mobile-menu-toggle:active {\n  background: #e2e8f0;\n  color: #dc3545;\n  transform: scale(1.05);\n}\n\n.mobile-page-title {\n  font-size: 1.25rem;\n  font-weight: 700;\n  color: #1e293b;\n  margin: 0;\n  text-align: center;\n  flex: 1;\n  padding: 0 1rem;\n}\n\n.mobile-user-info {\n  display: flex;\n  align-items: center;\n}\n\n.mobile-user-avatar {\n  width: 44px;\n  height: 44px;\n  background: linear-gradient(135deg, #dc3545, #b91c1c);\n  border-radius: 12px;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  color: white;\n  font-size: 1.1rem;\n}\n\n/* ===== MOBILE MENU OVERLAY ===== */\n.mobile-menu-overlay {\n  position: fixed;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  background: rgba(0, 0, 0, 0.5);\n  z-index: 300;\n  animation: fadeIn 0.2s ease;\n}\n\n.mobile-menu {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 320px;\n  max-width: 90vw;\n  height: 100vh;\n  background: white;\n  box-shadow: 4px 0 20px rgba(0, 0, 0, 0.15);\n  animation: slideInLeft 0.3s ease;\n  overflow-y: auto;\n}\n\n.mobile-menu-header {\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n  padding: 1.5rem;\n  border-bottom: 1px solid #e2e8f0;\n  background: linear-gradient(135deg, #dc3545, #b91c1c);\n  color: white;\n}\n\n.mobile-brand {\n  display: flex;\n  align-items: center;\n  gap: 0.75rem;\n  font-size: 1.25rem;\n  font-weight: 700;\n}\n\n.mobile-brand i {\n  font-size: 1.5rem;\n}\n\n.mobile-menu-close {\n  width: 40px;\n  height: 40px;\n  border: none;\n  background: rgba(255, 255, 255, 0.1);\n  border-radius: 10px;\n  color: white;\n  font-size: 1.1rem;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  cursor: pointer;\n  transition: all 0.2s ease;\n}\n\n.mobile-menu-close:hover {\n  background: rgba(255, 255, 255, 0.2);\n}\n\n.mobile-nav {\n  padding: 1rem 0;\n}\n\n.mobile-nav-item {\n  display: flex;\n  align-items: center;\n  gap: 1rem;\n  width: 100%;\n  padding: 1rem 1.5rem;\n  border: none;\n  background: none;\n  color: #475569;\n  font-size: 1rem;\n  font-weight: 500;\n  text-align: left;\n  transition: all 0.2s ease;\n  cursor: pointer;\n  touch-action: manipulation;\n  min-height: 60px;\n}\n\n.mobile-nav-item:hover {\n  background: #f8fafc;\n  color: #dc3545;\n}\n\n.mobile-nav-item.active {\n  background: rgba(220, 53, 69, 0.1);\n  color: #dc3545;\n  border-right: 4px solid #dc3545;\n}\n\n.mobile-nav-icon {\n  width: 24px;\n  text-align: center;\n  font-size: 1.25rem;\n  flex-shrink: 0;\n}\n\n.mobile-nav-label {\n  flex: 1;\n  font-weight: 600;\n}\n\n.mobile-nav-arrow {\n  font-size: 0.875rem;\n  color: #94a3b8;\n  transition: transform 0.2s ease;\n}\n\n.mobile-nav-item:hover .mobile-nav-arrow {\n  transform: translateX(4px);\n}\n\n/* ===== MOBILE BOTTOM NAVIGATION ===== */\n.mobile-bottom-nav {\n  position: fixed;\n  bottom: 0;\n  left: 0;\n  right: 0;\n  background: white;\n  border-top: 1px solid #e2e8f0;\n  box-shadow: 0 -4px 20px rgba(0, 0, 0, 0.1);\n  display: flex;\n  padding: 0.5rem;\n  z-index: 150;\n  safe-area-inset-bottom: env(safe-area-inset-bottom);\n}\n\n.bottom-nav-item {\n  flex: 1;\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  justify-content: center;\n  padding: 0.5rem;\n  border: none;\n  background: none;\n  border-radius: 12px;\n  transition: all 0.2s ease;\n  cursor: pointer;\n  touch-action: manipulation;\n  min-height: 60px;\n  color: #64748b;\n}\n\n.bottom-nav-item:hover {\n  background: rgba(59, 130, 246, 0.1);\n  color: #3b82f6;\n}\n\n.bottom-nav-item.active {\n  background: rgba(220, 53, 69, 0.1);\n  color: #dc3545;\n}\n\n.bottom-nav-icon {\n  font-size: 1.25rem;\n  margin-bottom: 0.25rem;\n  transition: transform 0.2s ease;\n}\n\n.bottom-nav-item:active .bottom-nav-icon {\n  transform: scale(0.95);\n}\n\n.bottom-nav-label {\n  font-size: 0.75rem;\n  font-weight: 600;\n  text-transform: uppercase;\n  letter-spacing: 0.5px;\n  line-height: 1;\n}\n\n/* ===== MOBILE CONTENT ADJUSTMENTS ===== */\n.admin-layout.mobile .admin-content {\n  flex: 1;\n  padding: 1rem;\n  margin-bottom: 80px; /* Space for bottom nav */\n  overflow-y: auto;\n}\n\n.admin-layout.mobile .content-body {\n  padding: 0;\n}\n\n/* ===== MOBILE PANEL OPTIMIZATIONS ===== */\n.admin-layout.mobile .admin-panel {\n  margin-bottom: 1rem;\n  border-radius: 16px;\n}\n\n.admin-layout.mobile .panel-header {\n  padding: 1.25rem;\n}\n\n.admin-layout.mobile .panel-body {\n  padding: 1.25rem;\n}\n\n.admin-layout.mobile .panel-title {\n  font-size: 1.125rem;\n}\n\n/* ===== MOBILE KPI CARDS ===== */\n.admin-layout.mobile .kpi-grid {\n  flex-direction: column;\n  gap: 0.75rem;\n  margin-bottom: 1.5rem;\n}\n\n.admin-layout.mobile .kpi-card {\n  min-width: auto;\n  padding: 1.25rem;\n  border-radius: 16px;\n}\n\n.admin-layout.mobile .kpi-icon {\n  width: 48px;\n  height: 48px;\n  font-size: 1.25rem;\n}\n\n.admin-layout.mobile .kpi-value {\n  font-size: 1.5rem;\n}\n\n/* ===== MOBILE STAFF CARDS ===== */\n.admin-layout.mobile .staff-grid,\n.admin-layout.mobile .staff-management-grid {\n  flex-direction: column;\n  gap: 0.75rem;\n}\n\n.admin-layout.mobile .staff-card,\n.admin-layout.mobile .staff-management-card {\n  min-width: auto;\n}\n\n/* ===== MOBILE FORM IMPROVEMENTS ===== */\n.admin-layout.mobile .form-control {\n  font-size: 16px; /* Prevents zoom on iOS */\n  padding: 0.875rem;\n  border-radius: 12px;\n}\n\n.admin-layout.mobile .btn {\n  min-height: 44px;\n  font-size: 1rem;\n  border-radius: 12px;\n  font-weight: 600;\n}\n\n/* ===== MOBILE ANIMATIONS ===== */\n@keyframes fadeIn {\n  from { opacity: 0; }\n  to { opacity: 1; }\n}\n\n@keyframes slideInLeft {\n  from { transform: translateX(-100%); }\n  to { transform: translateX(0); }\n}\n\n/* ===== RESPONSIVE ADMIN LAYOUT (UPDATED) ===== */\n@media (max-width: 1200px) {\n  .admin-grid-layout {\n    flex-direction: column;\n  }\n  \n  .kpi-grid {\n    flex-direction: column;\n    gap: 1rem;\n  }\n  \n  .kpi-card {\n    min-width: auto;\n  }\n}\n\n@media (max-width: 992px) {\n  .admin-sidebar:not(.mobile-hidden) {\n    position: fixed;\n    left: -280px;\n    top: 0;\n    height: 100vh;\n    z-index: 1000;\n    transition: left 0.3s ease;\n  }\n  \n  .admin-sidebar.open {\n    left: 0;\n  }\n  \n  .admin-content {\n    width: 100%;\n    padding: 1rem;\n  }\n  \n  .staff-management-grid {\n    flex-direction: column;\n  }\n  \n  .staff-management-card {\n    min-width: auto;\n  }\n}\n\n@media (max-width: 768px) {\n  .kpi-grid {\n    gap: 0.75rem;\n  }\n  \n  .kpi-card {\n    flex-direction: column;\n    text-align: center;\n    padding: 1.25rem;\n  }\n  \n  .kpi-icon {\n    width: 48px;\n    height: 48px;\n    font-size: 1.25rem;\n  }\n  \n  .staff-grid {\n    flex-direction: column;\n  }\n  \n  .staff-card {\n    min-width: auto;\n  }\n  \n  .page-title {\n    font-size: 1.5rem;\n  }\n  \n  .panel-title {\n    font-size: 1.125rem;\n  }\n}\n\n@media (max-width: 480px) {\n  .admin-content {\n    padding: 0.75rem;\n  }\n  \n  .kpi-value {\n    font-size: 1.5rem;\n  }\n  \n  .kpi-label {\n    font-size: 0.8125rem;\n  }\n  \n  .panel-header,\n  .panel-body {\n    padding: 1rem;\n  }\n  \n  .mobile-page-title {\n    font-size: 1.125rem;\n  }\n  \n  .mobile-menu {\n    width: 100%;\n    max-width: 100vw;\n  }\n  \n  .bottom-nav-label {\n    font-size: 0.6875rem;\n  }\n}\n\n/* ===== PWA STAFF LAYOUT ===== */\n.pwa-staff-layout {\n  min-height: calc(100vh - 80px);\n  background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);\n  display: flex;\n  flex-direction: column;\n}\n\n/* PWA Navigation Tabs */\n.pwa-nav-tabs {\n  background: white;\n  border-bottom: 1px solid #e2e8f0;\n  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);\n  position: sticky;\n  top: 0;\n  z-index: 100;\n}\n\n.pwa-nav-container {\n  display: flex;\n  justify-content: center;\n  padding: 0.5rem 1rem;\n  max-width: 1200px;\n  margin: 0 auto;\n  gap: 0.5rem;\n}\n\n.pwa-nav-tab {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  justify-content: center;\n  padding: 0.75rem 1rem;\n  border: none;\n  background: none;\n  border-radius: 12px;\n  transition: all 0.2s ease;\n  cursor: pointer;\n  min-width: 80px;\n  color: #64748b;\n  font-weight: 500;\n}\n\n.pwa-nav-tab:hover {\n  background: rgba(59, 130, 246, 0.1);\n  color: #3b82f6;\n  transform: translateY(-2px);\n}\n\n.pwa-nav-tab.active {\n  background: linear-gradient(135deg, #3b82f6, #1d4ed8);\n  color: white;\n  box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);\n}\n\n.pwa-tab-icon {\n  font-size: 1.25rem;\n  margin-bottom: 0.25rem;\n}\n\n.pwa-tab-label {\n  font-size: 0.75rem;\n  font-weight: 600;\n  text-transform: uppercase;\n  letter-spacing: 0.5px;\n}\n\n/* PWA Main Content */\n.pwa-main-content {\n  flex: 1;\n  display: flex;\n  flex-direction: column;\n  max-width: 1400px;\n  margin: 0 auto;\n  width: 100%;\n  padding: 0 1rem;\n}\n\n.pwa-main-header {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  padding: 1.5rem 0;\n  border-bottom: 1px solid rgba(255, 255, 255, 0.2);\n  margin-bottom: 1.5rem;\n}\n\n.pwa-header-info {\n  flex: 1;\n}\n\n.pwa-main-title {\n  font-size: 1.875rem;\n  font-weight: 700;\n  color: #1e293b;\n  margin: 0 0 0.25rem 0;\n  display: flex;\n  align-items: center;\n  gap: 0.75rem;\n}\n\n.pwa-main-title i {\n  color: #3b82f6;\n}\n\n.pwa-main-subtitle {\n  color: #64748b;\n  margin: 0;\n  font-size: 0.875rem;\n}\n\n.pwa-header-user {\n  display: flex;\n  align-items: center;\n  gap: 0.75rem;\n  background: white;\n  padding: 0.75rem 1rem;\n  border-radius: 16px;\n  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);\n}\n\n.pwa-user-avatar {\n  width: 40px;\n  height: 40px;\n  background: linear-gradient(135deg, #3b82f6, #1d4ed8);\n  border-radius: 50%;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  color: white;\n  font-size: 1.1rem;\n}\n\n.pwa-user-info {\n  display: flex;\n  flex-direction: column;\n}\n\n.pwa-user-name {\n  font-weight: 600;\n  color: #1e293b;\n  font-size: 0.875rem;\n}\n\n.pwa-user-role {\n  color: #64748b;\n  font-size: 0.75rem;\n  text-transform: uppercase;\n  letter-spacing: 0.5px;\n}\n\n.pwa-content-area {\n  flex: 1;\n}\n\n/* ===== PWA POS GRID LAYOUT ===== */\n.pwa-pos-grid {\n  display: grid;\n  grid-template-columns: 1fr 400px;\n  gap: 1.5rem;\n  height: calc(100vh - 280px);\n  min-height: 600px;\n}\n\n.pwa-menu-section,\n.pwa-cart-section {\n  display: flex;\n  flex-direction: column;\n  background: white;\n  border-radius: 20px;\n  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);\n  overflow: hidden;\n}\n\n.pwa-section-header {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  padding: 1.25rem 1.5rem;\n  border-bottom: 1px solid #f1f5f9;\n  background: linear-gradient(135deg, #ffffff 0%, #f8fafc 100%);\n}\n\n.pwa-header-content {\n  display: flex;\n  align-items: center;\n  gap: 1rem;\n}\n\n.pwa-header-icon {\n  width: 48px;\n  height: 48px;\n  background: linear-gradient(135deg, #f59e0b, #d97706);\n  border-radius: 14px;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  color: white;\n  font-size: 1.25rem;\n}\n\n.pwa-cart-icon {\n  background: linear-gradient(135deg, #10b981, #059669);\n}\n\n.pwa-header-text {\n  display: flex;\n  flex-direction: column;\n}\n\n.pwa-section-title {\n  font-size: 1.125rem;\n  font-weight: 700;\n  color: #1e293b;\n  margin: 0;\n}\n\n.pwa-section-subtitle {\n  color: #64748b;\n  font-size: 0.8125rem;\n  margin: 0;\n}\n\n.pwa-header-actions {\n  display: flex;\n  gap: 0.5rem;\n}\n\n.pwa-refresh-btn {\n  width: 40px;\n  height: 40px;\n  background: none;\n  border: 1px solid #e2e8f0;\n  border-radius: 10px;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  color: #64748b;\n  transition: all 0.2s ease;\n  cursor: pointer;\n}\n\n.pwa-refresh-btn:hover {\n  background: #f1f5f9;\n  color: #3b82f6;\n  border-color: #3b82f6;\n}\n\n.pwa-cart-total {\n  display: flex;\n  flex-direction: column;\n  align-items: flex-end;\n  text-align: right;\n}\n\n.pwa-total-label {\n  color: #64748b;\n  font-size: 0.75rem;\n  text-transform: uppercase;\n  letter-spacing: 0.5px;\n  font-weight: 600;\n}\n\n.pwa-total-amount {\n  color: #10b981;\n  font-size: 1.25rem;\n  font-weight: 700;\n  line-height: 1.2;\n}\n\n.pwa-menu-container,\n.pwa-cart-container {\n  flex: 1;\n  overflow-y: auto;\n  padding: 1rem;\n}\n\n/* ===== PWA RESPONSIVE DESIGN ===== */\n@media (max-width: 1200px) {\n  .pwa-pos-grid {\n    grid-template-columns: 1fr 350px;\n  }\n}\n\n@media (max-width: 992px) {\n  .pwa-pos-grid {\n    grid-template-columns: 1fr;\n    grid-template-rows: 1fr auto;\n    height: auto;\n    min-height: auto;\n  }\n  \n  .pwa-cart-section {\n    order: -1;\n    max-height: 400px;\n  }\n  \n  .pwa-main-header {\n    flex-direction: column;\n    gap: 1rem;\n    align-items: flex-start;\n  }\n  \n  .pwa-header-user {\n    align-self: stretch;\n    justify-content: center;\n  }\n}\n\n@media (max-width: 768px) {\n  .pwa-nav-container {\n    justify-content: flex-start;\n    overflow-x: auto;\n    padding-bottom: 0.5rem;\n  }\n  \n  .pwa-nav-tab {\n    min-width: 70px;\n    padding: 0.5rem 0.75rem;\n  }\n  \n  .pwa-tab-label {\n    font-size: 0.65rem;\n  }\n  \n  .pwa-main-content {\n    padding: 0 0.75rem;\n  }\n  \n  .pwa-main-title {\n    font-size: 1.5rem;\n  }\n  \n  .pwa-pos-grid {\n    gap: 1rem;\n  }\n  \n  .pwa-section-header {\n    padding: 1rem 1.25rem;\n  }\n  \n  .pwa-header-icon {\n    width: 40px;\n    height: 40px;\n    font-size: 1.1rem;\n  }\n}\n\n@media (max-width: 480px) {\n  .pwa-nav-tab {\n    min-width: 60px;\n    padding: 0.5rem;\n  }\n  \n  .pwa-tab-icon {\n    font-size: 1.1rem;\n    margin-bottom: 0.125rem;\n  }\n  \n  .pwa-tab-label {\n    font-size: 0.625rem;\n  }\n  \n  .pwa-main-content {\n    padding: 0 0.5rem;\n  }\n  \n  .pwa-main-header {\n    padding: 1rem 0;\n  }\n  \n  .pwa-header-content {\n    gap: 0.75rem;\n  }\n}\n\n/* ===== PWA MENU GRID STYLES ===== */\n.pos-menu-grid {\n  display: grid;\n  grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));\n  gap: 1.25rem;\n  padding: 0.5rem 0;\n  width: 100%;\n}\n\n.menu-item-card {\n  background: white;\n  border: 1px solid #f1f5f9;\n  border-radius: 16px;\n  padding: 1.25rem;\n  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);\n  cursor: pointer;\n  position: relative;\n  overflow: hidden;\n  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04);\n}\n\n.menu-item-card::before {\n  content: '';\n  position: absolute;\n  top: 0;\n  left: 0;\n  right: 0;\n  height: 4px;\n  background: linear-gradient(90deg, #f59e0b, #d97706);\n  transform: scaleX(0);\n  transition: transform 0.3s ease;\n}\n\n.menu-item-card:hover {\n  transform: translateY(-6px);\n  box-shadow: 0 12px 32px rgba(0, 0, 0, 0.12);\n  border-color: #f59e0b;\n}\n\n.menu-item-card:hover::before {\n  transform: scaleX(1);\n}\n\n.menu-item-card:active {\n  transform: translateY(-2px) scale(0.98);\n}\n\n.menu-item-header {\n  display: flex;\n  justify-content: space-between;\n  align-items: flex-start;\n  margin-bottom: 1rem;\n  gap: 1rem;\n}\n\n.menu-item-name {\n  font-size: 1.125rem;\n  font-weight: 700;\n  color: #1e293b;\n  margin: 0;\n  line-height: 1.3;\n  flex: 1;\n}\n\n.menu-item-price {\n  background: linear-gradient(135deg, #10b981, #059669);\n  color: white;\n  font-size: 1.125rem;\n  font-weight: 700;\n  padding: 0.375rem 0.75rem;\n  border-radius: 12px;\n  text-align: center;\n  box-shadow: 0 2px 8px rgba(16, 185, 129, 0.25);\n  white-space: nowrap;\n}\n\n.menu-item-stock {\n  font-size: 0.8125rem;\n  font-weight: 600;\n  margin-bottom: 1.25rem;\n  display: flex;\n  align-items: center;\n  gap: 0.5rem;\n  padding: 0.5rem 0.75rem;\n  border-radius: 10px;\n  background: #f8fafc;\n}\n\n.stock-out {\n  color: #ef4444 !important;\n  background: #fef2f2 !important;\n}\n\n.stock-low {\n  color: #f59e0b !important;\n  background: #fffbeb !important;\n}\n\n.stock-good {\n  color: #10b981 !important;\n  background: #f0fdfa !important;\n}\n\n.menu-item-actions {\n  display: flex;\n  flex-direction: column;\n  gap: 1rem;\n}\n\n.quantity-selector {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  gap: 0.75rem;\n  background: #f8fafc;\n  border-radius: 12px;\n  padding: 0.5rem;\n}\n\n.qty-btn {\n  width: 40px;\n  height: 40px;\n  padding: 0;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  border-radius: 10px;\n  border: 1px solid #e2e8f0;\n  background: white;\n  color: #64748b;\n  font-weight: 600;\n  transition: all 0.2s ease;\n  touch-action: manipulation;\n}\n\n.qty-btn:hover:not(:disabled) {\n  background: #3b82f6;\n  color: white;\n  border-color: #3b82f6;\n  transform: scale(1.05);\n}\n\n.qty-btn:disabled {\n  opacity: 0.5;\n  cursor: not-allowed;\n}\n\n.qty-input {\n  width: 60px;\n  height: 40px;\n  text-align: center;\n  font-weight: 700;\n  font-size: 1rem;\n  border: 1px solid #e2e8f0;\n  border-radius: 10px;\n  background: white;\n  color: #1e293b;\n}\n\n.qty-input:focus {\n  border-color: #3b82f6;\n  box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);\n  outline: none;\n}\n\n.add-to-cart-btn {\n  font-weight: 700;\n  padding: 0.875rem 1.25rem;\n  border-radius: 12px;\n  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);\n  border: none;\n  font-size: 0.9375rem;\n  position: relative;\n  overflow: hidden;\n  touch-action: manipulation;\n}\n\n.add-to-cart-btn:not(:disabled) {\n  background: linear-gradient(135deg, #dc2626, #b91c1c);\n  color: white;\n  box-shadow: 0 4px 12px rgba(220, 38, 38, 0.3);\n}\n\n.add-to-cart-btn:hover:not(:disabled) {\n  transform: translateY(-2px);\n  box-shadow: 0 8px 20px rgba(220, 38, 38, 0.4);\n}\n\n.add-to-cart-btn:active:not(:disabled) {\n  transform: translateY(0) scale(0.98);\n}\n\n.add-to-cart-btn:disabled {\n  background: #e2e8f0;\n  color: #94a3b8;\n  box-shadow: none;\n  cursor: not-allowed;\n}\n\n.no-menu-items {\n  grid-column: 1 / -1;\n  text-align: center;\n  padding: 4rem 2rem;\n  color: #64748b;\n  background: white;\n  border-radius: 16px;\n  border: 2px dashed #e2e8f0;\n}\n\n.no-menu-items i {\n  margin-bottom: 1rem;\n  color: #cbd5e1;\n}\n\n/* ===== PWA CART STYLES ===== */\n.pwa-cart-wrapper {\n  height: 100%;\n  display: flex;\n  flex-direction: column;\n}\n\n.pwa-cart-container .card {\n  background: none;\n  border: none;\n  box-shadow: none;\n}\n\n.pwa-cart-container .card-body {\n  padding: 0;\n}\n\n.pwa-cart-header {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  margin-bottom: 1.25rem;\n  padding: 1rem;\n  background: #f8fafc;\n  border-radius: 12px;\n}\n\n.pwa-cart-title {\n  font-size: 1.125rem;\n  font-weight: 700;\n  color: #1e293b;\n  margin: 0;\n}\n\n.pwa-cart-actions {\n  display: flex;\n  gap: 0.5rem;\n}\n\n.pwa-cart-btn {\n  padding: 0.5rem 0.75rem;\n  border-radius: 8px;\n  font-weight: 600;\n  font-size: 0.875rem;\n  border: none;\n  transition: all 0.2s ease;\n  touch-action: manipulation;\n  display: flex;\n  align-items: center;\n  gap: 0.25rem;\n}\n\n.pwa-cart-btn.clear {\n  background: #fef2f2;\n  color: #dc2626;\n}\n\n.pwa-cart-btn.clear:hover:not(:disabled) {\n  background: #fee2e2;\n  transform: translateY(-1px);\n}\n\n.pwa-cart-btn.confirm {\n  background: linear-gradient(135deg, #10b981, #059669);\n  color: white;\n}\n\n.pwa-cart-btn.confirm:hover:not(:disabled) {\n  transform: translateY(-1px);\n  box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3);\n}\n\n.pwa-cart-btn:disabled {\n  opacity: 0.5;\n  cursor: not-allowed;\n}\n\n.pwa-cart-items {\n  flex: 1;\n  display: flex;\n  flex-direction: column;\n  gap: 0.75rem;\n  margin-bottom: 1.25rem;\n  min-height: 200px;\n  overflow-y: auto;\n}\n\n.pwa-cart-empty {\n  flex: 1;\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n  align-items: center;\n  text-align: center;\n  padding: 2rem 1rem;\n  color: #64748b;\n}\n\n.pwa-cart-empty i {\n  color: #cbd5e1;\n  margin-bottom: 0.5rem;\n}\n\n.pwa-cart-empty p {\n  font-weight: 600;\n  margin: 0 0 0.25rem 0;\n  color: #475569;\n}\n\n.pwa-cart-empty span {\n  font-size: 0.875rem;\n}\n\n.pwa-cart-item {\n  background: white;\n  border: 1px solid #f1f5f9;\n  border-radius: 12px;\n  padding: 1rem;\n  transition: all 0.2s ease;\n}\n\n.pwa-cart-item:hover {\n  border-color: #e2e8f0;\n  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04);\n}\n\n.pwa-item-info {\n  margin-bottom: 0.75rem;\n}\n\n.pwa-item-name {\n  font-size: 0.9375rem;\n  font-weight: 600;\n  color: #1e293b;\n  margin: 0 0 0.25rem 0;\n}\n\n.pwa-item-price {\n  font-size: 0.8125rem;\n  color: #64748b;\n}\n\n.pwa-item-controls {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  gap: 0.75rem;\n}\n\n.pwa-quantity-controls {\n  display: flex;\n  align-items: center;\n  gap: 0.5rem;\n  background: #f8fafc;\n  border-radius: 8px;\n  padding: 0.25rem;\n}\n\n.pwa-qty-btn {\n  width: 32px;\n  height: 32px;\n  border-radius: 6px;\n  border: 1px solid #e2e8f0;\n  background: white;\n  color: #64748b;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  font-size: 0.75rem;\n  font-weight: 600;\n  transition: all 0.2s ease;\n  touch-action: manipulation;\n}\n\n.pwa-qty-btn:hover {\n  background: #3b82f6;\n  color: white;\n  border-color: #3b82f6;\n}\n\n.pwa-qty-input {\n  width: 45px;\n  height: 32px;\n  text-align: center;\n  font-weight: 600;\n  font-size: 0.875rem;\n  border: 1px solid #e2e8f0;\n  border-radius: 6px;\n  background: white;\n  color: #1e293b;\n}\n\n.pwa-qty-input:focus {\n  border-color: #3b82f6;\n  box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.1);\n  outline: none;\n}\n\n.pwa-item-total {\n  font-size: 0.9375rem;\n  font-weight: 700;\n  color: #10b981;\n  min-width: 80px;\n  text-align: center;\n}\n\n.pwa-remove-btn {\n  width: 32px;\n  height: 32px;\n  border-radius: 6px;\n  border: 1px solid #fecaca;\n  background: #fef2f2;\n  color: #dc2626;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  font-size: 0.75rem;\n  transition: all 0.2s ease;\n  touch-action: manipulation;\n}\n\n.pwa-remove-btn:hover {\n  background: #fee2e2;\n  transform: scale(1.05);\n}\n\n.pwa-cart-summary {\n  border-top: 2px solid #f1f5f9;\n  padding-top: 1rem;\n  margin-top: auto;\n}\n\n.pwa-cart-total {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  padding: 1rem;\n  background: linear-gradient(135deg, #f0fdf4, #dcfce7);\n  border-radius: 12px;\n  border: 1px solid #bbf7d0;\n}\n\n.pwa-total-label {\n  font-size: 1rem;\n  font-weight: 600;\n  color: #166534;\n}\n\n.pwa-total-value {\n  font-size: 1.25rem;\n  font-weight: 700;\n  color: #15803d;\n}\n\n/* ===== RESPONSIVE MENU GRID ===== */\n@media (max-width: 1400px) {\n  .pos-menu-grid {\n    grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));\n  }\n}\n\n@media (max-width: 1200px) {\n  .pos-menu-grid {\n    grid-template-columns: repeat(auto-fill, minmax(260px, 1fr));\n  }\n}\n\n@media (max-width: 992px) {\n  .pos-menu-grid {\n    grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));\n    gap: 1rem;\n  }\n  \n  .menu-item-card {\n    padding: 1rem;\n  }\n}\n\n@media (max-width: 768px) {\n  .pos-menu-grid {\n    grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));\n    gap: 0.75rem;\n  }\n  \n  .menu-item-name {\n    font-size: 1rem;\n  }\n  \n  .menu-item-price {\n    font-size: 1rem;\n    padding: 0.25rem 0.5rem;\n  }\n  \n  .qty-btn,\n  .qty-input {\n    height: 36px;\n  }\n  \n  .qty-btn {\n    width: 36px;\n  }\n  \n  .qty-input {\n    width: 50px;\n    font-size: 0.875rem;\n  }\n}\n\n@media (max-width: 600px) {\n  .pos-menu-grid {\n    grid-template-columns: 1fr;\n    gap: 1rem;\n  }\n  \n  .menu-item-header {\n    margin-bottom: 0.75rem;\n  }\n  \n  .quantity-selector {\n    gap: 0.5rem;\n    padding: 0.375rem;\n  }\n  \n  .add-to-cart-btn {\n    padding: 0.75rem 1rem;\n    font-size: 0.875rem;\n  }\n}\n\n/* ===== RESPONSIVE DESIGN ===== */\n\n@media (max-width: 992px) {\n  .admin-sidebar {\n    width: 100%;\n    min-width: unset;\n    position: fixed;\n    top: 0;\n    left: 0;\n    z-index: 1000;\n    height: 100vh;\n    transform: translateX(-100%);\n    transition: transform 0.3s ease;\n  }\n  \n  .admin-sidebar.show {\n    transform: translateX(0);\n  }\n  \n  .pos-menu-grid {\n    grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));\n  }\n  \n  .pos-header {\n    padding: 1rem;\n  }\n}\n\n@media (max-width: 768px) {\n  .menu-item-card {\n    padding: 0.75rem;\n  }\n  \n  .menu-item-name {\n    font-size: 1rem;\n  }\n  \n  .menu-item-price {\n    font-size: 1.1rem;\n  }\n  \n  .pos-menu-grid {\n    grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));\n    gap: 0.75rem;\n  }\n}\n\n@media (max-width: 576px) {\n  .pos-menu-grid {\n    grid-template-columns: 1fr;\n  }\n  \n  .quantity-selector {\n    justify-content: space-between;\n  }\n  \n  .admin-layout {\n    flex-direction: column;\n  }\n}\n\n/* ===== MODERN PWA NAVBAR ===== */\n.modern-navbar {\n  background: #ffffff;\n  border-bottom: 1px solid #e2e8f0;\n  box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);\n  position: sticky;\n  top: 0;\n  z-index: 1030;\n  backdrop-filter: blur(10px);\n  -webkit-backdrop-filter: blur(10px);\n}\n\n.navbar-container {\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n  padding: 0.75rem 1.5rem;\n  max-width: 1400px;\n  margin: 0 auto;\n  gap: 2rem;\n}\n\n/* Brand Section */\n.navbar-brand {\n  display: flex;\n  align-items: center;\n  gap: 0.75rem;\n  background: none;\n  border: none;\n  padding: 0.5rem;\n  border-radius: 12px;\n  transition: all 0.2s ease;\n  cursor: pointer;\n}\n\n.navbar-brand:hover {\n  background: rgba(220, 53, 69, 0.05);\n  transform: translateY(-1px);\n}\n\n.brand-icon {\n  position: relative;\n}\n\n.brand-logo {\n  width: 40px;\n  height: 40px;\n  border-radius: 10px;\n  object-fit: cover;\n  box-shadow: 0 4px 12px rgba(220, 53, 69, 0.2);\n  transition: all 0.3s ease;\n}\n\n.navbar-brand:hover .brand-logo {\n  transform: scale(1.05);\n  box-shadow: 0 6px 20px rgba(220, 53, 69, 0.3);\n}\n\n.brand-content {\n  display: flex;\n  flex-direction: column;\n  align-items: flex-start;\n}\n\n.brand-title {\n  font-size: 1.25rem;\n  font-weight: 700;\n  color: #000000;\n  margin: 0;\n  display: flex;\n  align-items: center;\n  gap: 0.5rem;\n}\n\n.brand-badge {\n  background: #f3f4f6;\n  color: #000000;\n  font-size: 0.65rem;\n  font-weight: 600;\n  padding: 0.15rem 0.4rem;\n  border-radius: 8px;\n  text-transform: uppercase;\n  letter-spacing: 0.5px;\n}\n\n.brand-subtitle {\n  font-size: 0.75rem;\n  color: #000000;\n  margin: 0;\n  font-weight: 500;\n}\n\n/* Navigation Tabs */\n.nav-tabs {\n  flex: 1;\n  display: flex;\n  justify-content: center;\n}\n\n.nav-tab-list {\n  display: flex;\n  align-items: center;\n  background: #f1f5f9;\n  border-radius: 12px;\n  padding: 0.25rem;\n  gap: 0.25rem;\n}\n\n.nav-tab {\n  display: flex;\n  align-items: center;\n  gap: 0.5rem;\n  background: transparent;\n  border: none;\n  padding: 0.75rem 1.25rem;\n  border-radius: 10px;\n  font-weight: 500;\n  font-size: 0.875rem;\n  color: #000000;\n  transition: all 0.2s ease;\n  cursor: pointer;\n  position: relative;\n}\n\n.nav-tab:hover {\n  color: #000000;\n  background: rgba(220, 53, 69, 0.08);\n}\n\n.nav-tab.active {\n  background: #ffffff;\n  color: #000000;\n  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);\n  font-weight: 600;\n}\n\n.nav-tab.active::after {\n  content: '';\n  position: absolute;\n  bottom: -0.25rem;\n  left: 50%;\n  transform: translateX(-50%);\n  width: 20px;\n  height: 3px;\n  background: linear-gradient(135deg, #dc3545, #c82333);\n  border-radius: 2px;\n}\n\n.tab-icon {\n  font-size: 1rem;\n}\n\n.tab-label {\n  font-weight: inherit;\n}\n\n/* User Profile */\n.user-profile {\n  display: flex;\n  align-items: center;\n}\n\n.user-info {\n  display: flex;\n  align-items: center;\n  gap: 0.75rem;\n  position: relative;\n}\n\n.user-avatar {\n  width: 36px;\n  height: 36px;\n  background: linear-gradient(135deg, #dc3545, #c82333);\n  border-radius: 50%;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  color: white;\n  font-size: 1.1rem;\n  box-shadow: 0 2px 8px rgba(220, 53, 69, 0.2);\n}\n\n.user-details {\n  display: flex;\n  flex-direction: column;\n  align-items: flex-start;\n}\n\n.user-name {\n  font-weight: 600;\n  color: #000000;\n  font-size: 0.875rem;\n  line-height: 1.2;\n}\n\n.user-role {\n  font-size: 0.75rem;\n  font-weight: 500;\n  display: flex;\n  align-items: center;\n  padding: 0.125rem 0.375rem;\n  border-radius: 6px;\n  margin-top: 0.125rem;\n  color: #000000;\n}\n\n.role-admin {\n  background: #f3f4f6;\n  color: #000000;\n}\n\n.role-staff {\n  background: #f3f4f6;\n  color: #000000;\n}\n\n.user-menu-btn {\n  background: none;\n  border: none;\n  color: #000000;\n  padding: 0.5rem;\n  border-radius: 8px;\n  transition: all 0.2s ease;\n  cursor: pointer;\n}\n\n.user-menu-btn:hover {\n  background: #f3f4f6;\n  color: #dc3545;\n}\n\n/* Modern Dropdown */\n.modern-dropdown {\n  background: white;\n  border: 1px solid #e5e7eb;\n  border-radius: 12px;\n  box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);\n  padding: 0.5rem;\n  min-width: 220px;\n  margin-top: 0.5rem;\n}\n\n.modern-dropdown .dropdown-header {\n  padding: 0.75rem;\n  border: none;\n  background: none;\n}\n\n.dropdown-user-info {\n  display: flex;\n  align-items: center;\n  gap: 0.75rem;\n}\n\n.dropdown-avatar {\n  width: 32px;\n  height: 32px;\n  background: linear-gradient(135deg, #dc3545, #c82333);\n  border-radius: 50%;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  color: white;\n  font-size: 1rem;\n}\n\n.dropdown-name {\n  font-weight: 600;\n  color: #000000;\n  font-size: 0.875rem;\n}\n\n.dropdown-role {\n  font-size: 0.75rem;\n  font-weight: 500;\n  display: flex;\n  align-items: center;\n  padding: 0.125rem 0.375rem;\n  border-radius: 6px;\n  margin-top: 0.125rem;\n  color: #000000;\n  background: #f3f4f6;\n}\n\n.logout-item {\n  border: none;\n  background: none;\n  width: 100%;\n  padding: 0.75rem;\n  border-radius: 8px;\n  transition: all 0.2s ease;\n  cursor: pointer;\n}\n\n.logout-item:hover {\n  background: #fee2e2;\n  color: #dc2626;\n}\n\n.dropdown-item-content {\n  display: flex;\n  align-items: center;\n  gap: 0.75rem;\n  font-weight: 500;\n}\n\n/* PWA Indicator */\n.pwa-indicator {\n  position: absolute;\n  top: 0.5rem;\n  right: 0.5rem;\n  width: 8px;\n  height: 8px;\n  background: #10b981;\n  border-radius: 50%;\n  animation: pulse 2s infinite;\n}\n\n/* Mobile Responsive Styles */\n@media (max-width: 768px) {\n  .navbar-container {\n    padding: 0.5rem 1rem;\n    gap: 1rem;\n  }\n  \n  .brand-logo {\n    width: 32px;\n    height: 32px;\n  }\n  \n  .brand-title {\n    font-size: 1.1rem;\n  }\n  \n  .brand-badge {\n    font-size: 0.6rem;\n    padding: 0.1rem 0.3rem;\n  }\n  \n  .brand-subtitle {\n    display: none;\n  }\n  \n  .nav-tab {\n    padding: 0.6rem 1rem;\n    font-size: 0.8rem;\n  }\n  \n  .tab-label {\n    display: none;\n  }\n  \n  .user-details {\n    display: none !important;\n  }\n  \n  .user-avatar {\n    width: 32px;\n    height: 32px;\n    font-size: 1rem;\n  }\n}\n\n@media (max-width: 480px) {\n  .navbar-container {\n    padding: 0.5rem 0.75rem;\n  }\n  \n  .brand-title {\n    font-size: 1rem;\n  }\n  \n  .nav-tab-list {\n    padding: 0.2rem;\n    gap: 0.2rem;\n  }\n  \n  .nav-tab {\n    padding: 0.5rem 0.8rem;\n  }\n  \n  .tab-icon {\n    font-size: 0.9rem;\n  }\n  \n  .modern-dropdown {\n    min-width: 180px;\n  }\n}\n\n/* Dark mode support - Override to maintain white background and black text */\n@media (prefers-color-scheme: dark) {\n  .modern-navbar {\n    background: #ffffff !important;\n    border-bottom: 1px solid #e2e8f0 !important;\n  }\n  \n  .brand-title {\n    color: #000000 !important;\n  }\n  \n  .brand-subtitle {\n    color: #000000 !important;\n  }\n  \n  .nav-tab-list {\n    background: #f1f5f9 !important;\n  }\n  \n  .nav-tab {\n    color: #000000 !important;\n  }\n  \n  .nav-tab:hover {\n    background: rgba(220, 53, 69, 0.08) !important;\n    color: #000000 !important;\n  }\n  \n  .nav-tab.active {\n    background: #ffffff !important;\n    color: #000000 !important;\n  }\n  \n  .user-name {\n    color: #000000 !important;\n  }\n  \n  .modern-dropdown {\n    background: white !important;\n    border: 1px solid #e5e7eb !important;\n  }\n  \n  .dropdown-name {\n    color: #000000 !important;\n  }\n  \n  .mobile-menu-toggle {\n    color: #000000 !important;\n  }\n  \n  .notification-btn {\n    color: #000000 !important;\n  }\n  \n  .user-menu-btn {\n    color: #000000 !important;\n  }\n  \n  .logout-item:hover {\n    background: #fee2e2 !important;\n    color: #dc2626 !important;\n  }\n}\n\n/* PWA-specific enhancements */\n@supports (display: standalone) {\n  .modern-navbar {\n    padding-top: env(safe-area-inset-top);\n  }\n}\n\n/* High contrast mode support */\n@media (prefers-contrast: high) {\n  .modern-navbar {\n    border-bottom: 2px solid #000;\n  }\n  \n  .nav-tab.active {\n    outline: 2px solid currentColor;\n  }\n}\n\n/* ===== MOBILE HAMBURGER MENU ===== */\n.mobile-menu-toggle {\n  background: none;\n  border: none;\n  color: #000000;\n  font-size: 1.25rem;\n  padding: 0.5rem;\n  border-radius: 8px;\n  transition: all 0.2s ease;\n  cursor: pointer;\n  margin-right: 0.5rem;\n}\n\n.mobile-menu-toggle:hover {\n  background: #f3f4f6;\n  color: #dc3545;\n}\n\n/* Mobile Navigation Menu */\n.mobile-nav-menu {\n  position: fixed;\n  top: 0;\n  left: 0;\n  width: 280px;\n  height: 100vh;\n  background: #ffffff;\n  border-right: 1px solid #e5e7eb;\n  box-shadow: 2px 0 10px rgba(0, 0, 0, 0.1);\n  transform: translateX(-100%);\n  transition: transform 0.3s ease;\n  z-index: 1040;\n  overflow-y: auto;\n}\n\n.mobile-nav-menu.open {\n  transform: translateX(0);\n}\n\n.mobile-nav-header {\n  padding: 2rem 1.5rem 1.5rem;\n  background: linear-gradient(135deg, #dc3545, #c82333);\n  color: white;\n}\n\n.mobile-user-info {\n  display: flex;\n  align-items: center;\n  gap: 0.75rem;\n}\n\n.mobile-avatar {\n  width: 48px;\n  height: 48px;\n  background: rgba(255, 255, 255, 0.2);\n  border-radius: 50%;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  font-size: 1.5rem;\n  color: white;\n}\n\n.mobile-user-details {\n  flex: 1;\n}\n\n.mobile-user-name {\n  font-weight: 700;\n  font-size: 1.1rem;\n  margin-bottom: 0.25rem;\n}\n\n.mobile-user-role {\n  font-size: 0.8rem;\n  display: flex;\n  align-items: center;\n  opacity: 0.9;\n}\n\n/* Mobile Navigation List */\n.mobile-nav-list {\n  padding: 1rem 0;\n}\n\n.mobile-nav-item {\n  display: flex;\n  align-items: center;\n  gap: 0.75rem;\n  width: 100%;\n  padding: 1rem 1.5rem;\n  background: none;\n  border: none;\n  color: #000000;\n  font-size: 1rem;\n  font-weight: 500;\n  text-align: left;\n  transition: all 0.2s ease;\n  cursor: pointer;\n}\n\n.mobile-nav-item:hover {\n  background: #f9fafb;\n  color: #dc3545;\n}\n\n.mobile-nav-item.active {\n  background: #fef2f2;\n  color: #dc3545;\n  font-weight: 600;\n  border-right: 3px solid #dc3545;\n}\n\n.mobile-nav-item.logout {\n  color: #ef4444;\n  margin-top: 0.5rem;\n}\n\n.mobile-nav-item.logout:hover {\n  background: #fef2f2;\n  color: #dc2626;\n}\n\n.mobile-nav-divider {\n  height: 1px;\n  background: #e5e7eb;\n  margin: 0.5rem 1.5rem;\n}\n\n/* Mobile Menu Overlay */\n.mobile-menu-overlay {\n  position: fixed;\n  top: 0;\n  left: 0;\n  width: 100vw;\n  height: 100vh;\n  background: rgba(0, 0, 0, 0.5);\n  z-index: 1039;\n  backdrop-filter: blur(2px);\n}\n\n/* ===== NOTIFICATION SYSTEM ===== */\n.navbar-actions {\n  display: flex;\n  align-items: center;\n  gap: 0.75rem;\n}\n\n.notification-wrapper {\n  position: relative;\n}\n\n.notification-btn {\n  background: none;\n  border: none;\n  color: #000000;\n  padding: 0.5rem;\n  border-radius: 8px;\n  transition: all 0.2s ease;\n  cursor: pointer;\n  position: relative;\n  font-size: 1.1rem;\n}\n\n.notification-btn:hover {\n  background: #f3f4f6;\n  color: #dc3545;\n}\n\n.notification-badge {\n  position: absolute;\n  top: 0.2rem;\n  right: 0.2rem;\n  background: #ef4444;\n  color: white;\n  border-radius: 50%;\n  width: 18px;\n  height: 18px;\n  font-size: 0.7rem;\n  font-weight: 600;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  animation: notification-pulse 2s infinite;\n}\n\n@keyframes notification-pulse {\n  0%, 100% { transform: scale(1); }\n  50% { transform: scale(1.1); }\n}\n\n/* Notification Dropdown */\n.notification-dropdown {\n  position: absolute;\n  top: calc(100% + 0.5rem);\n  right: 0;\n  width: 320px;\n  max-width: 90vw;\n  background: white;\n  border: 1px solid #e5e7eb;\n  border-radius: 12px;\n  box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);\n  z-index: 1050;\n  overflow: hidden;\n}\n\n.notification-header {\n  padding: 1rem 1.25rem;\n  border-bottom: 1px solid #e5e7eb;\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  background: #f9fafb;\n}\n\n.notification-header h6 {\n  margin: 0;\n  font-size: 1rem;\n  font-weight: 600;\n  color: #1f2937;\n}\n\n.mark-read-btn {\n  background: none;\n  border: none;\n  color: #6b7280;\n  font-size: 0.8rem;\n  font-weight: 500;\n  cursor: pointer;\n  transition: color 0.2s ease;\n}\n\n.mark-read-btn:hover {\n  color: #dc3545;\n}\n\n/* Notification List */\n.notification-list {\n  max-height: 300px;\n  overflow-y: auto;\n}\n\n.notification-item {\n  display: flex;\n  align-items: flex-start;\n  gap: 0.75rem;\n  padding: 1rem 1.25rem;\n  border-bottom: 1px solid #f3f4f6;\n  transition: background 0.2s ease;\n  position: relative;\n}\n\n.notification-item:hover {\n  background: #f9fafb;\n}\n\n.notification-item.unread {\n  background: #fef7f7;\n  border-left: 3px solid #dc3545;\n}\n\n.notification-icon {\n  width: 36px;\n  height: 36px;\n  border-radius: 50%;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  font-size: 0.9rem;\n  flex-shrink: 0;\n}\n\n.notification-item[class*=\"order\"] .notification-icon {\n  background: #dcfce7;\n  color: #16a34a;\n}\n\n.notification-item[class*=\"system\"] .notification-icon {\n  background: #dbeafe;\n  color: #2563eb;\n}\n\n.notification-item[class*=\"inventory\"] .notification-icon {\n  background: #fef3c7;\n  color: #d97706;\n}\n\n.notification-content {\n  flex: 1;\n  min-width: 0;\n}\n\n.notification-message {\n  font-size: 0.875rem;\n  color: #374151;\n  margin: 0 0 0.25rem 0;\n  line-height: 1.4;\n}\n\n.notification-time {\n  font-size: 0.75rem;\n  color: #6b7280;\n}\n\n.unread-dot {\n  position: absolute;\n  top: 1.25rem;\n  right: 1.25rem;\n  width: 8px;\n  height: 8px;\n  background: #dc3545;\n  border-radius: 50%;\n}\n\n.notification-empty {\n  text-align: center;\n  padding: 2rem 1.25rem;\n  color: #6b7280;\n}\n\n.notification-empty i {\n  font-size: 2rem;\n  margin-bottom: 0.5rem;\n  display: block;\n  opacity: 0.5;\n}\n\n.notification-empty p {\n  margin: 0;\n  font-size: 0.875rem;\n}\n\n/* Enhanced Mobile Responsiveness */\n@media (max-width: 768px) {\n  .navbar-container {\n    padding: 0.5rem 1rem;\n  }\n  \n  .brand-title {\n    font-size: 1rem;\n  }\n  \n  .brand-badge {\n    font-size: 0.55rem;\n    padding: 0.1rem 0.25rem;\n  }\n  \n  .notification-dropdown {\n    width: 280px;\n    right: -1rem;\n  }\n  \n  .user-details {\n    display: none !important;\n  }\n}\n\n@media (max-width: 480px) {\n  .navbar-container {\n    padding: 0.5rem 0.75rem;\n    gap: 0.5rem;\n  }\n  \n  .brand-content {\n    display: flex;\n    flex-direction: column;\n    align-items: flex-start;\n  }\n  \n  .brand-title {\n    font-size: 0.9rem;\n    line-height: 1.2;\n  }\n  \n  .notification-dropdown {\n    width: calc(100vw - 2rem);\n    right: -0.75rem;\n  }\n  \n  .mobile-nav-menu {\n    width: 100%;\n  }\n  \n  .notification-btn,\n  .user-menu-btn {\n    padding: 0.4rem;\n  }\n}\n\n/* Touch-friendly enhancements */\n@media (hover: none) and (pointer: coarse) {\n  .mobile-nav-item,\n  .notification-btn,\n  .user-menu-btn,\n  .mobile-menu-toggle {\n    min-height: 44px;\n    min-width: 44px;\n  }\n  \n  .notification-item {\n    min-height: 60px;\n  }\n}\n\n/* User Section */\n.user-section {\n  position: relative;\n}\n\n.user-info {\n  background: rgba(255, 255, 255, 0.1);\n  padding: 8px 15px;\n  border-radius: 15px;\n  backdrop-filter: blur(10px);\n  border: 1px solid rgba(255, 255, 255, 0.1);\n}\n\n.user-name {\n  font-size: 0.95rem;\n  line-height: 1.2;\n}\n\n.role-badge {\n  font-size: 0.75rem;\n  font-weight: 600;\n  padding: 2px 8px;\n  border-radius: 12px;\n  text-transform: uppercase;\n  letter-spacing: 0.5px;\n  display: inline-flex;\n  align-items: center;\n  margin-top: 2px;\n}\n\n.role-badge.admin {\n  background: #f3f4f6;\n  color: #000000;\n  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);\n}\n\n.role-badge.staff {\n  background: #f3f4f6;\n  color: #000000;\n  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);\n}\n\n/* Action Buttons - removed conflicting styles to maintain navbar black text */\n\n.logout-btn {\n  background: linear-gradient(135deg, #e53e3e, #c53030);\n  border: none;\n  color: #ffffff;\n  padding: 10px 16px;\n  border-radius: 20px;\n  font-weight: 500;\n  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);\n  position: relative;\n  overflow: hidden;\n}\n\n.logout-btn::before {\n  content: '';\n  position: absolute;\n  top: 0;\n  left: -100%;\n  width: 100%;\n  height: 100%;\n  background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);\n  transition: left 0.6s ease;\n}\n\n.logout-btn:hover::before {\n  left: 100%;\n}\n\n.logout-btn:hover {\n  background: linear-gradient(135deg, #c53030, #9c2626);\n  transform: translateY(-2px);\n  box-shadow: 0 6px 20px rgba(197, 48, 48, 0.4);\n  color: #ffffff;\n}\n\n.logout-btn:focus-visible {\n  outline: 2px solid #ffffff;\n  outline-offset: 2px;\n}\n\n/* Dropdown Styling */\n.user-dropdown {\n  background: rgba(255, 255, 255, 0.95);\n  backdrop-filter: blur(15px);\n  border: 1px solid rgba(255, 255, 255, 0.2);\n  border-radius: 15px;\n  box-shadow: 0 10px 40px rgba(0,0,0,0.3);\n  padding: 8px 0;\n  margin-top: 8px;\n}\n\n.user-dropdown .dropdown-header {\n  color: #2d3748;\n  font-weight: 600;\n  font-size: 0.9rem;\n  padding: 8px 16px;\n}\n\n.user-dropdown .dropdown-item {\n  padding: 8px 16px;\n  border-radius: 8px;\n  margin: 2px 8px;\n  transition: all 0.2s ease;\n}\n\n.user-dropdown .dropdown-item:hover {\n  background: rgba(220, 53, 69, 0.1);\n  transform: translateX(4px);\n}\n\n/* Animations */\n@keyframes pulse {\n  0%, 100% { transform: scale(1); }\n  50% { transform: scale(1.1); }\n}\n\n@keyframes fadeInDown {\n  from {\n    opacity: 0;\n    transform: translateY(-20px);\n  }\n  to {\n    opacity: 1;\n    transform: translateY(0);\n  }\n}\n\n.beautiful-navbar {\n  animation: fadeInDown 0.6s ease-out;\n}\n\n/* Responsive Design */\n@media (max-width: 991.98px) {\n  .brand-name {\n    font-size: 1.5rem !important;\n  }\n  \n  .nav-pills-container {\n    position: fixed;\n    bottom: 20px;\n    left: 50%;\n    transform: translateX(-50%);\n    z-index: 1030;\n    background: rgba(26, 26, 26, 0.95);\n    backdrop-filter: blur(20px);\n    box-shadow: 0 8px 32px rgba(0,0,0,0.3);\n  }\n  \n  /* Add safe spacing for mobile bottom navigation */\n  .pos-layout,\n  .admin-layout {\n    padding-bottom: 80px;\n    padding-bottom: calc(80px + env(safe-area-inset-bottom));\n  }\n  \n  /* Ensure dropdowns appear above mobile nav */\n  .user-dropdown {\n    z-index: 1040;\n  }\n}\n\n@media (max-width: 767.98px) {\n  .beautiful-navbar {\n    min-height: 60px;\n  }\n  \n  .brand-logo {\n    width: 35px;\n    height: 35px;\n  }\n  \n  .brand-name {\n    font-size: 1.3rem !important;\n  }\n  \n  .nav-pill {\n    padding: 8px 16px;\n    font-size: 0.85rem;\n  }\n}\n\n/* ===== UTILITY CLASSES ===== */\n.card-hover {\n  transition: all 0.3s ease;\n}\n\n.card-hover:hover {\n  transform: translateY(-2px);\n  box-shadow: 0 6px 20px rgba(0,0,0,0.1);\n}\n\n.text-truncate-2 {\n  display: -webkit-box;\n  -webkit-line-clamp: 2;\n  -webkit-box-orient: vertical;\n  overflow: hidden;\n}\n\n.border-dashed {\n  border-style: dashed !important;\n}\n\n.shadow-custom {\n  box-shadow: 0 4px 12px rgba(0,0,0,0.1) !important;\n}","size_bytes":52048},"src/App.js":{"content":"import React, { useState, useEffect } from 'react';\nimport { BrowserRouter as Router, Routes, Route, Navigate } from 'react-router-dom';\nimport Header from './components/Header';\nimport Login from './components/Login';\nimport POS from './components/POS';\nimport Admin from './components/Admin';\nimport { AuthProvider, useAuth } from './services/AuthContext';\nimport { CartProvider } from './services/CartContext';\nimport './App.css';\n\nfunction AppContent() {\n  const { user, isLoading } = useAuth();\n\n  if (isLoading) {\n    return (\n      <div className=\"flex items-center justify-center min-h-screen\">\n        <div className=\"text-lg\">Loading...</div>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"App\">\n      <Header />\n      <main className=\"container py-4\">\n        {!user ? (\n          <Login />\n        ) : (\n          <Routes>\n            <Route path=\"/\" element={<POS />} />\n            <Route path=\"/admin\" element={\n              user.role === 'admin' ? <Admin /> : <Navigate to=\"/\" replace />\n            } />\n            <Route path=\"*\" element={<Navigate to=\"/\" replace />} />\n          </Routes>\n        )}\n      </main>\n      <footer className=\"text-center text-muted py-3 text-sm\">\n        Shawarma Boss ‚Ä¢ Modern MERN Stack POS\n      </footer>\n    </div>\n  );\n}\n\nfunction App() {\n  return (\n    <Router>\n      <AuthProvider>\n        <CartProvider>\n          <AppContent />\n        </CartProvider>\n      </AuthProvider>\n    </Router>\n  );\n}\n\nexport default App;","size_bytes":1488},"src/index.css":{"content":"/* Import Bootstrap CSS */\n@import '~bootstrap/dist/css/bootstrap.min.css';\n\n/* Import Font Awesome CSS */\n@import '~@fortawesome/fontawesome-free/css/all.min.css';\n\n/* Modern CSS Reset and Base Styles */\n* {\n  margin: 0;\n  padding: 0;\n  box-sizing: border-box;\n}\n\nbody {\n  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n  background-color: #f8f9fa;\n}\n\n.App {\n  min-height: 100vh;\n}\n\n/* Utility Classes */\n.text-danger {\n  color: #dc3545;\n}\n\n.text-success {\n  color: #28a745;\n}\n\n.text-muted {\n  color: #6c757d;\n}\n\n.btn {\n  display: inline-block;\n  padding: 0.375rem 0.75rem;\n  margin-bottom: 0;\n  font-size: 1rem;\n  font-weight: 400;\n  line-height: 1.5;\n  text-align: center;\n  white-space: nowrap;\n  vertical-align: middle;\n  cursor: pointer;\n  border: 1px solid transparent;\n  border-radius: 0.25rem;\n  text-decoration: none;\n  transition: all 0.15s ease-in-out;\n}\n\n.btn-primary {\n  color: #fff;\n  background-color: #007bff;\n  border-color: #007bff;\n}\n\n.btn-danger {\n  color: #fff;\n  background-color: #dc3545;\n  border-color: #dc3545;\n}\n\n.btn-success {\n  color: #fff;\n  background-color: #28a745;\n  border-color: #28a745;\n}\n\n.btn-outline-danger {\n  color: #dc3545;\n  background-color: transparent;\n  border-color: #dc3545;\n}\n\n.btn:hover {\n  opacity: 0.85;\n}\n\n.form-control {\n  display: block;\n  width: 100%;\n  padding: 0.375rem 0.75rem;\n  font-size: 1rem;\n  line-height: 1.5;\n  color: #495057;\n  background-color: #fff;\n  border: 1px solid #ced4da;\n  border-radius: 0.25rem;\n  transition: border-color 0.15s ease-in-out, box-shadow 0.15s ease-in-out;\n}\n\n.form-control:focus {\n  border-color: #80bdff;\n  outline: 0;\n  box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25);\n}\n\n.card {\n  background-color: #fff;\n  border: 1px solid rgba(0, 0, 0, 0.125);\n  border-radius: 0.25rem;\n  box-shadow: 0 0.125rem 0.25rem rgba(0, 0, 0, 0.075);\n}\n\n.card-header {\n  padding: 0.75rem 1.25rem;\n  background-color: rgba(0, 0, 0, 0.03);\n  border-bottom: 1px solid rgba(0, 0, 0, 0.125);\n}\n\n.card-body {\n  padding: 1.25rem;\n}\n\n.grid {\n  display: grid;\n  gap: 1rem;\n}\n\n.grid-cols-1 { grid-template-columns: repeat(1, 1fr); }\n.grid-cols-2 { grid-template-columns: repeat(2, 1fr); }\n.grid-cols-3 { grid-template-columns: repeat(3, 1fr); }\n\n@media (min-width: 768px) {\n  .md\\:grid-cols-2 { grid-template-columns: repeat(2, 1fr); }\n  .md\\:grid-cols-3 { grid-template-columns: repeat(3, 1fr); }\n}\n\n.flex {\n  display: flex;\n}\n\n.flex-col {\n  flex-direction: column;\n}\n\n.items-center {\n  align-items: center;\n}\n\n.justify-between {\n  justify-content: space-between;\n}\n\n.gap-2 {\n  gap: 0.5rem;\n}\n\n.gap-4 {\n  gap: 1rem;\n}\n\n.p-2 { padding: 0.5rem; }\n.p-4 { padding: 1rem; }\n.p-6 { padding: 1.5rem; }\n\n.m-2 { margin: 0.5rem; }\n.m-4 { margin: 1rem; }\n\n.mt-2 { margin-top: 0.5rem; }\n.mt-4 { margin-top: 1rem; }\n.mb-2 { margin-bottom: 0.5rem; }\n.mb-4 { margin-bottom: 1rem; }\n\n.text-center {\n  text-align: center;\n}\n\n.font-bold {\n  font-weight: 700;\n}\n\n.text-sm {\n  font-size: 0.875rem;\n}\n\n.text-lg {\n  font-size: 1.125rem;\n}\n\n.text-xl {\n  font-size: 1.25rem;\n}\n\n.hidden {\n  display: none;\n}\n\n.container {\n  max-width: 1200px;\n  margin: 0 auto;\n  padding: 0 1rem;\n}\n\n.menu-card {\n  cursor: pointer;\n  transition: transform 0.2s ease-in-out;\n}\n\n.menu-card:hover {\n  transform: translateY(-2px);\n  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);\n}\n\n.cart-item {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  padding: 0.5rem;\n  border-bottom: 1px solid #eee;\n}\n\n.stock-low {\n  color: #ffc107;\n}\n\n.stock-out {\n  color: #dc3545;\n}\n\n/* Width/Height utility classes */\n.w-12 { width: 3rem; }\n.w-16 { width: 4rem; }\n.w-20 { width: 5rem; }\n.h-12 { height: 3rem; }\n.h-16 { height: 4rem; }\n.h-20 { height: 5rem; }\n\n.w-4 { width: 1rem; }\n.h-4 { height: 1rem; }\n\n.mx-auto {\n  margin-left: auto;\n  margin-right: auto;\n}\n\n.mb-1 { margin-bottom: 0.25rem; }\n.mb-2 { margin-bottom: 0.5rem; }\n.mb-4 { margin-bottom: 1rem; }\n.mb-6 { margin-bottom: 1.5rem; }\n\n.mt-1 { margin-top: 0.25rem; }\n.mt-6 { margin-top: 1.5rem; }\n\n.min-h-96 { min-height: 24rem; }\n\n.max-w-md { max-width: 28rem; }\n\n.w-full { width: 100%; }\n\n.space-y-1 > * + * { margin-top: 0.25rem; }\n\n.justify-center { justify-content: center; }\n\n.bg-red-50 { background-color: #fef2f2; }\n.border-red-200 { border-color: #fecaca; }\n.rounded { border-radius: 0.25rem; }\n\n/* Legacy navbar compact styling - only for non-beautiful navbars */\n.navbar:not(.beautiful-navbar) {\n  --bs-navbar-padding-y: .25rem;\n}\n\n.navbar:not(.beautiful-navbar) .navbar-brand img {\n  width: 32px !important;\n  height: 32px !important;\n  max-width: 32px !important;\n  max-height: 32px !important;\n  object-fit: contain;\n}\n\n.navbar:not(.beautiful-navbar) .navbar-nav .nav-link {\n  padding: .25rem .5rem;\n}\n\n@media (max-width: 576px) {\n  .navbar:not(.beautiful-navbar) .navbar-brand small {\n    display: none;\n  }\n}","size_bytes":4924},"src/index.js":{"content":"import React from 'react';\nimport ReactDOM from 'react-dom/client';\nimport App from './App';\nimport './index.css';\n\n// Import Bootstrap JavaScript for dropdown functionality\nimport 'bootstrap/dist/js/bootstrap.bundle.min.js';\n\nconst root = ReactDOM.createRoot(document.getElementById('root'));\nroot.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>\n);","size_bytes":364},"src/components/Admin.js":{"content":"import React, { useState, useEffect } from 'react';\nimport { getStaff, addStaff, getMenu, addMenuItem, updateMenuStock, getOrders } from '../services/api';\nimport { useAuth } from '../services/AuthContext';\n\nconst Admin = () => {\n  const { user } = useAuth();\n  const [staff, setStaff] = useState([]);\n  const [menu, setMenu] = useState([]);\n  const [orders, setOrders] = useState([]);\n  const [isLoading, setIsLoading] = useState(true);\n  const [error, setError] = useState('');\n  const [activeSection, setActiveSection] = useState('dashboard');\n  const [isMobileMenuOpen, setIsMobileMenuOpen] = useState(false);\n  const [isMobile, setIsMobile] = useState(false);\n\n  // Form states\n  const [newStaff, setNewStaff] = useState({ username: '', password: '', role: 'staff' });\n  const [newMenuItem, setNewMenuItem] = useState({ name: '', price: '', stock: '' });\n  const [stockUpdates, setStockUpdates] = useState({});\n  const [successMessage, setSuccessMessage] = useState('');\n\n  useEffect(() => {\n    loadAllData();\n  }, []);\n\n  // Mobile detection and responsive handling\n  useEffect(() => {\n    const checkMobile = () => {\n      setIsMobile(window.innerWidth <= 768);\n    };\n    \n    checkMobile();\n    window.addEventListener('resize', checkMobile);\n    \n    return () => window.removeEventListener('resize', checkMobile);\n  }, []);\n\n  // Close mobile menu when section changes\n  useEffect(() => {\n    setIsMobileMenuOpen(false);\n  }, [activeSection]);\n\n  const loadAllData = async () => {\n    try {\n      setIsLoading(true);\n      const [staffData, menuData, ordersData] = await Promise.all([\n        getStaff(),\n        getMenu(),\n        getOrders()\n      ]);\n      setStaff(staffData);\n      setMenu(menuData);\n      setOrders(ordersData);\n      setError('');\n    } catch (error) {\n      console.error('Error loading admin data:', error);\n      setError('Failed to load admin data. Please refresh.');\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const handleAddStaff = async (e) => {\n    e.preventDefault();\n    if (!newStaff.username || !newStaff.password) {\n      alert('Please fill in all fields');\n      return;\n    }\n\n    try {\n      await addStaff(newStaff);\n      await loadAllData();\n      setNewStaff({ username: '', password: '', role: 'staff' });\n      setSuccessMessage('Staff member added successfully!');\n      setTimeout(() => setSuccessMessage(''), 3000);\n    } catch (error) {\n      console.error('Error adding staff:', error);\n      setError('Failed to add staff member');\n    }\n  };\n\n  const handleAddMenuItem = async (e) => {\n    e.preventDefault();\n    if (!newMenuItem.name || !newMenuItem.price || !newMenuItem.stock) {\n      setError('Please fill in all fields');\n      return;\n    }\n\n    try {\n      await addMenuItem({\n        name: newMenuItem.name,\n        price: parseFloat(newMenuItem.price),\n        stock: parseInt(newMenuItem.stock)\n      });\n      await loadAllData();\n      setNewMenuItem({ name: '', price: '', stock: '' });\n      setSuccessMessage('Menu item added successfully!');\n      setTimeout(() => setSuccessMessage(''), 3000);\n    } catch (error) {\n      console.error('Error adding menu item:', error);\n      setError('Failed to add menu item');\n    }\n  };\n\n  const handleUpdateStock = async (itemId, newStock) => {\n    try {\n      await updateMenuStock(itemId, parseInt(newStock));\n      await loadAllData();\n      setStockUpdates({});\n      setSuccessMessage('Stock updated successfully!');\n      setTimeout(() => setSuccessMessage(''), 3000);\n    } catch (error) {\n      console.error('Error updating stock:', error);\n      setError('Failed to update stock');\n    }\n  };\n\n  const handleStockChange = (itemId, value) => {\n    setStockUpdates(prev => ({\n      ...prev,\n      [itemId]: value\n    }));\n  };\n\n  const exportData = () => {\n    const data = {\n      staff,\n      menu,\n      orders,\n      exportDate: new Date().toISOString()\n    };\n    \n    const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });\n    const url = URL.createObjectURL(blob);\n    const a = document.createElement('a');\n    a.href = url;\n    a.download = `shawarma-boss-export-${new Date().toISOString().split('T')[0]}.json`;\n    document.body.appendChild(a);\n    a.click();\n    document.body.removeChild(a);\n    URL.revokeObjectURL(url);\n  };\n\n  const exportCSV = () => {\n    const csvContent = [\n      ['Order ID', 'Staff', 'Date', 'Total', 'Items'].join(','),\n      ...orders.map(order => [\n        order.id,\n        order.staff,\n        order.timestamp,\n        order.total,\n        order.payload ? order.payload.items?.map(item => `${item.name} x${item.quantity}`).join(';') : ''\n      ].join(','))\n    ].join('\\n');\n\n    const blob = new Blob([csvContent], { type: 'text/csv' });\n    const url = URL.createObjectURL(blob);\n    const a = document.createElement('a');\n    a.href = url;\n    a.download = `orders-export-${new Date().toISOString().split('T')[0]}.csv`;\n    document.body.appendChild(a);\n    a.click();\n    document.body.removeChild(a);\n    URL.revokeObjectURL(url);\n  };\n\n  // Calculate sales stats\n  const salesStats = React.useMemo(() => {\n    const today = new Date().toDateString();\n    const todayOrders = orders.filter(order => \n      new Date(order.timestamp).toDateString() === today\n    );\n    const totalSales = orders.reduce((sum, order) => sum + Number(order.total || 0), 0);\n    const todaySales = todayOrders.reduce((sum, order) => sum + Number(order.total || 0), 0);\n\n    const staffSales = {};\n    orders.forEach(order => {\n      if (!staffSales[order.staff]) {\n        staffSales[order.staff] = { orders: 0, total: 0 };\n      }\n      staffSales[order.staff].orders++;\n      staffSales[order.staff].total += Number(order.total || 0);\n    });\n\n    return {\n      totalOrders: orders.length,\n      totalSales,\n      todayOrders: todayOrders.length,\n      todaySales,\n      staffSales\n    };\n  }, [orders]);\n\n  // Sidebar navigation items\n  const sidebarItems = [\n    { id: 'dashboard', icon: 'fas fa-tachometer-alt', label: 'Dashboard' },\n    { id: 'staff', icon: 'fas fa-users', label: 'Staff Management' },\n    { id: 'menu', icon: 'fas fa-utensils', label: 'Menu Management' },\n    { id: 'orders', icon: 'fas fa-receipt', label: 'Recent Orders' },\n    { id: 'reports', icon: 'fas fa-chart-bar', label: 'Reports & Export' }\n  ];\n\n  const renderDashboard = () => (\n    <div className=\"dashboard-container\">\n      {/* KPI Grid Cards */}\n      <div className=\"kpi-grid d-flex flex-wrap gap-3 mb-4\">\n        <div className=\"kpi-card flex-fill\">\n          <div className=\"kpi-icon bg-primary\">\n            <i className=\"fas fa-shopping-cart\"></i>\n          </div>\n          <div className=\"kpi-content\">\n            <div className=\"kpi-value text-primary\">{salesStats.totalOrders}</div>\n            <div className=\"kpi-label\">Total Orders</div>\n          </div>\n        </div>\n        <div className=\"kpi-card flex-fill\">\n          <div className=\"kpi-icon bg-success\">\n            <i className=\"fas fa-dollar-sign\"></i>\n          </div>\n          <div className=\"kpi-content\">\n            <div className=\"kpi-value text-success\">GHS {salesStats.totalSales.toFixed(2)}</div>\n            <div className=\"kpi-label\">Total Sales</div>\n          </div>\n        </div>\n        <div className=\"kpi-card flex-fill\">\n          <div className=\"kpi-icon bg-warning\">\n            <i className=\"fas fa-clock\"></i>\n          </div>\n          <div className=\"kpi-content\">\n            <div className=\"kpi-value text-warning\">{salesStats.todayOrders}</div>\n            <div className=\"kpi-label\">Today's Orders</div>\n          </div>\n        </div>\n        <div className=\"kpi-card flex-fill\">\n          <div className=\"kpi-icon bg-info\">\n            <i className=\"fas fa-chart-line\"></i>\n          </div>\n          <div className=\"kpi-content\">\n            <div className=\"kpi-value text-info\">GHS {salesStats.todaySales.toFixed(2)}</div>\n            <div className=\"kpi-label\">Today's Sales</div>\n          </div>\n        </div>\n      </div>\n      \n      {/* Responsive Grid Layout for Staff and Stock */}\n      <div className=\"admin-grid-layout d-flex flex-column flex-lg-row gap-4\">\n        {/* Staff Performance Panel */}\n        <div className=\"admin-panel flex-fill\">\n          <div className=\"panel-header\">\n            <h4 className=\"panel-title\">\n              <i className=\"fas fa-users me-2\"></i>\n              Staff Performance\n            </h4>\n          </div>\n          <div className=\"panel-body\">\n            <div className=\"staff-grid d-flex flex-wrap gap-3\">\n              {staff.map((member) => (\n                <div key={member.username} className=\"staff-card flex-fill\">\n                  <div className=\"staff-avatar\">\n                    <i className=\"fas fa-user\"></i>\n                  </div>\n                  <div className=\"staff-info\">\n                    <div className=\"staff-name\">{member.username}</div>\n                    <div className=\"staff-role\">{member.role}</div>\n                  </div>\n                  {salesStats.staffSales[member.username] && (\n                    <div className=\"staff-stats\">\n                      <div className=\"stat-orders\">{salesStats.staffSales[member.username].orders}</div>\n                      <div className=\"stat-sales\">GHS {salesStats.staffSales[member.username].total.toFixed(2)}</div>\n                    </div>\n                  )}\n                </div>\n              ))}\n            </div>\n          </div>\n        </div>\n\n        {/* Stock Alerts Panel */}\n        <div className=\"admin-panel flex-fill\">\n          <div className=\"panel-header\">\n            <h4 className=\"panel-title\">\n              <i className=\"fas fa-exclamation-triangle me-2\"></i>\n              Stock Alerts\n            </h4>\n          </div>\n          <div className=\"panel-body\">\n            {menu.filter(item => item.stock <= 5).length === 0 ? (\n              <div className=\"no-alerts\">\n                <i className=\"fas fa-check-circle\"></i>\n                <span>All items are well stocked</span>\n              </div>\n            ) : (\n              <div className=\"stock-alerts d-flex flex-column gap-2\">\n                {menu.filter(item => item.stock <= 5).map(item => (\n                  <div key={item.id} className={`stock-alert ${item.stock === 0 ? 'critical' : 'warning'}`}>\n                    <div className=\"alert-icon\">\n                      <i className={`fas ${item.stock === 0 ? 'fa-times-circle' : 'fa-exclamation-triangle'}`}></i>\n                    </div>\n                    <div className=\"alert-content\">\n                      <div className=\"alert-title\">{item.name}</div>\n                      <div className=\"alert-message\">{item.stock === 0 ? 'Out of stock' : `${item.stock} left`}</div>\n                    </div>\n                  </div>\n                ))}\n              </div>\n            )}\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n\n  const renderStaffManagement = () => (\n    <div className=\"staff-management-container\">\n      <div className=\"admin-grid-layout d-flex flex-column flex-xl-row gap-4\">\n        {/* Staff List Panel */}\n        <div className=\"admin-panel flex-fill\">\n          <div className=\"panel-header\">\n            <h4 className=\"panel-title\">\n              <i className=\"fas fa-users me-2\"></i>\n              Staff Members\n            </h4>\n          </div>\n          <div className=\"panel-body\">\n            <div className=\"staff-management-grid d-flex flex-wrap gap-3\">\n              {staff.map((member) => (\n                <div key={member.username} className=\"staff-management-card flex-fill\">\n                  <div className=\"staff-card-header\">\n                    <div className=\"staff-avatar large\">\n                      <i className=\"fas fa-user\"></i>\n                    </div>\n                    <div className=\"staff-badge\">\n                      <span className={`badge ${member.role === 'admin' ? 'bg-danger' : 'bg-primary'}`}>\n                        {member.role}\n                      </span>\n                    </div>\n                  </div>\n                  <div className=\"staff-card-body\">\n                    <div className=\"staff-name\">{member.username}</div>\n                    {salesStats.staffSales[member.username] && (\n                      <div className=\"staff-performance\">\n                        <div className=\"performance-item\">\n                          <span className=\"performance-label\">Orders:</span>\n                          <span className=\"performance-value\">{salesStats.staffSales[member.username].orders}</span>\n                        </div>\n                        <div className=\"performance-item\">\n                          <span className=\"performance-label\">Sales:</span>\n                          <span className=\"performance-value text-success\">GHS {salesStats.staffSales[member.username].total.toFixed(2)}</span>\n                        </div>\n                      </div>\n                    )}\n                  </div>\n                  <div className=\"staff-card-actions\">\n                    <button className=\"btn btn-sm btn-outline-primary\">\n                      <i className=\"fas fa-edit\"></i>\n                    </button>\n                    <button className=\"btn btn-sm btn-outline-danger\">\n                      <i className=\"fas fa-trash\"></i>\n                    </button>\n                  </div>\n                </div>\n              ))}\n            </div>\n          </div>\n        </div>\n        \n        {/* Add Staff Form Panel */}\n        <div className=\"admin-panel\" style={{minWidth: '320px'}}>\n          <div className=\"panel-header\">\n            <h4 className=\"panel-title\">\n              <i className=\"fas fa-user-plus me-2\"></i>\n              Add New Staff\n            </h4>\n          </div>\n          <div className=\"panel-body\">\n            <form onSubmit={handleAddStaff} className=\"add-staff-form\">\n              <div className=\"form-group\">\n                <label className=\"form-label\">Username</label>\n                <input\n                  type=\"text\"\n                  placeholder=\"Enter username\"\n                  value={newStaff.username}\n                  onChange={(e) => setNewStaff({...newStaff, username: e.target.value})}\n                  className=\"form-control\"\n                />\n              </div>\n              <div className=\"form-group\">\n                <label className=\"form-label\">Password</label>\n                <input\n                  type=\"password\"\n                  placeholder=\"Enter password\"\n                  value={newStaff.password}\n                  onChange={(e) => setNewStaff({...newStaff, password: e.target.value})}\n                  className=\"form-control\"\n                />\n              </div>\n              <div className=\"form-group\">\n                <label className=\"form-label\">Role</label>\n                <select\n                  value={newStaff.role}\n                  onChange={(e) => setNewStaff({...newStaff, role: e.target.value})}\n                  className=\"form-control\"\n                >\n                  <option value=\"staff\">Staff</option>\n                  <option value=\"admin\">Admin</option>\n                </select>\n              </div>\n              <button type=\"submit\" className=\"btn btn-danger w-100\">\n                <i className=\"fas fa-user-plus me-2\"></i>\n                Add Staff Member\n              </button>\n            </form>\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n\n  const renderMenuManagement = () => (\n    <div className=\"row\">\n      <div className=\"col-lg-8\">\n        <div className=\"card\">\n          <div className=\"card-header\">\n            <h4 className=\"font-bold text-danger mb-0\">Menu Items</h4>\n          </div>\n          <div className=\"card-body\">\n            <div className=\"table-responsive\">\n              <table className=\"table table-hover\">\n                <thead className=\"table-light\">\n                  <tr>\n                    <th>Item Name</th>\n                    <th>Price</th>\n                    <th>Stock</th>\n                    <th>Status</th>\n                    <th>Actions</th>\n                  </tr>\n                </thead>\n                <tbody>\n                  {menu.map((item) => (\n                    <tr key={item.id}>\n                      <td className=\"fw-medium\">{item.name}</td>\n                      <td>GHS {parseFloat(item.price || 0).toFixed(2)}</td>\n                      <td>\n                        <div className=\"d-flex align-items-center gap-2\">\n                          <input\n                            type=\"number\"\n                            min=\"0\"\n                            value={stockUpdates[item.id] !== undefined ? stockUpdates[item.id] : item.stock}\n                            onChange={(e) => handleStockChange(item.id, e.target.value)}\n                            className=\"form-control form-control-sm\"\n                            style={{ width: '80px' }}\n                          />\n                          {stockUpdates[item.id] !== undefined && stockUpdates[item.id] != item.stock && (\n                            <button\n                              onClick={() => handleUpdateStock(item.id, stockUpdates[item.id])}\n                              className=\"btn btn-sm btn-primary\"\n                            >\n                              Update\n                            </button>\n                          )}\n                        </div>\n                      </td>\n                      <td>\n                        <span className={`badge ${item.stock <= 0 ? 'bg-danger' : item.stock <= 5 ? 'bg-warning' : 'bg-success'}`}>\n                          {item.stock <= 0 ? 'Out of Stock' : item.stock <= 5 ? 'Low Stock' : 'In Stock'}\n                        </span>\n                      </td>\n                      <td>\n                        <button className=\"btn btn-sm btn-outline-primary me-2\">\n                          <i className=\"fas fa-edit\"></i>\n                        </button>\n                      </td>\n                    </tr>\n                  ))}\n                </tbody>\n              </table>\n            </div>\n          </div>\n        </div>\n      </div>\n      \n      <div className=\"col-lg-4\">\n        <div className=\"card\">\n          <div className=\"card-header\">\n            <h4 className=\"font-bold text-danger mb-0\">Add New Item</h4>\n          </div>\n          <div className=\"card-body\">\n            <form onSubmit={handleAddMenuItem}>\n              <div className=\"mb-3\">\n                <input\n                  type=\"text\"\n                  placeholder=\"Item name\"\n                  value={newMenuItem.name}\n                  onChange={(e) => setNewMenuItem({...newMenuItem, name: e.target.value})}\n                  className=\"form-control\"\n                />\n              </div>\n              <div className=\"mb-3\">\n                <input\n                  type=\"number\"\n                  step=\"0.01\"\n                  placeholder=\"Price (GHS)\"\n                  value={newMenuItem.price}\n                  onChange={(e) => setNewMenuItem({...newMenuItem, price: e.target.value})}\n                  className=\"form-control\"\n                />\n              </div>\n              <div className=\"mb-3\">\n                <input\n                  type=\"number\"\n                  placeholder=\"Initial Stock\"\n                  value={newMenuItem.stock}\n                  onChange={(e) => setNewMenuItem({...newMenuItem, stock: e.target.value})}\n                  className=\"form-control\"\n                />\n              </div>\n              <button type=\"submit\" className=\"btn btn-danger w-100\">\n                <i className=\"fas fa-plus me-2\"></i>\n                Add Item\n              </button>\n            </form>\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n\n  const renderRecentOrders = () => (\n    <div className=\"card\">\n      <div className=\"card-header\">\n        <h4 className=\"font-bold text-danger mb-0\">Recent Orders</h4>\n      </div>\n      <div className=\"card-body\">\n        <div className=\"table-responsive\">\n          <table className=\"table table-hover\">\n            <thead className=\"table-light\">\n              <tr>\n                <th>Order ID</th>\n                <th>Staff</th>\n                <th>Date & Time</th>\n                <th>Total</th>\n                <th>Items</th>\n              </tr>\n            </thead>\n            <tbody>\n              {orders.slice(0, 20).map((order) => (\n                <tr key={order.id}>\n                  <td className=\"font-mono\">#{order.id.slice(-8)}</td>\n                  <td>{order.staff}</td>\n                  <td>{new Date(order.timestamp).toLocaleString()}</td>\n                  <td className=\"fw-bold text-success\">GHS {parseFloat(order.total || 0).toFixed(2)}</td>\n                  <td className=\"text-sm\">\n                    {order.payload?.items?.slice(0, 2).map(item => item.name).join(', ')}\n                    {order.payload?.items?.length > 2 && '...'}\n                  </td>\n                </tr>\n              ))}\n            </tbody>\n          </table>\n          {orders.length === 0 && (\n            <div className=\"text-center py-4 text-muted\">No orders yet</div>\n          )}\n        </div>\n      </div>\n    </div>\n  );\n\n  const renderReportsExport = () => (\n    <div className=\"row\">\n      <div className=\"col-lg-6\">\n        <div className=\"card mb-4\">\n          <div className=\"card-header\">\n            <h4 className=\"font-bold text-danger mb-0\">Export Options</h4>\n          </div>\n          <div className=\"card-body\">\n            <div className=\"d-grid gap-2\">\n              <button onClick={exportData} className=\"btn btn-outline-danger\">\n                <i className=\"fas fa-download me-2\"></i>\n                Export JSON Data\n              </button>\n              <button onClick={exportCSV} className=\"btn btn-outline-danger\">\n                <i className=\"fas fa-file-csv me-2\"></i>\n                Export Orders CSV\n              </button>\n              <button onClick={loadAllData} className=\"btn btn-outline-danger\">\n                <i className=\"fas fa-sync-alt me-2\"></i>\n                Refresh All Data\n              </button>\n            </div>\n          </div>\n        </div>\n      </div>\n      \n      <div className=\"col-lg-6\">\n        <div className=\"card\">\n          <div className=\"card-header\">\n            <h4 className=\"font-bold text-danger mb-0\">Quick Stats</h4>\n          </div>\n          <div className=\"card-body\">\n            <div className=\"row text-center\">\n              <div className=\"col-6 mb-3\">\n                <div className=\"h4 text-primary mb-0\">{menu.length}</div>\n                <small className=\"text-muted\">Menu Items</small>\n              </div>\n              <div className=\"col-6 mb-3\">\n                <div className=\"h4 text-warning mb-0\">{staff.length}</div>\n                <small className=\"text-muted\">Staff Members</small>\n              </div>\n              <div className=\"col-6\">\n                <div className=\"h4 text-info mb-0\">{menu.filter(item => item.stock <= 5).length}</div>\n                <small className=\"text-muted\">Low Stock Items</small>\n              </div>\n              <div className=\"col-6\">\n                <div className=\"h4 text-success mb-0\">{salesStats.todayOrders}</div>\n                <small className=\"text-muted\">Today's Orders</small>\n              </div>\n            </div>\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n\n  const renderContent = () => {\n    switch (activeSection) {\n      case 'dashboard':\n        return renderDashboard();\n      case 'staff':\n        return renderStaffManagement();\n      case 'menu':\n        return renderMenuManagement();\n      case 'orders':\n        return renderRecentOrders();\n      case 'reports':\n        return renderReportsExport();\n      default:\n        return renderDashboard();\n    }\n  };\n\n  if (isLoading) {\n    return (\n      <div className=\"flex items-center justify-center py-8\">\n        <div className=\"spinner\"></div>\n        <span className=\"ml-2\">Loading admin panel...</span>\n      </div>\n    );\n  }\n\n  if (error) {\n    return (\n      <div className=\"card\">\n        <div className=\"card-body text-center\">\n          <div className=\"text-danger mb-4\">{error}</div>\n          <button onClick={loadAllData} className=\"btn btn-danger\">\n            Retry\n          </button>\n        </div>\n      </div>\n    );\n  }\n\n  return (\n    <div className={`admin-layout ${isMobile ? 'mobile' : ''}`}>\n      {/* Mobile Header */}\n      {isMobile && (\n        <div className=\"mobile-header\">\n          <div className=\"mobile-header-content\">\n            <button \n              className=\"mobile-menu-toggle\"\n              onClick={() => setIsMobileMenuOpen(!isMobileMenuOpen)}\n              aria-label=\"Toggle navigation menu\"\n            >\n              <i className={`fas ${isMobileMenuOpen ? 'fa-times' : 'fa-bars'}`}></i>\n            </button>\n            <h2 className=\"mobile-page-title\">\n              {sidebarItems.find(item => item.id === activeSection)?.label || 'Dashboard'}\n            </h2>\n            <div className=\"mobile-user-info\">\n              <div className=\"mobile-user-avatar\">\n                <i className=\"fas fa-user\"></i>\n              </div>\n            </div>\n          </div>\n        </div>\n      )}\n\n      {/* Mobile Menu Overlay */}\n      {isMobile && isMobileMenuOpen && (\n        <div className=\"mobile-menu-overlay\" onClick={() => setIsMobileMenuOpen(false)}>\n          <div className=\"mobile-menu\" onClick={(e) => e.stopPropagation()}>\n            <div className=\"mobile-menu-header\">\n              <div className=\"mobile-brand\">\n                <i className=\"fas fa-shield-alt\"></i>\n                <span>Admin Panel</span>\n              </div>\n              <button \n                className=\"mobile-menu-close\"\n                onClick={() => setIsMobileMenuOpen(false)}\n              >\n                <i className=\"fas fa-times\"></i>\n              </button>\n            </div>\n            <nav className=\"mobile-nav\">\n              {sidebarItems.map((item) => (\n                <button\n                  key={item.id}\n                  className={`mobile-nav-item ${activeSection === item.id ? 'active' : ''}`}\n                  onClick={() => setActiveSection(item.id)}\n                >\n                  <div className=\"mobile-nav-icon\">\n                    <i className={item.icon}></i>\n                  </div>\n                  <span className=\"mobile-nav-label\">{item.label}</span>\n                  <i className=\"fas fa-chevron-right mobile-nav-arrow\"></i>\n                </button>\n              ))}\n            </nav>\n          </div>\n        </div>\n      )}\n\n      {/* Desktop Sidebar */}\n      <div className={`admin-sidebar ${isMobile ? 'mobile-hidden' : ''}`}>\n        <div className=\"sidebar-header\">\n          <div className=\"sidebar-brand\">\n            <i className=\"fas fa-shield-alt me-2\"></i>\n            <span className=\"brand-text\">Admin Panel</span>\n          </div>\n        </div>\n        <nav className=\"sidebar-nav\">\n          {sidebarItems.map((item) => (\n            <button\n              key={item.id}\n              className={`nav-item ${activeSection === item.id ? 'active' : ''}`}\n              onClick={() => setActiveSection(item.id)}\n            >\n              <div className=\"nav-icon\">\n                <i className={item.icon}></i>\n              </div>\n              <span className=\"nav-label\">{item.label}</span>\n            </button>\n          ))}\n        </nav>\n      </div>\n\n      {/* Main Content Area */}\n      <div className=\"admin-content\">\n        {/* Desktop Header */}\n        {!isMobile && (\n          <div className=\"content-header\">\n            <h3 className=\"page-title\">\n              {sidebarItems.find(item => item.id === activeSection)?.label || 'Dashboard'}\n            </h3>\n          </div>\n        )}\n        \n        <div className=\"content-body\">\n          {/* Success/Error Messages */}\n          {successMessage && (\n            <div className=\"alert alert-success alert-dismissible fade show mb-4\" role=\"alert\">\n              <i className=\"fas fa-check-circle me-2\"></i>\n              {successMessage}\n              <button type=\"button\" className=\"btn-close\" onClick={() => setSuccessMessage('')}></button>\n            </div>\n          )}\n          \n          {error && (\n            <div className=\"alert alert-danger alert-dismissible fade show mb-4\" role=\"alert\">\n              <i className=\"fas fa-exclamation-circle me-2\"></i>\n              {error}\n              <button type=\"button\" className=\"btn-close\" onClick={() => setError('')}></button>\n            </div>\n          )}\n          \n          {renderContent()}\n        </div>\n      </div>\n\n      {/* Mobile Bottom Navigation */}\n      {isMobile && (\n        <div className=\"mobile-bottom-nav\">\n          {sidebarItems.slice(0, 4).map((item) => (\n            <button\n              key={item.id}\n              className={`bottom-nav-item ${activeSection === item.id ? 'active' : ''}`}\n              onClick={() => setActiveSection(item.id)}\n            >\n              <div className=\"bottom-nav-icon\">\n                <i className={item.icon}></i>\n              </div>\n              <span className=\"bottom-nav-label\">{item.label}</span>\n            </button>\n          ))}\n          <button\n            className=\"bottom-nav-item\"\n            onClick={() => setIsMobileMenuOpen(true)}\n          >\n            <div className=\"bottom-nav-icon\">\n              <i className=\"fas fa-ellipsis-h\"></i>\n            </div>\n            <span className=\"bottom-nav-label\">More</span>\n          </button>\n        </div>\n      )}\n    </div>\n  );\n};\n\nexport default Admin;","size_bytes":29744},"src/components/Cart.js":{"content":"import React from 'react';\nimport { useCart } from '../services/CartContext';\n\nconst Cart = ({ onConfirmOrder }) => {\n  const { \n    cartItems, \n    removeFromCart, \n    updateQuantity, \n    clearCart, \n    getCartTotal, \n    getCartCount \n  } = useCart();\n\n  const handleQuantityChange = (itemId, newQuantity) => {\n    if (newQuantity <= 0) {\n      removeFromCart(itemId);\n    } else {\n      updateQuantity(itemId, newQuantity);\n    }\n  };\n\n  return (\n    <div className=\"pwa-cart-wrapper\">\n      <div className=\"pwa-cart-header\">\n        <h4 className=\"pwa-cart-title\">Cart ({getCartCount()})</h4>\n        <div className=\"pwa-cart-actions\">\n          <button\n            onClick={clearCart}\n            disabled={cartItems.length === 0}\n            className=\"pwa-cart-btn clear\"\n          >\n            <i className=\"fas fa-trash me-1\"></i>\n            Clear\n          </button>\n          <button\n            onClick={onConfirmOrder}\n            disabled={cartItems.length === 0}\n            className=\"pwa-cart-btn confirm\"\n          >\n            <i className=\"fas fa-check me-1\"></i>\n            Confirm\n          </button>\n        </div>\n      </div>\n\n        <div className=\"pwa-cart-items\">\n          {cartItems.length === 0 ? (\n            <div className=\"pwa-cart-empty\">\n              <i className=\"fas fa-shopping-cart fa-2x mb-2\"></i>\n              <p>Your cart is empty</p>\n              <span className=\"text-muted\">Add items from the menu to get started</span>\n            </div>\n          ) : (\n            cartItems.map((item) => (\n              <div key={item.id} className=\"pwa-cart-item\">\n                <div className=\"pwa-item-info\">\n                  <h6 className=\"pwa-item-name\">{item.name}</h6>\n                  <span className=\"pwa-item-price\">\n                    GHS {parseFloat(item.price || 0).toFixed(2)} each\n                  </span>\n                </div>\n                \n                <div className=\"pwa-item-controls\">\n                  <div className=\"pwa-quantity-controls\">\n                    <button\n                      onClick={() => handleQuantityChange(item.id, item.quantity - 1)}\n                      className=\"pwa-qty-btn\"\n                    >\n                      <i className=\"fas fa-minus\"></i>\n                    </button>\n                    \n                    <input\n                      type=\"number\"\n                      min=\"1\"\n                      value={item.quantity}\n                      onChange={(e) => handleQuantityChange(item.id, parseInt(e.target.value) || 1)}\n                      className=\"pwa-qty-input\"\n                    />\n                    \n                    <button\n                      onClick={() => handleQuantityChange(item.id, item.quantity + 1)}\n                      className=\"pwa-qty-btn\"\n                    >\n                      <i className=\"fas fa-plus\"></i>\n                    </button>\n                  </div>\n                  \n                  <div className=\"pwa-item-total\">\n                    GHS {(parseFloat(item.price || 0) * item.quantity).toFixed(2)}\n                  </div>\n                  \n                  <button\n                    onClick={() => removeFromCart(item.id)}\n                    className=\"pwa-remove-btn\"\n                    title=\"Remove item\"\n                  >\n                    <i className=\"fas fa-trash\"></i>\n                  </button>\n                </div>\n              </div>\n            ))\n          )}\n        </div>\n\n        {cartItems.length > 0 && (\n          <div className=\"pwa-cart-summary\">\n            <div className=\"pwa-cart-total\">\n              <span className=\"pwa-total-label\">Order Total:</span>\n              <span className=\"pwa-total-value\">\n                GHS {getCartTotal().toFixed(2)}\n              </span>\n            </div>\n          </div>\n        )}\n    </div>\n  );\n};\n\nexport default Cart;","size_bytes":3891},"src/components/Header.js":{"content":"import React, { useState, useEffect } from 'react';\nimport { useAuth } from '../services/AuthContext';\nimport { useNavigate, useLocation } from 'react-router-dom';\n\nconst Header = () => {\n  const { user, logout } = useAuth();\n  const navigate = useNavigate();\n  const location = useLocation();\n  const [isMobileMenuOpen, setIsMobileMenuOpen] = useState(false);\n  const [notifications, setNotifications] = useState([]);\n  const [unreadCount, setUnreadCount] = useState(0);\n  const [showNotifications, setShowNotifications] = useState(false);\n\n  // Mock notification system for UI demonstration (ready for real-time integration)\n  useEffect(() => {\n    // Demo notifications - can be replaced with WebSocket/SSE for real-time updates\n    const mockNotifications = [\n      { id: 1, type: 'order', message: 'New order #1234 received', time: '2 min ago', read: false },\n      { id: 2, type: 'system', message: 'Daily backup completed', time: '1 hour ago', read: true },\n      { id: 3, type: 'inventory', message: 'Low stock alert: Chicken Shawarma', time: '3 hours ago', read: false },\n    ];\n    setNotifications(mockNotifications);\n    setUnreadCount(mockNotifications.filter(n => !n.read).length);\n    \n    // TODO: Replace with real-time notification subscription\n    // Example: WebSocket connection, Server-Sent Events, or polling\n  }, []);\n\n  // Close dropdowns when clicking outside\n  useEffect(() => {\n    const handleClickOutside = (event) => {\n      if (showNotifications && !event.target.closest('.notification-wrapper')) {\n        setShowNotifications(false);\n      }\n    };\n\n    document.addEventListener('click', handleClickOutside);\n    return () => document.removeEventListener('click', handleClickOutside);\n  }, [showNotifications]);\n\n  const handleLogout = () => {\n    logout();\n    navigate('/');\n  };\n\n  const handleNavigation = (path) => {\n    navigate(path);\n    setIsMobileMenuOpen(false); // Close mobile menu when navigating\n  };\n\n  const toggleMobileMenu = () => {\n    setIsMobileMenuOpen(!isMobileMenuOpen);\n  };\n\n  const toggleNotifications = () => {\n    setShowNotifications(!showNotifications);\n  };\n\n  const markAllAsRead = () => {\n    setNotifications(prev => prev.map(n => ({ ...n, read: true })));\n    setUnreadCount(0);\n  };\n\n  const getNotificationIcon = (type) => {\n    switch (type) {\n      case 'order': return 'fas fa-shopping-cart';\n      case 'system': return 'fas fa-cog';\n      case 'inventory': return 'fas fa-exclamation-triangle';\n      default: return 'fas fa-bell';\n    }\n  };\n\n  return (\n    <header className=\"modern-navbar\">\n      <div className=\"navbar-container\">\n        {/* Mobile Hamburger Menu */}\n        {user && (\n          <button \n            className=\"mobile-menu-toggle d-md-none\"\n            onClick={toggleMobileMenu}\n            aria-label=\"Toggle mobile menu\"\n            aria-expanded={isMobileMenuOpen}\n          >\n            <i className={`fas ${isMobileMenuOpen ? 'fa-times' : 'fa-bars'}`}></i>\n          </button>\n        )}\n\n        {/* Brand Section */}\n        <button \n          className=\"navbar-brand\" \n          onClick={() => handleNavigation('/')}\n          aria-label=\"Go to home\"\n        >\n          <div className=\"brand-icon\">\n            <img \n              src=\"/icons/logo.png\" \n              alt=\"Shawarma Boss Logo\" \n              className=\"brand-logo\"\n            />\n          </div>\n          <div className=\"brand-content\">\n            <h1 className=\"brand-title\">\n              Shawarma Boss\n              <span className=\"brand-badge\">POS</span>\n            </h1>\n            <p className=\"brand-subtitle d-none d-lg-block\">Modern Point of Sale</p>\n          </div>\n        </button>\n\n        {user && (\n          <>\n            {/* Desktop Navigation Tabs */}\n            <nav className=\"nav-tabs d-none d-md-flex\" aria-label=\"Primary navigation\">\n              <div className=\"nav-tab-list\">\n                <button\n                  onClick={() => handleNavigation('/')}\n                  className={`nav-tab ${location.pathname === '/' ? 'active' : ''}`}\n                  title=\"Staff Dashboard\"\n                  aria-current={location.pathname === '/' ? 'page' : undefined}\n                >\n                  <div className=\"tab-icon\">\n                    <i className=\"fas fa-cash-register\"></i>\n                  </div>\n                  <span className=\"tab-label\">Staff</span>\n                </button>\n                {user.role === 'admin' && (\n                  <button\n                    onClick={() => handleNavigation('/admin')}\n                    className={`nav-tab ${location.pathname === '/admin' ? 'active' : ''}`}\n                    title=\"Admin Dashboard\"\n                    aria-current={location.pathname === '/admin' ? 'page' : undefined}\n                  >\n                    <div className=\"tab-icon\">\n                      <i className=\"fas fa-shield-alt\"></i>\n                    </div>\n                    <span className=\"tab-label\">Admin</span>\n                  </button>\n                )}\n              </div>\n            </nav>\n            \n            {/* Right Side Actions */}\n            <div className=\"navbar-actions\">\n              {/* Notifications */}\n              <div className=\"notification-wrapper\">\n                <button\n                  className=\"notification-btn\"\n                  onClick={toggleNotifications}\n                  title=\"Notifications\"\n                  aria-label=\"Show notifications\"\n                >\n                  <i className=\"fas fa-bell\"></i>\n                  {unreadCount > 0 && (\n                    <span className=\"notification-badge\">{unreadCount}</span>\n                  )}\n                </button>\n                \n                {/* Notification Dropdown */}\n                {showNotifications && (\n                  <div className=\"notification-dropdown\">\n                    <div className=\"notification-header\">\n                      <h6>Notifications</h6>\n                      {unreadCount > 0 && (\n                        <button \n                          className=\"mark-read-btn\"\n                          onClick={markAllAsRead}\n                        >\n                          Mark all as read\n                        </button>\n                      )}\n                    </div>\n                    <div className=\"notification-list\">\n                      {notifications.length === 0 ? (\n                        <div className=\"notification-empty\">\n                          <i className=\"fas fa-bell-slash\"></i>\n                          <p>No notifications yet</p>\n                        </div>\n                      ) : (\n                        notifications.map(notification => (\n                          <div \n                            key={notification.id} \n                            className={`notification-item ${!notification.read ? 'unread' : ''}`}\n                          >\n                            <div className=\"notification-icon\">\n                              <i className={getNotificationIcon(notification.type)}></i>\n                            </div>\n                            <div className=\"notification-content\">\n                              <p className=\"notification-message\">{notification.message}</p>\n                              <span className=\"notification-time\">{notification.time}</span>\n                            </div>\n                            {!notification.read && <div className=\"unread-dot\"></div>}\n                          </div>\n                        ))\n                      )}\n                    </div>\n                  </div>\n                )}\n              </div>\n\n              {/* User Profile */}\n              <div className=\"user-profile\">\n                <div className=\"user-info\">\n                  <div className=\"user-avatar\">\n                    <i className=\"fas fa-user-circle\"></i>\n                  </div>\n                  <div className=\"user-details d-none d-lg-block\">\n                    <div className=\"user-name\">{user.username}</div>\n                    <div className={`user-role role-${user.role}`}>\n                      <i className={`fas ${user.role === 'admin' ? 'fa-crown' : 'fa-user'} me-1`}></i>\n                      {user.role}\n                    </div>\n                  </div>\n                  \n                  <div className=\"dropdown\">\n                    <button \n                      className=\"user-menu-btn\" \n                      type=\"button\" \n                      data-bs-toggle=\"dropdown\" \n                      aria-expanded=\"false\"\n                      title=\"User Menu\"\n                    >\n                      <i className=\"fas fa-chevron-down d-none d-md-inline\"></i>\n                      <i className=\"fas fa-ellipsis-v d-md-none\"></i>\n                    </button>\n                    <ul className=\"dropdown-menu dropdown-menu-end modern-dropdown\">\n                      <li className=\"dropdown-header\">\n                        <div className=\"dropdown-user-info\">\n                          <div className=\"dropdown-avatar\">\n                            <i className=\"fas fa-user-circle\"></i>\n                          </div>\n                          <div>\n                            <div className=\"dropdown-name\">{user.username}</div>\n                            <div className={`dropdown-role role-${user.role}`}>\n                              <i className={`fas ${user.role === 'admin' ? 'fa-crown' : 'fa-user'} me-1`}></i>\n                              {user.role}\n                            </div>\n                          </div>\n                        </div>\n                      </li>\n                      <li><hr className=\"dropdown-divider\" /></li>\n                      <li>\n                        <button className=\"dropdown-item logout-item\" onClick={handleLogout}>\n                          <div className=\"dropdown-item-content\">\n                            <i className=\"fas fa-sign-out-alt\"></i>\n                            <span>Sign Out</span>\n                          </div>\n                        </button>\n                      </li>\n                    </ul>\n                  </div>\n                </div>\n              </div>\n            </div>\n          </>\n        )}\n      </div>\n\n      {/* Mobile Navigation Menu */}\n      {user && (\n        <div className={`mobile-nav-menu ${isMobileMenuOpen ? 'open' : ''}`}>\n          <div className=\"mobile-nav-header\">\n            <div className=\"mobile-user-info\">\n              <div className=\"mobile-avatar\">\n                <i className=\"fas fa-user-circle\"></i>\n              </div>\n              <div className=\"mobile-user-details\">\n                <div className=\"mobile-user-name\">{user.username}</div>\n                <div className={`mobile-user-role role-${user.role}`}>\n                  <i className={`fas ${user.role === 'admin' ? 'fa-crown' : 'fa-user'} me-1`}></i>\n                  {user.role}\n                </div>\n              </div>\n            </div>\n          </div>\n          \n          <nav className=\"mobile-nav-list\">\n            <button\n              onClick={() => handleNavigation('/')}\n              className={`mobile-nav-item ${location.pathname === '/' ? 'active' : ''}`}\n            >\n              <i className=\"fas fa-cash-register\"></i>\n              <span>Staff Dashboard</span>\n            </button>\n            {user.role === 'admin' && (\n              <button\n                onClick={() => handleNavigation('/admin')}\n                className={`mobile-nav-item ${location.pathname === '/admin' ? 'active' : ''}`}\n              >\n                <i className=\"fas fa-shield-alt\"></i>\n                <span>Admin Dashboard</span>\n              </button>\n            )}\n            <div className=\"mobile-nav-divider\"></div>\n            <button className=\"mobile-nav-item logout\" onClick={handleLogout}>\n              <i className=\"fas fa-sign-out-alt\"></i>\n              <span>Sign Out</span>\n            </button>\n          </nav>\n        </div>\n      )}\n      \n      {/* Mobile Menu Overlay */}\n      {isMobileMenuOpen && <div className=\"mobile-menu-overlay\" onClick={toggleMobileMenu}></div>}\n    </header>\n  );\n};\n\nexport default Header;","size_bytes":12215},"src/components/Login.js":{"content":"import React, { useState } from 'react';\nimport { useAuth } from '../services/AuthContext';\n\nconst Login = () => {\n  const [username, setUsername] = useState('');\n  const [password, setPassword] = useState('');\n  const [error, setError] = useState('');\n  const [isLoading, setIsLoading] = useState(false);\n  const { login } = useAuth();\n\n  const handleSubmit = async (e) => {\n    e.preventDefault();\n    setError('');\n    setIsLoading(true);\n\n    if (!username.trim() || !password.trim()) {\n      setError('Please enter both username and password');\n      setIsLoading(false);\n      return;\n    }\n\n    try {\n      const result = await login(username.trim(), password);\n      if (!result.success) {\n        setError(result.error || 'Login failed');\n      }\n    } catch (error) {\n      setError('An error occurred. Please try again.');\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  return (\n    <div className=\"flex items-center justify-center min-h-96\">\n      <div className=\"card w-full max-w-md slide-up\">\n        <div className=\"card-body p-6\">\n          <div className=\"text-center mb-6\">\n            <img \n              src=\"/icons/logo.png\" \n              alt=\"Shawarma Boss Logo\" \n              className=\"w-12 h-12 mx-auto mb-4 rounded\"\n              onError={(e) => {\n                e.target.style.display = 'none';\n              }}\n            />\n            <h2 className=\"text-xl font-bold text-danger\">Shawarma Boss POS</h2>\n            <p className=\"text-muted text-sm mt-1\">Modern MERN Stack Point of Sale</p>\n          </div>\n\n          <form onSubmit={handleSubmit}>\n            <div className=\"mb-4\">\n              <label className=\"block text-sm font-medium mb-2\">Username</label>\n              <input\n                type=\"text\"\n                value={username}\n                onChange={(e) => setUsername(e.target.value)}\n                className=\"form-control\"\n                placeholder=\"Enter username\"\n                disabled={isLoading}\n                autoComplete=\"username\"\n              />\n            </div>\n\n            <div className=\"mb-4\">\n              <label className=\"block text-sm font-medium mb-2\">Password</label>\n              <input\n                type=\"password\"\n                value={password}\n                onChange={(e) => setPassword(e.target.value)}\n                className=\"form-control\"\n                placeholder=\"Enter password\"\n                disabled={isLoading}\n                autoComplete=\"current-password\"\n              />\n            </div>\n\n            {error && (\n              <div className=\"text-danger text-sm mb-4 p-2 bg-red-50 border border-red-200 rounded\">\n                {error}\n              </div>\n            )}\n\n            <button\n              type=\"submit\"\n              disabled={isLoading}\n              className=\"btn btn-danger w-full flex items-center justify-center\"\n            >\n              {isLoading ? (\n                <div className=\"spinner w-4 h-4\"></div>\n              ) : (\n                'Login'\n              )}\n            </button>\n          </form>\n\n          <div className=\"mt-6 text-center text-sm text-muted\">\n            <div className=\"mb-2\">\n              <strong>Demo Accounts:</strong>\n            </div>\n            <div className=\"space-y-1\">\n              <div>Admin: <code>admin</code> / <code>admin123</code></div>\n              <div>Staff: <code>staff1</code> / <code>staff123</code></div>\n            </div>\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default Login;","size_bytes":3538},"src/components/MenuGrid.js":{"content":"import React, { useState } from 'react';\nimport { useCart } from '../services/CartContext';\n\nconst MenuGrid = ({ menu }) => {\n  const { addToCart } = useCart();\n  const [quantities, setQuantities] = useState({});\n\n  const handleQuantityChange = (itemId, quantity) => {\n    setQuantities(prev => ({\n      ...prev,\n      [itemId]: Math.max(1, parseInt(quantity) || 1)\n    }));\n  };\n\n  const handleAddToCart = (item) => {\n    const quantity = quantities[item.id] || 1;\n    if (item.stock < quantity) {\n      alert(`Not enough stock! Only ${item.stock} available.`);\n      return;\n    }\n    addToCart(item, quantity);\n    // Reset quantity to 1 after adding\n    setQuantities(prev => ({\n      ...prev,\n      [item.id]: 1\n    }));\n  };\n\n  const getStockStatus = (stock) => {\n    if (stock === 0) return { text: 'Out of Stock', class: 'stock-out text-danger' };\n    if (stock <= 5) return { text: `Low Stock (${stock})`, class: 'stock-low text-warning' };\n    return { text: `In Stock (${stock})`, class: 'stock-good text-success' };\n  };\n\n  return (\n    <div className=\"pos-menu-grid\">\n      {menu.map((item) => {\n        const stockStatus = getStockStatus(item.stock);\n        const quantity = quantities[item.id] || 1;\n        \n        return (\n          <div key={item.id} className=\"menu-item-card\">\n            <div className=\"menu-item-header\">\n              <h5 className=\"menu-item-name\">{item.name}</h5>\n              <span className=\"menu-item-price\">\n                GHS {parseFloat(item.price || 0).toFixed(2)}\n              </span>\n            </div>\n            \n            <div className={`menu-item-stock ${stockStatus.class}`}>\n              <i className={`fas ${\n                item.stock === 0 ? 'fa-times-circle' : \n                item.stock <= 5 ? 'fa-exclamation-triangle' : \n                'fa-check-circle'\n              } me-1`}></i>\n              {stockStatus.text}\n            </div>\n            \n            <div className=\"menu-item-actions\">\n              <div className=\"quantity-selector\">\n                <button \n                  className=\"btn btn-outline-secondary btn-sm qty-btn\"\n                  onClick={() => handleQuantityChange(item.id, Math.max(1, quantity - 1))}\n                  disabled={item.stock === 0 || quantity <= 1}\n                >\n                  <i className=\"fas fa-minus\"></i>\n                </button>\n                <input\n                  type=\"number\"\n                  min=\"1\"\n                  max={item.stock}\n                  value={quantity}\n                  onChange={(e) => handleQuantityChange(item.id, e.target.value)}\n                  className=\"form-control form-control-sm qty-input\"\n                  disabled={item.stock === 0}\n                />\n                <button \n                  className=\"btn btn-outline-secondary btn-sm qty-btn\"\n                  onClick={() => handleQuantityChange(item.id, Math.min(item.stock, quantity + 1))}\n                  disabled={item.stock === 0 || quantity >= item.stock}\n                >\n                  <i className=\"fas fa-plus\"></i>\n                </button>\n              </div>\n              <button\n                onClick={() => handleAddToCart(item)}\n                disabled={item.stock === 0}\n                className={`btn add-to-cart-btn ${\n                  item.stock === 0 ? 'btn-secondary' : 'btn-danger'\n                }`}\n              >\n                <i className={`fas ${\n                  item.stock === 0 ? 'fa-ban' : 'fa-cart-plus'\n                } me-1`}></i>\n                {item.stock === 0 ? 'Out of Stock' : 'Add to Cart'}\n              </button>\n            </div>\n          </div>\n        );\n      })}\n      \n      {menu.length === 0 && (\n        <div className=\"no-menu-items\">\n          <i className=\"fas fa-utensils fa-3x text-muted mb-3\"></i>\n          <p className=\"text-muted mb-0\">No menu items available</p>\n        </div>\n      )}\n    </div>\n  );\n};\n\nexport default MenuGrid;","size_bytes":3953},"src/components/OrderModal.js":{"content":"import React from 'react';\n\nconst OrderModal = ({ order, onClose }) => {\n  const handlePrint = () => {\n    window.print();\n  };\n\n  const handleDownloadPDF = () => {\n    // This would integrate with jsPDF or similar library\n    alert('PDF download feature would be implemented here');\n  };\n\n  if (!order) return null;\n\n  return (\n    <div className=\"fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50\">\n      <div className=\"bg-white rounded-lg shadow-xl max-w-md w-full mx-4\">\n        <div className=\"flex justify-between items-center p-4 border-b\">\n          <h3 className=\"text-lg font-bold text-danger\">Order Receipt</h3>\n          <button\n            onClick={onClose}\n            className=\"text-gray-500 hover:text-gray-700 text-2xl\"\n          >\n            √ó\n          </button>\n        </div>\n        \n        <div className=\"p-4\">\n          {/* Receipt Content */}\n          <div id=\"receipt-content\" className=\"space-y-4\">\n            <div className=\"text-center\">\n              <h4 className=\"font-bold text-lg\">Shawarma Boss</h4>\n              <p className=\"text-sm text-muted\">Order Receipt</p>\n            </div>\n            \n            <div className=\"space-y-2\">\n              <div className=\"flex justify-between\">\n                <span>Order ID:</span>\n                <span className=\"font-mono\">#{order.id.slice(-8)}</span>\n              </div>\n              <div className=\"flex justify-between\">\n                <span>Staff:</span>\n                <span>{order.staff}</span>\n              </div>\n              <div className=\"flex justify-between\">\n                <span>Date:</span>\n                <span>{new Date(order.timestamp).toLocaleString()}</span>\n              </div>\n            </div>\n            \n            <div className=\"border-t pt-4\">\n              <h5 className=\"font-bold mb-2\">Items:</h5>\n              <div className=\"space-y-2\">\n                {order.items.map((item, index) => (\n                  <div key={index} className=\"flex justify-between\">\n                    <span>\n                      {item.name} √ó {item.quantity}\n                    </span>\n                    <span>GHS {(parseFloat(item.price || 0) * item.quantity).toFixed(2)}</span>\n                  </div>\n                ))}\n              </div>\n            </div>\n            \n            <div className=\"border-t pt-4\">\n              <div className=\"flex justify-between font-bold text-lg\">\n                <span>Total:</span>\n                <span>GHS {parseFloat(order.total || 0).toFixed(2)}</span>\n              </div>\n            </div>\n            \n            <div className=\"text-center text-sm text-muted mt-4\">\n              Thank you for your business!\n            </div>\n          </div>\n        </div>\n        \n        <div className=\"flex gap-2 p-4 border-t\">\n          <button\n            onClick={handlePrint}\n            className=\"btn btn-danger flex-1\"\n          >\n            Print Receipt\n          </button>\n          <button\n            onClick={handleDownloadPDF}\n            className=\"btn btn-outline-danger flex-1\"\n          >\n            Download PDF\n          </button>\n          <button\n            onClick={onClose}\n            className=\"btn btn-outline-danger\"\n          >\n            Close\n          </button>\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default OrderModal;","size_bytes":3367},"src/components/POS.js":{"content":"import React, { useState, useEffect } from 'react';\nimport { useAuth } from '../services/AuthContext';\nimport { useCart } from '../services/CartContext';\nimport { getMenu, createOrder, updateMenuStock } from '../services/api';\nimport MenuGrid from './MenuGrid';\nimport Cart from './Cart';\nimport OrderModal from './OrderModal';\n\nconst POS = () => {\n  const { user } = useAuth();\n  const { cartItems, clearCart, getCartTotal } = useCart();\n  const [menu, setMenu] = useState([]);\n  const [isLoading, setIsLoading] = useState(true);\n  const [error, setError] = useState('');\n  const [showOrderModal, setShowOrderModal] = useState(false);\n  const [recentOrders, setRecentOrders] = useState([]);\n  const [activeSection, setActiveSection] = useState('pos');\n\n  useEffect(() => {\n    loadMenu();\n    loadRecentOrders();\n  }, []);\n\n  const loadMenu = async () => {\n    try {\n      setIsLoading(true);\n      const menuData = await getMenu();\n      setMenu(menuData);\n      setError('');\n    } catch (error) {\n      console.error('Error loading menu:', error);\n      setError('Failed to load menu. Please refresh the page.');\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const loadRecentOrders = () => {\n    const stored = localStorage.getItem('shawarma_boss_recent_orders');\n    if (stored) {\n      try {\n        setRecentOrders(JSON.parse(stored));\n      } catch (error) {\n        console.error('Error loading recent orders:', error);\n      }\n    }\n  };\n\n  const handleConfirmOrder = async () => {\n    if (cartItems.length === 0) {\n      alert('Cart is empty!');\n      return;\n    }\n\n    const order = {\n      id: 'order-' + Date.now() + '-' + Math.floor(Math.random() * 1000),\n      user: user.username,\n      staff: user.username,\n      timestamp: new Date().toISOString(),\n      items: cartItems,\n      total: getCartTotal(),\n      status: 'completed'\n    };\n\n    try {\n      // Save order to backend\n      await createOrder(order);\n\n      // Update stock for each item\n      for (const item of cartItems) {\n        const menuItem = menu.find(m => m.id === item.id);\n        if (menuItem && menuItem.stock >= item.quantity) {\n          await updateMenuStock(item.id, menuItem.stock - item.quantity);\n        }\n      }\n\n      // Update local menu state\n      setMenu(prevMenu =>\n        prevMenu.map(menuItem => {\n          const cartItem = cartItems.find(item => item.id === menuItem.id);\n          if (cartItem) {\n            return {\n              ...menuItem,\n              stock: Math.max(0, menuItem.stock - cartItem.quantity)\n            };\n          }\n          return menuItem;\n        })\n      );\n\n      // Save to recent orders\n      const newRecentOrders = [order, ...recentOrders.slice(0, 4)];\n      setRecentOrders(newRecentOrders);\n      localStorage.setItem('shawarma_boss_recent_orders', JSON.stringify(newRecentOrders));\n\n      // Show order modal\n      setShowOrderModal(true);\n\n      // Clear cart\n      clearCart();\n    } catch (error) {\n      console.error('Error creating order:', error);\n      alert('Failed to create order. Please try again.');\n    }\n  };\n\n  // Sidebar navigation items for staff dashboard\n  const sidebarItems = [\n    { id: 'pos', icon: 'fas fa-cash-register', label: 'Point of Sale' },\n    { id: 'orders', icon: 'fas fa-receipt', label: 'Recent Orders' },\n    { id: 'menu', icon: 'fas fa-utensils', label: 'Menu Items' },\n    { id: 'stats', icon: 'fas fa-chart-line', label: 'Quick Stats' }\n  ];\n\n  // Calculate quick stats for staff dashboard\n  const calculateStats = () => {\n    const todayOrders = recentOrders.filter(order => {\n      const orderDate = new Date(order.timestamp).toDateString();\n      const today = new Date().toDateString();\n      return orderDate === today;\n    });\n\n    const todayRevenue = todayOrders.reduce((sum, order) => sum + parseFloat(order.total || 0), 0);\n    const totalItems = recentOrders.reduce((sum, order) => sum + (order.items?.length || 0), 0);\n\n    return {\n      totalOrders: recentOrders.length,\n      todayOrders: todayOrders.length,\n      todayRevenue,\n      totalItems\n    };\n  };\n\n  const stats = calculateStats();\n\n  // Render different sections based on active selection\n  const renderPOSSection = () => (\n    <div className=\"pwa-pos-grid\">\n      {/* Menu Section */}\n      <div className=\"pwa-menu-section\">\n        <div className=\"pwa-section-header\">\n          <div className=\"pwa-header-content\">\n            <div className=\"pwa-header-icon\">\n              <i className=\"fas fa-utensils\"></i>\n            </div>\n            <div className=\"pwa-header-text\">\n              <h5 className=\"pwa-section-title\">Menu Items</h5>\n              <span className=\"pwa-section-subtitle\">{menu.length} items available</span>\n            </div>\n          </div>\n          <div className=\"pwa-header-actions\">\n            <button\n              onClick={loadMenu}\n              className=\"pwa-refresh-btn\"\n              title=\"Refresh menu\"\n            >\n              <i className=\"fas fa-sync\"></i>\n            </button>\n          </div>\n        </div>\n        <div className=\"pwa-menu-container\">\n          <MenuGrid menu={menu} />\n        </div>\n      </div>\n\n      {/* Cart Section */}\n      <div className=\"pwa-cart-section\">\n        <div className=\"pwa-section-header\">\n          <div className=\"pwa-header-content\">\n            <div className=\"pwa-header-icon pwa-cart-icon\">\n              <i className=\"fas fa-shopping-cart\"></i>\n            </div>\n            <div className=\"pwa-header-text\">\n              <h5 className=\"pwa-section-title\">Current Order</h5>\n              <span className=\"pwa-section-subtitle\">\n                {cartItems.length} {cartItems.length === 1 ? 'item' : 'items'} in cart\n              </span>\n            </div>\n          </div>\n          <div className=\"pwa-cart-total\">\n            <span className=\"pwa-total-label\">Total</span>\n            <span className=\"pwa-total-amount\">GHS {getCartTotal().toFixed(2)}</span>\n          </div>\n        </div>\n        <div className=\"pwa-cart-container\">\n          <Cart onConfirmOrder={handleConfirmOrder} />\n        </div>\n      </div>\n    </div>\n  );\n\n  const renderRecentOrdersSection = () => (\n    <div className=\"card\">\n      <div className=\"card-header bg-success text-white\">\n        <h5 className=\"mb-0\">\n          <i className=\"fas fa-clock me-2\"></i>\n          Recent Orders\n        </h5>\n      </div>\n      <div className=\"card-body\">\n        {recentOrders.length === 0 ? (\n          <div className=\"text-center text-muted py-5\">\n            <i className=\"fas fa-receipt fa-3x text-muted mb-3\"></i>\n            <h6>No recent orders</h6>\n            <p className=\"mb-0\">Orders will appear here as they are created</p>\n          </div>\n        ) : (\n          <div className=\"row g-3\">\n            {recentOrders.map((order) => (\n              <div key={order.id} className=\"col-md-6 col-lg-4\">\n                <div className=\"card border\">\n                  <div className=\"card-body\">\n                    <div className=\"d-flex justify-content-between align-items-start mb-2\">\n                      <h6 className=\"card-title mb-0\">#{order.id.slice(-6)}</h6>\n                      <span className=\"badge bg-success\">Completed</span>\n                    </div>\n                    <p className=\"text-muted small mb-2\">\n                      {new Date(order.timestamp).toLocaleString()}\n                    </p>\n                    <div className=\"d-flex justify-content-between\">\n                      <span className=\"text-muted\">{order.items?.length || 0} items</span>\n                      <span className=\"fw-bold text-success\">GHS {parseFloat(order.total || 0).toFixed(2)}</span>\n                    </div>\n                  </div>\n                </div>\n              </div>\n            ))}\n          </div>\n        )}\n      </div>\n    </div>\n  );\n\n  const renderMenuSection = () => (\n    <div className=\"card\">\n      <div className=\"card-header bg-warning text-white\">\n        <h5 className=\"mb-0\">\n          <i className=\"fas fa-utensils me-2\"></i>\n          Menu Items Overview\n        </h5>\n      </div>\n      <div className=\"card-body\">\n        <div className=\"row g-3\">\n          {menu.map((item) => (\n            <div key={item.id} className=\"col-md-6 col-lg-4\">\n              <div className=\"card border\">\n                <div className=\"card-body\">\n                  <h6 className=\"card-title\">{item.name}</h6>\n                  <div className=\"d-flex justify-content-between align-items-center\">\n                    <span className=\"text-success fw-bold\">GHS {parseFloat(item.price || 0).toFixed(2)}</span>\n                    <span className={`badge ${item.stock <= 0 ? 'bg-danger' : item.stock <= 5 ? 'bg-warning' : 'bg-success'}`}>\n                      Stock: {item.stock}\n                    </span>\n                  </div>\n                </div>\n              </div>\n            </div>\n          ))}\n        </div>\n      </div>\n    </div>\n  );\n\n  const renderStatsSection = () => (\n    <div className=\"space-y-6\">\n      <div className=\"row g-4 mb-4\">\n        <div className=\"col-md-3\">\n          <div className=\"bg-primary bg-opacity-10 border border-primary border-opacity-20 rounded-lg p-4 text-center\">\n            <div className=\"text-3xl font-bold text-primary mb-1\">{stats.totalOrders}</div>\n            <div className=\"text-sm text-muted\">Total Orders</div>\n          </div>\n        </div>\n        <div className=\"col-md-3\">\n          <div className=\"bg-success bg-opacity-10 border border-success border-opacity-20 rounded-lg p-4 text-center\">\n            <div className=\"text-3xl font-bold text-success mb-1\">{stats.todayOrders}</div>\n            <div className=\"text-sm text-muted\">Today's Orders</div>\n          </div>\n        </div>\n        <div className=\"col-md-3\">\n          <div className=\"bg-warning bg-opacity-10 border border-warning border-opacity-20 rounded-lg p-4 text-center\">\n            <div className=\"text-3xl font-bold text-warning mb-1\">GHS {stats.todayRevenue.toFixed(2)}</div>\n            <div className=\"text-sm text-muted\">Today's Revenue</div>\n          </div>\n        </div>\n        <div className=\"col-md-3\">\n          <div className=\"bg-danger bg-opacity-10 border border-danger border-opacity-20 rounded-lg p-4 text-center\">\n            <div className=\"text-3xl font-bold text-danger mb-1\">{stats.totalItems}</div>\n            <div className=\"text-sm text-muted\">Items Sold</div>\n          </div>\n        </div>\n      </div>\n      \n      <div className=\"card\">\n        <div className=\"card-header\">\n          <h5 className=\"mb-0\">Performance Overview</h5>\n        </div>\n        <div className=\"card-body\">\n          <div className=\"text-center py-4\">\n            <i className=\"fas fa-user-check fa-3x text-success mb-3\"></i>\n            <h6>Logged in as: {user.username}</h6>\n            <p className=\"text-muted mb-0\">Keep up the great work!</p>\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n\n  const renderContent = () => {\n    switch (activeSection) {\n      case 'orders':\n        return renderRecentOrdersSection();\n      case 'menu':\n        return renderMenuSection();\n      case 'stats':\n        return renderStatsSection();\n      case 'pos':\n      default:\n        return renderPOSSection();\n    }\n  };\n\n  if (isLoading) {\n    return (\n      <div className=\"flex items-center justify-center py-8\">\n        <div className=\"spinner\"></div>\n        <span className=\"ml-2\">Loading menu...</span>\n      </div>\n    );\n  }\n\n  if (error) {\n    return (\n      <div className=\"card\">\n        <div className=\"card-body text-center\">\n          <div className=\"text-danger mb-4\">{error}</div>\n          <button \n            onClick={loadMenu}\n            className=\"btn btn-danger\"\n          >\n            Retry\n          </button>\n        </div>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"pwa-staff-layout fade-in\">\n      {/* PWA Navigation Tabs - Mobile First */}\n      <div className=\"pwa-nav-tabs\">\n        <div className=\"pwa-nav-container\">\n          {sidebarItems.map((item) => (\n            <button\n              key={item.id}\n              className={`pwa-nav-tab ${activeSection === item.id ? 'active' : ''}`}\n              onClick={() => setActiveSection(item.id)}\n            >\n              <div className=\"pwa-tab-icon\">\n                <i className={item.icon}></i>\n              </div>\n              <span className=\"pwa-tab-label\">{item.label}</span>\n            </button>\n          ))}\n        </div>\n      </div>\n\n      {/* PWA Main Content */}\n      <div className=\"pwa-main-content\">\n        {/* PWA Header */}\n        <div className=\"pwa-main-header\">\n          <div className=\"pwa-header-info\">\n            <h2 className=\"pwa-main-title\">\n              <i className={`${sidebarItems.find(item => item.id === activeSection)?.icon || 'fas fa-dashboard'}`}></i>\n              {sidebarItems.find(item => item.id === activeSection)?.label || 'Dashboard'}\n            </h2>\n            <p className=\"pwa-main-subtitle\">\n              {activeSection === 'pos' && 'Create orders and manage transactions'}\n              {activeSection === 'orders' && 'View all recent order history'}\n              {activeSection === 'menu' && 'Browse available menu items'}\n              {activeSection === 'stats' && 'View performance statistics'}\n            </p>\n          </div>\n          <div className=\"pwa-header-user\">\n            <div className=\"pwa-user-avatar\">\n              <i className=\"fas fa-user\"></i>\n            </div>\n            <div className=\"pwa-user-info\">\n              <span className=\"pwa-user-name\">{user.username}</span>\n              <span className=\"pwa-user-role\">Staff Member</span>\n            </div>\n          </div>\n        </div>\n\n        {/* Dynamic Content Area */}\n        <div className=\"pwa-content-area\">\n          {renderContent()}\n        </div>\n      </div>\n\n      {/* Order Success Modal */}\n      {showOrderModal && (\n        <OrderModal\n          order={recentOrders[0]}\n          onClose={() => setShowOrderModal(false)}\n        />\n      )}\n    </div>\n  );\n};\n\nexport default POS;","size_bytes":14091},"src/services/AuthContext.js":{"content":"import React, { createContext, useContext, useState, useEffect } from 'react';\nimport { login as apiLogin } from './api';\n\nconst AuthContext = createContext();\n\nexport const useAuth = () => {\n  const context = useContext(AuthContext);\n  if (!context) {\n    throw new Error('useAuth must be used within an AuthProvider');\n  }\n  return context;\n};\n\nexport const AuthProvider = ({ children }) => {\n  const [user, setUser] = useState(null);\n  const [isLoading, setIsLoading] = useState(true);\n\n  useEffect(() => {\n    // Check for stored user on app load\n    const storedUser = localStorage.getItem('shawarma_boss_current_user');\n    if (storedUser) {\n      try {\n        setUser(JSON.parse(storedUser));\n      } catch (error) {\n        console.error('Error parsing stored user:', error);\n        localStorage.removeItem('shawarma_boss_current_user');\n      }\n    }\n    setIsLoading(false);\n  }, []);\n\n  const login = async (username, password) => {\n    try {\n      const response = await apiLogin(username, password);\n      if (response.ok) {\n        const userData = { username: response.username, role: response.role };\n        setUser(userData);\n        localStorage.setItem('shawarma_boss_current_user', JSON.stringify(userData));\n        return { success: true };\n      } else {\n        return { success: false, error: response.error || 'Login failed' };\n      }\n    } catch (error) {\n      console.error('Login error:', error);\n      return { success: false, error: 'Network error. Please try again.' };\n    }\n  };\n\n  const logout = () => {\n    setUser(null);\n    localStorage.removeItem('shawarma_boss_current_user');\n  };\n\n  const value = {\n    user,\n    login,\n    logout,\n    isLoading\n  };\n\n  return (\n    <AuthContext.Provider value={value}>\n      {children}\n    </AuthContext.Provider>\n  );\n};","size_bytes":1803},"src/services/CartContext.js":{"content":"import React, { createContext, useContext, useState } from 'react';\n\nconst CartContext = createContext();\n\nexport const useCart = () => {\n  const context = useContext(CartContext);\n  if (!context) {\n    throw new Error('useCart must be used within a CartProvider');\n  }\n  return context;\n};\n\nexport const CartProvider = ({ children }) => {\n  const [cartItems, setCartItems] = useState([]);\n\n  const addToCart = (menuItem, quantity = 1) => {\n    setCartItems(prevItems => {\n      const existingItem = prevItems.find(item => item.id === menuItem.id);\n      \n      if (existingItem) {\n        return prevItems.map(item =>\n          item.id === menuItem.id\n            ? { ...item, quantity: item.quantity + quantity }\n            : item\n        );\n      } else {\n        return [...prevItems, { ...menuItem, quantity }];\n      }\n    });\n  };\n\n  const removeFromCart = (itemId) => {\n    setCartItems(prevItems => prevItems.filter(item => item.id !== itemId));\n  };\n\n  const updateQuantity = (itemId, newQuantity) => {\n    if (newQuantity <= 0) {\n      removeFromCart(itemId);\n      return;\n    }\n\n    setCartItems(prevItems =>\n      prevItems.map(item =>\n        item.id === itemId\n          ? { ...item, quantity: newQuantity }\n          : item\n      )\n    );\n  };\n\n  const clearCart = () => {\n    setCartItems([]);\n  };\n\n  const getCartTotal = () => {\n    return cartItems.reduce((total, item) => total + (parseFloat(item.price || 0) * item.quantity), 0);\n  };\n\n  const getCartCount = () => {\n    return cartItems.reduce((count, item) => count + item.quantity, 0);\n  };\n\n  const value = {\n    cartItems,\n    addToCart,\n    removeFromCart,\n    updateQuantity,\n    clearCart,\n    getCartTotal,\n    getCartCount\n  };\n\n  return (\n    <CartContext.Provider value={value}>\n      {children}\n    </CartContext.Provider>\n  );\n};","size_bytes":1817},"src/services/api.js":{"content":"import axios from 'axios';\n\n// Create axios instance with base configuration\nconst api = axios.create({\n  baseURL: '/api',\n  headers: {\n    'Content-Type': 'application/json',\n  },\n});\n\n// Auth API\nexport const login = async (username, password) => {\n  try {\n    const response = await api.post('/login', { username, password });\n    return response.data;\n  } catch (error) {\n    throw error.response?.data || { error: 'Network error' };\n  }\n};\n\n// Menu API\nexport const getMenu = async () => {\n  try {\n    const response = await api.get('/menu');\n    return response.data;\n  } catch (error) {\n    throw error.response?.data || { error: 'Failed to fetch menu' };\n  }\n};\n\nexport const addMenuItem = async (menuItem) => {\n  try {\n    const response = await api.post('/menu', menuItem);\n    return response.data;\n  } catch (error) {\n    throw error.response?.data || { error: 'Failed to add menu item' };\n  }\n};\n\nexport const updateMenuStock = async (itemId, stock) => {\n  try {\n    const response = await api.put(`/menu/${itemId}/stock`, { stock });\n    return response.data;\n  } catch (error) {\n    throw error.response?.data || { error: 'Failed to update stock' };\n  }\n};\n\n// Staff API\nexport const getStaff = async () => {\n  try {\n    const response = await api.get('/staff');\n    return response.data;\n  } catch (error) {\n    throw error.response?.data || { error: 'Failed to fetch staff' };\n  }\n};\n\nexport const addStaff = async (staffData) => {\n  try {\n    const response = await api.post('/staff', staffData);\n    return response.data;\n  } catch (error) {\n    throw error.response?.data || { error: 'Failed to add staff member' };\n  }\n};\n\n// Orders API\nexport const getOrders = async () => {\n  try {\n    const response = await api.get('/orders');\n    return response.data;\n  } catch (error) {\n    throw error.response?.data || { error: 'Failed to fetch orders' };\n  }\n};\n\nexport const createOrder = async (orderData) => {\n  try {\n    const response = await api.post('/orders', orderData);\n    return response.data;\n  } catch (error) {\n    throw error.response?.data || { error: 'Failed to create order' };\n  }\n};\n\n// Health check\nexport const healthCheck = async () => {\n  try {\n    const response = await api.get('/health');\n    return response.data;\n  } catch (error) {\n    throw error.response?.data || { error: 'Health check failed' };\n  }\n};\n\nexport default api;","size_bytes":2372},"dist/bundle.c91aa3c3b4cf3b28fd28.js":{"content":"(()=>{var __webpack_modules__={56:(module,__unused_webpack_exports,__webpack_require__)=>{\"use strict\";eval('{\\n\\n/* istanbul ignore next  */\\nfunction setAttributesWithoutAttributes(styleElement) {\\n  var nonce =  true ? __webpack_require__.nc : 0;\\n  if (nonce) {\\n    styleElement.setAttribute(\"nonce\", nonce);\\n  }\\n}\\nmodule.exports = setAttributesWithoutAttributes;//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTYuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBLGNBQWMsS0FBd0MsR0FBRyxzQkFBaUIsR0FBRyxDQUFJO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93b3Jrc3BhY2UvLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zZXRBdHRyaWJ1dGVzV2l0aG91dEF0dHJpYnV0ZXMuanM/ZGRjZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5mdW5jdGlvbiBzZXRBdHRyaWJ1dGVzV2l0aG91dEF0dHJpYnV0ZXMoc3R5bGVFbGVtZW50KSB7XG4gIHZhciBub25jZSA9IHR5cGVvZiBfX3dlYnBhY2tfbm9uY2VfXyAhPT0gXCJ1bmRlZmluZWRcIiA/IF9fd2VicGFja19ub25jZV9fIDogbnVsbDtcbiAgaWYgKG5vbmNlKSB7XG4gICAgc3R5bGVFbGVtZW50LnNldEF0dHJpYnV0ZShcIm5vbmNlXCIsIG5vbmNlKTtcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBzZXRBdHRyaWJ1dGVzV2l0aG91dEF0dHJpYnV0ZXM7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\\n//# sourceURL=webpack-internal:///56\\n\\n}')},72:module=>{\"use strict\";eval('{\\n\\nvar stylesInDOM = [];\\nfunction getIndexByIdentifier(identifier) {\\n  var result = -1;\\n  for (var i = 0; i < stylesInDOM.length; i++) {\\n    if (stylesInDOM[i].identifier === identifier) {\\n      result = i;\\n      break;\\n    }\\n  }\\n  return result;\\n}\\nfunction modulesToDom(list, options) {\\n  var idCountMap = {};\\n  var identifiers = [];\\n  for (var i = 0; i < list.length; i++) {\\n    var item = list[i];\\n    var id = options.base ? item[0] + options.base : item[0];\\n    var count = idCountMap[id] || 0;\\n    var identifier = \"\".concat(id, \" \").concat(count);\\n    idCountMap[id] = count + 1;\\n    var indexByIdentifier = getIndexByIdentifier(identifier);\\n    var obj = {\\n      css: item[1],\\n      media: item[2],\\n      sourceMap: item[3],\\n      supports: item[4],\\n      layer: item[5]\\n    };\\n    if (indexByIdentifier !== -1) {\\n      stylesInDOM[indexByIdentifier].references++;\\n      stylesInDOM[indexByIdentifier].updater(obj);\\n    } else {\\n      var updater = addElementStyle(obj, options);\\n      options.byIndex = i;\\n      stylesInDOM.splice(i, 0, {\\n        identifier: identifier,\\n        updater: updater,\\n        references: 1\\n      });\\n    }\\n    identifiers.push(identifier);\\n  }\\n  return identifiers;\\n}\\nfunction addElementStyle(obj, options) {\\n  var api = options.domAPI(options);\\n  api.update(obj);\\n  var updater = function updater(newObj) {\\n    if (newObj) {\\n      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {\\n        return;\\n      }\\n      api.update(obj = newObj);\\n    } else {\\n      api.remove();\\n    }\\n  };\\n  return updater;\\n}\\nmodule.exports = function (list, options) {\\n  options = options || {};\\n  list = list || [];\\n  var lastIdentifiers = modulesToDom(list, options);\\n  return function update(newList) {\\n    newList = newList || [];\\n    for (var i = 0; i < lastIdentifiers.length; i++) {\\n      var identifier = lastIdentifiers[i];\\n      var index = getIndexByIdentifier(identifier);\\n      stylesInDOM[index].references--;\\n    }\\n    var newLastIdentifiers = modulesToDom(newList, options);\\n    for (var _i = 0; _i < lastIdentifiers.length; _i++) {\\n      var _identifier = lastIdentifiers[_i];\\n      var _index = getIndexByIdentifier(_identifier);\\n      if (stylesInDOM[_index].references === 0) {\\n        stylesInDOM[_index].updater();\\n        stylesInDOM.splice(_index, 1);\\n      }\\n    }\\n    lastIdentifiers = newLastIdentifiers;\\n  };\\n};//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzIuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHdCQUF3QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw0QkFBNEI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiw2QkFBNkI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93b3Jrc3BhY2UvLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanM/MmRiYSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxudmFyIHN0eWxlc0luRE9NID0gW107XG5mdW5jdGlvbiBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKSB7XG4gIHZhciByZXN1bHQgPSAtMTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXNJbkRPTS5sZW5ndGg7IGkrKykge1xuICAgIGlmIChzdHlsZXNJbkRPTVtpXS5pZGVudGlmaWVyID09PSBpZGVudGlmaWVyKSB7XG4gICAgICByZXN1bHQgPSBpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBtb2R1bGVzVG9Eb20obGlzdCwgb3B0aW9ucykge1xuICB2YXIgaWRDb3VudE1hcCA9IHt9O1xuICB2YXIgaWRlbnRpZmllcnMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGl0ZW0gPSBsaXN0W2ldO1xuICAgIHZhciBpZCA9IG9wdGlvbnMuYmFzZSA/IGl0ZW1bMF0gKyBvcHRpb25zLmJhc2UgOiBpdGVtWzBdO1xuICAgIHZhciBjb3VudCA9IGlkQ291bnRNYXBbaWRdIHx8IDA7XG4gICAgdmFyIGlkZW50aWZpZXIgPSBcIlwiLmNvbmNhdChpZCwgXCIgXCIpLmNvbmNhdChjb3VudCk7XG4gICAgaWRDb3VudE1hcFtpZF0gPSBjb3VudCArIDE7XG4gICAgdmFyIGluZGV4QnlJZGVudGlmaWVyID0gZ2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcik7XG4gICAgdmFyIG9iaiA9IHtcbiAgICAgIGNzczogaXRlbVsxXSxcbiAgICAgIG1lZGlhOiBpdGVtWzJdLFxuICAgICAgc291cmNlTWFwOiBpdGVtWzNdLFxuICAgICAgc3VwcG9ydHM6IGl0ZW1bNF0sXG4gICAgICBsYXllcjogaXRlbVs1XVxuICAgIH07XG4gICAgaWYgKGluZGV4QnlJZGVudGlmaWVyICE9PSAtMSkge1xuICAgICAgc3R5bGVzSW5ET01baW5kZXhCeUlkZW50aWZpZXJdLnJlZmVyZW5jZXMrKztcbiAgICAgIHN0eWxlc0luRE9NW2luZGV4QnlJZGVudGlmaWVyXS51cGRhdGVyKG9iaik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB1cGRhdGVyID0gYWRkRWxlbWVudFN0eWxlKG9iaiwgb3B0aW9ucyk7XG4gICAgICBvcHRpb25zLmJ5SW5kZXggPSBpO1xuICAgICAgc3R5bGVzSW5ET00uc3BsaWNlKGksIDAsIHtcbiAgICAgICAgaWRlbnRpZmllcjogaWRlbnRpZmllcixcbiAgICAgICAgdXBkYXRlcjogdXBkYXRlcixcbiAgICAgICAgcmVmZXJlbmNlczogMVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlkZW50aWZpZXJzLnB1c2goaWRlbnRpZmllcik7XG4gIH1cbiAgcmV0dXJuIGlkZW50aWZpZXJzO1xufVxuZnVuY3Rpb24gYWRkRWxlbWVudFN0eWxlKG9iaiwgb3B0aW9ucykge1xuICB2YXIgYXBpID0gb3B0aW9ucy5kb21BUEkob3B0aW9ucyk7XG4gIGFwaS51cGRhdGUob2JqKTtcbiAgdmFyIHVwZGF0ZXIgPSBmdW5jdGlvbiB1cGRhdGVyKG5ld09iaikge1xuICAgIGlmIChuZXdPYmopIHtcbiAgICAgIGlmIChuZXdPYmouY3NzID09PSBvYmouY3NzICYmIG5ld09iai5tZWRpYSA9PT0gb2JqLm1lZGlhICYmIG5ld09iai5zb3VyY2VNYXAgPT09IG9iai5zb3VyY2VNYXAgJiYgbmV3T2JqLnN1cHBvcnRzID09PSBvYmouc3VwcG9ydHMgJiYgbmV3T2JqLmxheWVyID09PSBvYmoubGF5ZXIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgYXBpLnVwZGF0ZShvYmogPSBuZXdPYmopO1xuICAgIH0gZWxzZSB7XG4gICAgICBhcGkucmVtb3ZlKCk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gdXBkYXRlcjtcbn1cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGxpc3QsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGxpc3QgPSBsaXN0IHx8IFtdO1xuICB2YXIgbGFzdElkZW50aWZpZXJzID0gbW9kdWxlc1RvRG9tKGxpc3QsIG9wdGlvbnMpO1xuICByZXR1cm4gZnVuY3Rpb24gdXBkYXRlKG5ld0xpc3QpIHtcbiAgICBuZXdMaXN0ID0gbmV3TGlzdCB8fCBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxhc3RJZGVudGlmaWVycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGlkZW50aWZpZXIgPSBsYXN0SWRlbnRpZmllcnNbaV07XG4gICAgICB2YXIgaW5kZXggPSBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKTtcbiAgICAgIHN0eWxlc0luRE9NW2luZGV4XS5yZWZlcmVuY2VzLS07XG4gICAgfVxuICAgIHZhciBuZXdMYXN0SWRlbnRpZmllcnMgPSBtb2R1bGVzVG9Eb20obmV3TGlzdCwgb3B0aW9ucyk7XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGxhc3RJZGVudGlmaWVycy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBfaWRlbnRpZmllciA9IGxhc3RJZGVudGlmaWVyc1tfaV07XG4gICAgICB2YXIgX2luZGV4ID0gZ2V0SW5kZXhCeUlkZW50aWZpZXIoX2lkZW50aWZpZXIpO1xuICAgICAgaWYgKHN0eWxlc0luRE9NW19pbmRleF0ucmVmZXJlbmNlcyA9PT0gMCkge1xuICAgICAgICBzdHlsZXNJbkRPTVtfaW5kZXhdLnVwZGF0ZXIoKTtcbiAgICAgICAgc3R5bGVzSW5ET00uc3BsaWNlKF9pbmRleCwgMSk7XG4gICAgICB9XG4gICAgfVxuICAgIGxhc3RJZGVudGlmaWVycyA9IG5ld0xhc3RJZGVudGlmaWVycztcbiAgfTtcbn07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\\n//# sourceURL=webpack-internal:///72\\n\\n}')},113:module=>{\"use strict\";eval(\"{\\n\\n/* istanbul ignore next  */\\nfunction styleTagTransform(css, styleElement) {\\n  if (styleElement.styleSheet) {\\n    styleElement.styleSheet.cssText = css;\\n  } else {\\n    while (styleElement.firstChild) {\\n      styleElement.removeChild(styleElement.firstChild);\\n    }\\n    styleElement.appendChild(document.createTextNode(css));\\n  }\\n}\\nmodule.exports = styleTagTransform;//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTEzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd29ya3NwYWNlLy4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvc3R5bGVUYWdUcmFuc2Zvcm0uanM/MWRkZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5mdW5jdGlvbiBzdHlsZVRhZ1RyYW5zZm9ybShjc3MsIHN0eWxlRWxlbWVudCkge1xuICBpZiAoc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQpIHtcbiAgICBzdHlsZUVsZW1lbnQuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xuICB9IGVsc2Uge1xuICAgIHdoaWxlIChzdHlsZUVsZW1lbnQuZmlyc3RDaGlsZCkge1xuICAgICAgc3R5bGVFbGVtZW50LnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudC5maXJzdENoaWxkKTtcbiAgICB9XG4gICAgc3R5bGVFbGVtZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IHN0eWxlVGFnVHJhbnNmb3JtOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\\n//# sourceURL=webpack-internal:///113\\n\\n}\")},115:t=>{\"use strict\";t.exports=\"data:image/svg+xml,%3csvg xmlns=%27http://www.w3.org/2000/svg%27 viewBox=%270 0 16 16%27%3e%3cpath fill=%27none%27 stroke=%27%23dee2e6%27 stroke-linecap=%27round%27 stroke-linejoin=%27round%27 stroke-width=%272%27 d=%27m2 5 6 6 6-6%27/%3e%3c/svg%3e\"},154:t=>{\"use strict\";t.exports=\"data:image/svg+xml,%3csvg xmlns=%27http://www.w3.org/2000/svg%27 viewBox=%27-4 -4 8 8%27%3e%3ccircle r=%273%27 fill=%27rgba%280, 0, 0, 0.25%29%27/%3e%3c/svg%3e\"},159:module=>{\"use strict\";eval('{\\n\\n/* istanbul ignore next  */\\nfunction insertStyleElement(options) {\\n  var element = document.createElement(\"style\");\\n  options.setAttributes(element, options.attributes);\\n  options.insert(element, options.options);\\n  return element;\\n}\\nmodule.exports = insertStyleElement;//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTU5LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93b3Jrc3BhY2UvLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbnNlcnRTdHlsZUVsZW1lbnQuanM/ZGU2YyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5mdW5jdGlvbiBpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucykge1xuICB2YXIgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcbiAgb3B0aW9ucy5zZXRBdHRyaWJ1dGVzKGVsZW1lbnQsIG9wdGlvbnMuYXR0cmlidXRlcyk7XG4gIG9wdGlvbnMuaW5zZXJ0KGVsZW1lbnQsIG9wdGlvbnMub3B0aW9ucyk7XG4gIHJldHVybiBlbGVtZW50O1xufVxubW9kdWxlLmV4cG9ydHMgPSBpbnNlcnRTdHlsZUVsZW1lbnQ7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\\n//# sourceURL=webpack-internal:///159\\n\\n}')},221:(__unused_webpack_module,exports,__webpack_require__)=>{\"use strict\";eval('{/**\\n * @license React\\n * react-dom.production.js\\n *\\n * Copyright (c) Meta Platforms, Inc. and affiliates.\\n *\\n * This source code is licensed under the MIT license found in the\\n * LICENSE file in the root directory of this source tree.\\n */\\n\\n\\nvar React = __webpack_require__(540);\\nfunction formatProdErrorMessage(code) {\\n  var url = \"https://react.dev/errors/\" + code;\\n  if (1 < arguments.length) {\\n    url += \"?args[]=\" + encodeURIComponent(arguments[1]);\\n    for (var i = 2; i < arguments.length; i++)\\n      url += \"&args[]=\" + encodeURIComponent(arguments[i]);\\n  }\\n  return (\\n    \"Minified React error #\" +\\n    code +\\n    \"; visit \" +\\n    url +\\n    \" for the full message or use the non-minified dev environment for full errors and additional helpful warnings.\"\\n  );\\n}\\nfunction noop() {}\\nvar Internals = {\\n    d: {\\n      f: noop,\\n      r: function () {\\n        throw Error(formatProdErrorMessage(522));\\n      },\\n      D: noop,\\n      C: noop,\\n      L: noop,\\n      m: noop,\\n      X: noop,\\n      S: noop,\\n      M: noop\\n    },\\n    p: 0,\\n    findDOMNode: null\\n  },\\n  REACT_PORTAL_TYPE = Symbol.for(\"react.portal\");\\nfunction createPortal$1(children, containerInfo, implementation) {\\n  var key =\\n    3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;\\n  return {\\n    $$typeof: REACT_PORTAL_TYPE,\\n    key: null == key ? null : \"\" + key,\\n    children: children,\\n    containerInfo: containerInfo,\\n    implementation: implementation\\n  };\\n}\\nvar ReactSharedInternals =\\n  React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;\\nfunction getCrossOriginStringAs(as, input) {\\n  if (\"font\" === as) return \"\";\\n  if (\"string\" === typeof input)\\n    return \"use-credentials\" === input ? input : \"\";\\n}\\nexports.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE =\\n  Internals;\\nexports.createPortal = function (children, container) {\\n  var key =\\n    2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;\\n  if (\\n    !container ||\\n    (1 !== container.nodeType &&\\n      9 !== container.nodeType &&\\n      11 !== container.nodeType)\\n  )\\n    throw Error(formatProdErrorMessage(299));\\n  return createPortal$1(children, container, null, key);\\n};\\nexports.flushSync = function (fn) {\\n  var previousTransition = ReactSharedInternals.T,\\n    previousUpdatePriority = Internals.p;\\n  try {\\n    if (((ReactSharedInternals.T = null), (Internals.p = 2), fn)) return fn();\\n  } finally {\\n    (ReactSharedInternals.T = previousTransition),\\n      (Internals.p = previousUpdatePriority),\\n      Internals.d.f();\\n  }\\n};\\nexports.preconnect = function (href, options) {\\n  \"string\" === typeof href &&\\n    (options\\n      ? ((options = options.crossOrigin),\\n        (options =\\n          \"string\" === typeof options\\n            ? \"use-credentials\" === options\\n              ? options\\n              : \"\"\\n            : void 0))\\n      : (options = null),\\n    Internals.d.C(href, options));\\n};\\nexports.prefetchDNS = function (href) {\\n  \"string\" === typeof href && Internals.d.D(href);\\n};\\nexports.preinit = function (href, options) {\\n  if (\"string\" === typeof href && options && \"string\" === typeof options.as) {\\n    var as = options.as,\\n      crossOrigin = getCrossOriginStringAs(as, options.crossOrigin),\\n      integrity =\\n        \"string\" === typeof options.integrity ? options.integrity : void 0,\\n      fetchPriority =\\n        \"string\" === typeof options.fetchPriority\\n          ? options.fetchPriority\\n          : void 0;\\n    \"style\" === as\\n      ? Internals.d.S(\\n          href,\\n          \"string\" === typeof options.precedence ? options.precedence : void 0,\\n          {\\n            crossOrigin: crossOrigin,\\n            integrity: integrity,\\n            fetchPriority: fetchPriority\\n          }\\n        )\\n      : \"script\" === as &&\\n        Internals.d.X(href, {\\n          crossOrigin: crossOrigin,\\n          integrity: integrity,\\n          fetchPriority: fetchPriority,\\n          nonce: \"string\" === typeof options.nonce ? options.nonce : void 0\\n        });\\n  }\\n};\\nexports.preinitModule = function (href, options) {\\n  if (\"string\" === typeof href)\\n    if (\"object\" === typeof options && null !== options) {\\n      if (null == options.as || \"script\" === options.as) {\\n        var crossOrigin = getCrossOriginStringAs(\\n          options.as,\\n          options.crossOrigin\\n        );\\n        Internals.d.M(href, {\\n          crossOrigin: crossOrigin,\\n          integrity:\\n            \"string\" === typeof options.integrity ? options.integrity : void 0,\\n          nonce: \"string\" === typeof options.nonce ? options.nonce : void 0\\n        });\\n      }\\n    } else null == options && Internals.d.M(href);\\n};\\nexports.preload = function (href, options) {\\n  if (\\n    \"string\" === typeof href &&\\n    \"object\" === typeof options &&\\n    null !== options &&\\n    \"string\" === typeof options.as\\n  ) {\\n    var as = options.as,\\n      crossOrigin = getCrossOriginStringAs(as, options.crossOrigin);\\n    Internals.d.L(href, as, {\\n      crossOrigin: crossOrigin,\\n      integrity:\\n        \"string\" === typeof options.integrity ? options.integrity : void 0,\\n      nonce: \"string\" === typeof options.nonce ? options.nonce : void 0,\\n      type: \"string\" === typeof options.type ? options.type : void 0,\\n      fetchPriority:\\n        \"string\" === typeof options.fetchPriority\\n          ? options.fetchPriority\\n          : void 0,\\n      referrerPolicy:\\n        \"string\" === typeof options.referrerPolicy\\n          ? options.referrerPolicy\\n          : void 0,\\n      imageSrcSet:\\n        \"string\" === typeof options.imageSrcSet ? options.imageSrcSet : void 0,\\n      imageSizes:\\n        \"string\" === typeof options.imageSizes ? options.imageSizes : void 0,\\n      media: \"string\" === typeof options.media ? options.media : void 0\\n    });\\n  }\\n};\\nexports.preloadModule = function (href, options) {\\n  if (\"string\" === typeof href)\\n    if (options) {\\n      var crossOrigin = getCrossOriginStringAs(options.as, options.crossOrigin);\\n      Internals.d.m(href, {\\n        as:\\n          \"string\" === typeof options.as && \"script\" !== options.as\\n            ? options.as\\n            : void 0,\\n        crossOrigin: crossOrigin,\\n        integrity:\\n          \"string\" === typeof options.integrity ? options.integrity : void 0\\n      });\\n    } else Internals.d.m(href);\\n};\\nexports.requestFormReset = function (form) {\\n  Internals.d.r(form);\\n};\\nexports.unstable_batchedUpdates = function (fn, a) {\\n  return fn(a);\\n};\\nexports.useFormState = function (action, initialState, permalink) {\\n  return ReactSharedInternals.H.useFormState(action, initialState, permalink);\\n};\\nexports.useFormStatus = function () {\\n  return ReactSharedInternals.H.useHostTransitionStatus();\\n};\\nexports.version = \"19.1.1\";\\n//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjIxLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTtBQUNiLFlBQVksbUJBQU8sQ0FBQyxHQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0U7QUFDcEU7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxlQUFlIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd29ya3NwYWNlLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9janMvcmVhY3QtZG9tLnByb2R1Y3Rpb24uanM/NzNkZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC1kb20ucHJvZHVjdGlvbi5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgUmVhY3QgPSByZXF1aXJlKFwicmVhY3RcIik7XG5mdW5jdGlvbiBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKGNvZGUpIHtcbiAgdmFyIHVybCA9IFwiaHR0cHM6Ly9yZWFjdC5kZXYvZXJyb3JzL1wiICsgY29kZTtcbiAgaWYgKDEgPCBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgdXJsICs9IFwiP2FyZ3NbXT1cIiArIGVuY29kZVVSSUNvbXBvbmVudChhcmd1bWVudHNbMV0pO1xuICAgIGZvciAodmFyIGkgPSAyOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKVxuICAgICAgdXJsICs9IFwiJmFyZ3NbXT1cIiArIGVuY29kZVVSSUNvbXBvbmVudChhcmd1bWVudHNbaV0pO1xuICB9XG4gIHJldHVybiAoXG4gICAgXCJNaW5pZmllZCBSZWFjdCBlcnJvciAjXCIgK1xuICAgIGNvZGUgK1xuICAgIFwiOyB2aXNpdCBcIiArXG4gICAgdXJsICtcbiAgICBcIiBmb3IgdGhlIGZ1bGwgbWVzc2FnZSBvciB1c2UgdGhlIG5vbi1taW5pZmllZCBkZXYgZW52aXJvbm1lbnQgZm9yIGZ1bGwgZXJyb3JzIGFuZCBhZGRpdGlvbmFsIGhlbHBmdWwgd2FybmluZ3MuXCJcbiAgKTtcbn1cbmZ1bmN0aW9uIG5vb3AoKSB7fVxudmFyIEludGVybmFscyA9IHtcbiAgICBkOiB7XG4gICAgICBmOiBub29wLFxuICAgICAgcjogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aHJvdyBFcnJvcihmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDUyMikpO1xuICAgICAgfSxcbiAgICAgIEQ6IG5vb3AsXG4gICAgICBDOiBub29wLFxuICAgICAgTDogbm9vcCxcbiAgICAgIG06IG5vb3AsXG4gICAgICBYOiBub29wLFxuICAgICAgUzogbm9vcCxcbiAgICAgIE06IG5vb3BcbiAgICB9LFxuICAgIHA6IDAsXG4gICAgZmluZERPTU5vZGU6IG51bGxcbiAgfSxcbiAgUkVBQ1RfUE9SVEFMX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QucG9ydGFsXCIpO1xuZnVuY3Rpb24gY3JlYXRlUG9ydGFsJDEoY2hpbGRyZW4sIGNvbnRhaW5lckluZm8sIGltcGxlbWVudGF0aW9uKSB7XG4gIHZhciBrZXkgPVxuICAgIDMgPCBhcmd1bWVudHMubGVuZ3RoICYmIHZvaWQgMCAhPT0gYXJndW1lbnRzWzNdID8gYXJndW1lbnRzWzNdIDogbnVsbDtcbiAgcmV0dXJuIHtcbiAgICAkJHR5cGVvZjogUkVBQ1RfUE9SVEFMX1RZUEUsXG4gICAga2V5OiBudWxsID09IGtleSA/IG51bGwgOiBcIlwiICsga2V5LFxuICAgIGNoaWxkcmVuOiBjaGlsZHJlbixcbiAgICBjb250YWluZXJJbmZvOiBjb250YWluZXJJbmZvLFxuICAgIGltcGxlbWVudGF0aW9uOiBpbXBsZW1lbnRhdGlvblxuICB9O1xufVxudmFyIFJlYWN0U2hhcmVkSW50ZXJuYWxzID1cbiAgUmVhY3QuX19DTElFTlRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfV0FSTl9VU0VSU19USEVZX0NBTk5PVF9VUEdSQURFO1xuZnVuY3Rpb24gZ2V0Q3Jvc3NPcmlnaW5TdHJpbmdBcyhhcywgaW5wdXQpIHtcbiAgaWYgKFwiZm9udFwiID09PSBhcykgcmV0dXJuIFwiXCI7XG4gIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgaW5wdXQpXG4gICAgcmV0dXJuIFwidXNlLWNyZWRlbnRpYWxzXCIgPT09IGlucHV0ID8gaW5wdXQgOiBcIlwiO1xufVxuZXhwb3J0cy5fX0RPTV9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9XQVJOX1VTRVJTX1RIRVlfQ0FOTk9UX1VQR1JBREUgPVxuICBJbnRlcm5hbHM7XG5leHBvcnRzLmNyZWF0ZVBvcnRhbCA9IGZ1bmN0aW9uIChjaGlsZHJlbiwgY29udGFpbmVyKSB7XG4gIHZhciBrZXkgPVxuICAgIDIgPCBhcmd1bWVudHMubGVuZ3RoICYmIHZvaWQgMCAhPT0gYXJndW1lbnRzWzJdID8gYXJndW1lbnRzWzJdIDogbnVsbDtcbiAgaWYgKFxuICAgICFjb250YWluZXIgfHxcbiAgICAoMSAhPT0gY29udGFpbmVyLm5vZGVUeXBlICYmXG4gICAgICA5ICE9PSBjb250YWluZXIubm9kZVR5cGUgJiZcbiAgICAgIDExICE9PSBjb250YWluZXIubm9kZVR5cGUpXG4gIClcbiAgICB0aHJvdyBFcnJvcihmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDI5OSkpO1xuICByZXR1cm4gY3JlYXRlUG9ydGFsJDEoY2hpbGRyZW4sIGNvbnRhaW5lciwgbnVsbCwga2V5KTtcbn07XG5leHBvcnRzLmZsdXNoU3luYyA9IGZ1bmN0aW9uIChmbikge1xuICB2YXIgcHJldmlvdXNUcmFuc2l0aW9uID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCxcbiAgICBwcmV2aW91c1VwZGF0ZVByaW9yaXR5ID0gSW50ZXJuYWxzLnA7XG4gIHRyeSB7XG4gICAgaWYgKCgoUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCA9IG51bGwpLCAoSW50ZXJuYWxzLnAgPSAyKSwgZm4pKSByZXR1cm4gZm4oKTtcbiAgfSBmaW5hbGx5IHtcbiAgICAoUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCA9IHByZXZpb3VzVHJhbnNpdGlvbiksXG4gICAgICAoSW50ZXJuYWxzLnAgPSBwcmV2aW91c1VwZGF0ZVByaW9yaXR5KSxcbiAgICAgIEludGVybmFscy5kLmYoKTtcbiAgfVxufTtcbmV4cG9ydHMucHJlY29ubmVjdCA9IGZ1bmN0aW9uIChocmVmLCBvcHRpb25zKSB7XG4gIFwic3RyaW5nXCIgPT09IHR5cGVvZiBocmVmICYmXG4gICAgKG9wdGlvbnNcbiAgICAgID8gKChvcHRpb25zID0gb3B0aW9ucy5jcm9zc09yaWdpbiksXG4gICAgICAgIChvcHRpb25zID1cbiAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2Ygb3B0aW9uc1xuICAgICAgICAgICAgPyBcInVzZS1jcmVkZW50aWFsc1wiID09PSBvcHRpb25zXG4gICAgICAgICAgICAgID8gb3B0aW9uc1xuICAgICAgICAgICAgICA6IFwiXCJcbiAgICAgICAgICAgIDogdm9pZCAwKSlcbiAgICAgIDogKG9wdGlvbnMgPSBudWxsKSxcbiAgICBJbnRlcm5hbHMuZC5DKGhyZWYsIG9wdGlvbnMpKTtcbn07XG5leHBvcnRzLnByZWZldGNoRE5TID0gZnVuY3Rpb24gKGhyZWYpIHtcbiAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGhyZWYgJiYgSW50ZXJuYWxzLmQuRChocmVmKTtcbn07XG5leHBvcnRzLnByZWluaXQgPSBmdW5jdGlvbiAoaHJlZiwgb3B0aW9ucykge1xuICBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGhyZWYgJiYgb3B0aW9ucyAmJiBcInN0cmluZ1wiID09PSB0eXBlb2Ygb3B0aW9ucy5hcykge1xuICAgIHZhciBhcyA9IG9wdGlvbnMuYXMsXG4gICAgICBjcm9zc09yaWdpbiA9IGdldENyb3NzT3JpZ2luU3RyaW5nQXMoYXMsIG9wdGlvbnMuY3Jvc3NPcmlnaW4pLFxuICAgICAgaW50ZWdyaXR5ID1cbiAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIG9wdGlvbnMuaW50ZWdyaXR5ID8gb3B0aW9ucy5pbnRlZ3JpdHkgOiB2b2lkIDAsXG4gICAgICBmZXRjaFByaW9yaXR5ID1cbiAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIG9wdGlvbnMuZmV0Y2hQcmlvcml0eVxuICAgICAgICAgID8gb3B0aW9ucy5mZXRjaFByaW9yaXR5XG4gICAgICAgICAgOiB2b2lkIDA7XG4gICAgXCJzdHlsZVwiID09PSBhc1xuICAgICAgPyBJbnRlcm5hbHMuZC5TKFxuICAgICAgICAgIGhyZWYsXG4gICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIG9wdGlvbnMucHJlY2VkZW5jZSA/IG9wdGlvbnMucHJlY2VkZW5jZSA6IHZvaWQgMCxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjcm9zc09yaWdpbjogY3Jvc3NPcmlnaW4sXG4gICAgICAgICAgICBpbnRlZ3JpdHk6IGludGVncml0eSxcbiAgICAgICAgICAgIGZldGNoUHJpb3JpdHk6IGZldGNoUHJpb3JpdHlcbiAgICAgICAgICB9XG4gICAgICAgIClcbiAgICAgIDogXCJzY3JpcHRcIiA9PT0gYXMgJiZcbiAgICAgICAgSW50ZXJuYWxzLmQuWChocmVmLCB7XG4gICAgICAgICAgY3Jvc3NPcmlnaW46IGNyb3NzT3JpZ2luLFxuICAgICAgICAgIGludGVncml0eTogaW50ZWdyaXR5LFxuICAgICAgICAgIGZldGNoUHJpb3JpdHk6IGZldGNoUHJpb3JpdHksXG4gICAgICAgICAgbm9uY2U6IFwic3RyaW5nXCIgPT09IHR5cGVvZiBvcHRpb25zLm5vbmNlID8gb3B0aW9ucy5ub25jZSA6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgfVxufTtcbmV4cG9ydHMucHJlaW5pdE1vZHVsZSA9IGZ1bmN0aW9uIChocmVmLCBvcHRpb25zKSB7XG4gIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgaHJlZilcbiAgICBpZiAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIG9wdGlvbnMgJiYgbnVsbCAhPT0gb3B0aW9ucykge1xuICAgICAgaWYgKG51bGwgPT0gb3B0aW9ucy5hcyB8fCBcInNjcmlwdFwiID09PSBvcHRpb25zLmFzKSB7XG4gICAgICAgIHZhciBjcm9zc09yaWdpbiA9IGdldENyb3NzT3JpZ2luU3RyaW5nQXMoXG4gICAgICAgICAgb3B0aW9ucy5hcyxcbiAgICAgICAgICBvcHRpb25zLmNyb3NzT3JpZ2luXG4gICAgICAgICk7XG4gICAgICAgIEludGVybmFscy5kLk0oaHJlZiwge1xuICAgICAgICAgIGNyb3NzT3JpZ2luOiBjcm9zc09yaWdpbixcbiAgICAgICAgICBpbnRlZ3JpdHk6XG4gICAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2Ygb3B0aW9ucy5pbnRlZ3JpdHkgPyBvcHRpb25zLmludGVncml0eSA6IHZvaWQgMCxcbiAgICAgICAgICBub25jZTogXCJzdHJpbmdcIiA9PT0gdHlwZW9mIG9wdGlvbnMubm9uY2UgPyBvcHRpb25zLm5vbmNlIDogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSBudWxsID09IG9wdGlvbnMgJiYgSW50ZXJuYWxzLmQuTShocmVmKTtcbn07XG5leHBvcnRzLnByZWxvYWQgPSBmdW5jdGlvbiAoaHJlZiwgb3B0aW9ucykge1xuICBpZiAoXG4gICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGhyZWYgJiZcbiAgICBcIm9iamVjdFwiID09PSB0eXBlb2Ygb3B0aW9ucyAmJlxuICAgIG51bGwgIT09IG9wdGlvbnMgJiZcbiAgICBcInN0cmluZ1wiID09PSB0eXBlb2Ygb3B0aW9ucy5hc1xuICApIHtcbiAgICB2YXIgYXMgPSBvcHRpb25zLmFzLFxuICAgICAgY3Jvc3NPcmlnaW4gPSBnZXRDcm9zc09yaWdpblN0cmluZ0FzKGFzLCBvcHRpb25zLmNyb3NzT3JpZ2luKTtcbiAgICBJbnRlcm5hbHMuZC5MKGhyZWYsIGFzLCB7XG4gICAgICBjcm9zc09yaWdpbjogY3Jvc3NPcmlnaW4sXG4gICAgICBpbnRlZ3JpdHk6XG4gICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBvcHRpb25zLmludGVncml0eSA/IG9wdGlvbnMuaW50ZWdyaXR5IDogdm9pZCAwLFxuICAgICAgbm9uY2U6IFwic3RyaW5nXCIgPT09IHR5cGVvZiBvcHRpb25zLm5vbmNlID8gb3B0aW9ucy5ub25jZSA6IHZvaWQgMCxcbiAgICAgIHR5cGU6IFwic3RyaW5nXCIgPT09IHR5cGVvZiBvcHRpb25zLnR5cGUgPyBvcHRpb25zLnR5cGUgOiB2b2lkIDAsXG4gICAgICBmZXRjaFByaW9yaXR5OlxuICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2Ygb3B0aW9ucy5mZXRjaFByaW9yaXR5XG4gICAgICAgICAgPyBvcHRpb25zLmZldGNoUHJpb3JpdHlcbiAgICAgICAgICA6IHZvaWQgMCxcbiAgICAgIHJlZmVycmVyUG9saWN5OlxuICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2Ygb3B0aW9ucy5yZWZlcnJlclBvbGljeVxuICAgICAgICAgID8gb3B0aW9ucy5yZWZlcnJlclBvbGljeVxuICAgICAgICAgIDogdm9pZCAwLFxuICAgICAgaW1hZ2VTcmNTZXQ6XG4gICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBvcHRpb25zLmltYWdlU3JjU2V0ID8gb3B0aW9ucy5pbWFnZVNyY1NldCA6IHZvaWQgMCxcbiAgICAgIGltYWdlU2l6ZXM6XG4gICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBvcHRpb25zLmltYWdlU2l6ZXMgPyBvcHRpb25zLmltYWdlU2l6ZXMgOiB2b2lkIDAsXG4gICAgICBtZWRpYTogXCJzdHJpbmdcIiA9PT0gdHlwZW9mIG9wdGlvbnMubWVkaWEgPyBvcHRpb25zLm1lZGlhIDogdm9pZCAwXG4gICAgfSk7XG4gIH1cbn07XG5leHBvcnRzLnByZWxvYWRNb2R1bGUgPSBmdW5jdGlvbiAoaHJlZiwgb3B0aW9ucykge1xuICBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGhyZWYpXG4gICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgIHZhciBjcm9zc09yaWdpbiA9IGdldENyb3NzT3JpZ2luU3RyaW5nQXMob3B0aW9ucy5hcywgb3B0aW9ucy5jcm9zc09yaWdpbik7XG4gICAgICBJbnRlcm5hbHMuZC5tKGhyZWYsIHtcbiAgICAgICAgYXM6XG4gICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIG9wdGlvbnMuYXMgJiYgXCJzY3JpcHRcIiAhPT0gb3B0aW9ucy5hc1xuICAgICAgICAgICAgPyBvcHRpb25zLmFzXG4gICAgICAgICAgICA6IHZvaWQgMCxcbiAgICAgICAgY3Jvc3NPcmlnaW46IGNyb3NzT3JpZ2luLFxuICAgICAgICBpbnRlZ3JpdHk6XG4gICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIG9wdGlvbnMuaW50ZWdyaXR5ID8gb3B0aW9ucy5pbnRlZ3JpdHkgOiB2b2lkIDBcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBJbnRlcm5hbHMuZC5tKGhyZWYpO1xufTtcbmV4cG9ydHMucmVxdWVzdEZvcm1SZXNldCA9IGZ1bmN0aW9uIChmb3JtKSB7XG4gIEludGVybmFscy5kLnIoZm9ybSk7XG59O1xuZXhwb3J0cy51bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyA9IGZ1bmN0aW9uIChmbiwgYSkge1xuICByZXR1cm4gZm4oYSk7XG59O1xuZXhwb3J0cy51c2VGb3JtU3RhdGUgPSBmdW5jdGlvbiAoYWN0aW9uLCBpbml0aWFsU3RhdGUsIHBlcm1hbGluaykge1xuICByZXR1cm4gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSC51c2VGb3JtU3RhdGUoYWN0aW9uLCBpbml0aWFsU3RhdGUsIHBlcm1hbGluayk7XG59O1xuZXhwb3J0cy51c2VGb3JtU3RhdHVzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSC51c2VIb3N0VHJhbnNpdGlvblN0YXR1cygpO1xufTtcbmV4cG9ydHMudmVyc2lvbiA9IFwiMTkuMS4xXCI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\\n//# sourceURL=webpack-internal:///221\\n\\n}')},247:(__unused_webpack_module,exports,__webpack_require__)=>{\"use strict\";eval('{/**\\n * @license React\\n * react-dom-client.production.js\\n *\\n * Copyright (c) Meta Platforms, Inc. and affiliates.\\n *\\n * This source code is licensed under the MIT license found in the\\n * LICENSE file in the root directory of this source tree.\\n */\\n\\n/*\\n Modernizr 3.0.0pre (Custom Build) | MIT\\n*/\\n\\nvar Scheduler = __webpack_require__(982),\\n  React = __webpack_require__(540),\\n  ReactDOM = __webpack_require__(961);\\nfunction formatProdErrorMessage(code) {\\n  var url = \"https://react.dev/errors/\" + code;\\n  if (1 < arguments.length) {\\n    url += \"?args[]=\" + encodeURIComponent(arguments[1]);\\n    for (var i = 2; i < arguments.length; i++)\\n      url += \"&args[]=\" + encodeURIComponent(arguments[i]);\\n  }\\n  return (\\n    \"Minified React error #\" +\\n    code +\\n    \"; visit \" +\\n    url +\\n    \" for the full message or use the non-minified dev environment for full errors and additional helpful warnings.\"\\n  );\\n}\\nfunction isValidContainer(node) {\\n  return !(\\n    !node ||\\n    (1 !== node.nodeType && 9 !== node.nodeType && 11 !== node.nodeType)\\n  );\\n}\\nfunction getNearestMountedFiber(fiber) {\\n  var node = fiber,\\n    nearestMounted = fiber;\\n  if (fiber.alternate) for (; node.return; ) node = node.return;\\n  else {\\n    fiber = node;\\n    do\\n      (node = fiber),\\n        0 !== (node.flags & 4098) && (nearestMounted = node.return),\\n        (fiber = node.return);\\n    while (fiber);\\n  }\\n  return 3 === node.tag ? nearestMounted : null;\\n}\\nfunction getSuspenseInstanceFromFiber(fiber) {\\n  if (13 === fiber.tag) {\\n    var suspenseState = fiber.memoizedState;\\n    null === suspenseState &&\\n      ((fiber = fiber.alternate),\\n      null !== fiber && (suspenseState = fiber.memoizedState));\\n    if (null !== suspenseState) return suspenseState.dehydrated;\\n  }\\n  return null;\\n}\\nfunction assertIsMounted(fiber) {\\n  if (getNearestMountedFiber(fiber) !== fiber)\\n    throw Error(formatProdErrorMessage(188));\\n}\\nfunction findCurrentFiberUsingSlowPath(fiber) {\\n  var alternate = fiber.alternate;\\n  if (!alternate) {\\n    alternate = getNearestMountedFiber(fiber);\\n    if (null === alternate) throw Error(formatProdErrorMessage(188));\\n    return alternate !== fiber ? null : fiber;\\n  }\\n  for (var a = fiber, b = alternate; ; ) {\\n    var parentA = a.return;\\n    if (null === parentA) break;\\n    var parentB = parentA.alternate;\\n    if (null === parentB) {\\n      b = parentA.return;\\n      if (null !== b) {\\n        a = b;\\n        continue;\\n      }\\n      break;\\n    }\\n    if (parentA.child === parentB.child) {\\n      for (parentB = parentA.child; parentB; ) {\\n        if (parentB === a) return assertIsMounted(parentA), fiber;\\n        if (parentB === b) return assertIsMounted(parentA), alternate;\\n        parentB = parentB.sibling;\\n      }\\n      throw Error(formatProdErrorMessage(188));\\n    }\\n    if (a.return !== b.return) (a = parentA), (b = parentB);\\n    else {\\n      for (var didFindChild = !1, child$0 = parentA.child; child$0; ) {\\n        if (child$0 === a) {\\n          didFindChild = !0;\\n          a = parentA;\\n          b = parentB;\\n          break;\\n        }\\n        if (child$0 === b) {\\n          didFindChild = !0;\\n          b = parentA;\\n          a = parentB;\\n          break;\\n        }\\n        child$0 = child$0.sibling;\\n      }\\n      if (!didFindChild) {\\n        for (child$0 = parentB.child; child$0; ) {\\n          if (child$0 === a) {\\n            didFindChild = !0;\\n            a = parentB;\\n            b = parentA;\\n            break;\\n          }\\n          if (child$0 === b) {\\n            didFindChild = !0;\\n            b = parentB;\\n            a = parentA;\\n            break;\\n          }\\n          child$0 = child$0.sibling;\\n        }\\n        if (!didFindChild) throw Error(formatProdErrorMessage(189));\\n      }\\n    }\\n    if (a.alternate !== b) throw Error(formatProdErrorMessage(190));\\n  }\\n  if (3 !== a.tag) throw Error(formatProdErrorMessage(188));\\n  return a.stateNode.current === a ? fiber : alternate;\\n}\\nfunction findCurrentHostFiberImpl(node) {\\n  var tag = node.tag;\\n  if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return node;\\n  for (node = node.child; null !== node; ) {\\n    tag = findCurrentHostFiberImpl(node);\\n    if (null !== tag) return tag;\\n    node = node.sibling;\\n  }\\n  return null;\\n}\\nvar assign = Object.assign,\\n  REACT_LEGACY_ELEMENT_TYPE = Symbol.for(\"react.element\"),\\n  REACT_ELEMENT_TYPE = Symbol.for(\"react.transitional.element\"),\\n  REACT_PORTAL_TYPE = Symbol.for(\"react.portal\"),\\n  REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\"),\\n  REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\"),\\n  REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\"),\\n  REACT_PROVIDER_TYPE = Symbol.for(\"react.provider\"),\\n  REACT_CONSUMER_TYPE = Symbol.for(\"react.consumer\"),\\n  REACT_CONTEXT_TYPE = Symbol.for(\"react.context\"),\\n  REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\"),\\n  REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\"),\\n  REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\"),\\n  REACT_MEMO_TYPE = Symbol.for(\"react.memo\"),\\n  REACT_LAZY_TYPE = Symbol.for(\"react.lazy\");\\nSymbol.for(\"react.scope\");\\nvar REACT_ACTIVITY_TYPE = Symbol.for(\"react.activity\");\\nSymbol.for(\"react.legacy_hidden\");\\nSymbol.for(\"react.tracing_marker\");\\nvar REACT_MEMO_CACHE_SENTINEL = Symbol.for(\"react.memo_cache_sentinel\");\\nSymbol.for(\"react.view_transition\");\\nvar MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\\nfunction getIteratorFn(maybeIterable) {\\n  if (null === maybeIterable || \"object\" !== typeof maybeIterable) return null;\\n  maybeIterable =\\n    (MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||\\n    maybeIterable[\"@@iterator\"];\\n  return \"function\" === typeof maybeIterable ? maybeIterable : null;\\n}\\nvar REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\");\\nfunction getComponentNameFromType(type) {\\n  if (null == type) return null;\\n  if (\"function\" === typeof type)\\n    return type.$$typeof === REACT_CLIENT_REFERENCE\\n      ? null\\n      : type.displayName || type.name || null;\\n  if (\"string\" === typeof type) return type;\\n  switch (type) {\\n    case REACT_FRAGMENT_TYPE:\\n      return \"Fragment\";\\n    case REACT_PROFILER_TYPE:\\n      return \"Profiler\";\\n    case REACT_STRICT_MODE_TYPE:\\n      return \"StrictMode\";\\n    case REACT_SUSPENSE_TYPE:\\n      return \"Suspense\";\\n    case REACT_SUSPENSE_LIST_TYPE:\\n      return \"SuspenseList\";\\n    case REACT_ACTIVITY_TYPE:\\n      return \"Activity\";\\n  }\\n  if (\"object\" === typeof type)\\n    switch (type.$$typeof) {\\n      case REACT_PORTAL_TYPE:\\n        return \"Portal\";\\n      case REACT_CONTEXT_TYPE:\\n        return (type.displayName || \"Context\") + \".Provider\";\\n      case REACT_CONSUMER_TYPE:\\n        return (type._context.displayName || \"Context\") + \".Consumer\";\\n      case REACT_FORWARD_REF_TYPE:\\n        var innerType = type.render;\\n        type = type.displayName;\\n        type ||\\n          ((type = innerType.displayName || innerType.name || \"\"),\\n          (type = \"\" !== type ? \"ForwardRef(\" + type + \")\" : \"ForwardRef\"));\\n        return type;\\n      case REACT_MEMO_TYPE:\\n        return (\\n          (innerType = type.displayName || null),\\n          null !== innerType\\n            ? innerType\\n            : getComponentNameFromType(type.type) || \"Memo\"\\n        );\\n      case REACT_LAZY_TYPE:\\n        innerType = type._payload;\\n        type = type._init;\\n        try {\\n          return getComponentNameFromType(type(innerType));\\n        } catch (x) {}\\n    }\\n  return null;\\n}\\nvar isArrayImpl = Array.isArray,\\n  ReactSharedInternals =\\n    React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,\\n  ReactDOMSharedInternals =\\n    ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,\\n  sharedNotPendingObject = {\\n    pending: !1,\\n    data: null,\\n    method: null,\\n    action: null\\n  },\\n  valueStack = [],\\n  index = -1;\\nfunction createCursor(defaultValue) {\\n  return { current: defaultValue };\\n}\\nfunction pop(cursor) {\\n  0 > index ||\\n    ((cursor.current = valueStack[index]), (valueStack[index] = null), index--);\\n}\\nfunction push(cursor, value) {\\n  index++;\\n  valueStack[index] = cursor.current;\\n  cursor.current = value;\\n}\\nvar contextStackCursor = createCursor(null),\\n  contextFiberStackCursor = createCursor(null),\\n  rootInstanceStackCursor = createCursor(null),\\n  hostTransitionProviderCursor = createCursor(null);\\nfunction pushHostContainer(fiber, nextRootInstance) {\\n  push(rootInstanceStackCursor, nextRootInstance);\\n  push(contextFiberStackCursor, fiber);\\n  push(contextStackCursor, null);\\n  switch (nextRootInstance.nodeType) {\\n    case 9:\\n    case 11:\\n      fiber = (fiber = nextRootInstance.documentElement)\\n        ? (fiber = fiber.namespaceURI)\\n          ? getOwnHostContext(fiber)\\n          : 0\\n        : 0;\\n      break;\\n    default:\\n      if (\\n        ((fiber = nextRootInstance.tagName),\\n        (nextRootInstance = nextRootInstance.namespaceURI))\\n      )\\n        (nextRootInstance = getOwnHostContext(nextRootInstance)),\\n          (fiber = getChildHostContextProd(nextRootInstance, fiber));\\n      else\\n        switch (fiber) {\\n          case \"svg\":\\n            fiber = 1;\\n            break;\\n          case \"math\":\\n            fiber = 2;\\n            break;\\n          default:\\n            fiber = 0;\\n        }\\n  }\\n  pop(contextStackCursor);\\n  push(contextStackCursor, fiber);\\n}\\nfunction popHostContainer() {\\n  pop(contextStackCursor);\\n  pop(contextFiberStackCursor);\\n  pop(rootInstanceStackCursor);\\n}\\nfunction pushHostContext(fiber) {\\n  null !== fiber.memoizedState && push(hostTransitionProviderCursor, fiber);\\n  var context = contextStackCursor.current;\\n  var JSCompiler_inline_result = getChildHostContextProd(context, fiber.type);\\n  context !== JSCompiler_inline_result &&\\n    (push(contextFiberStackCursor, fiber),\\n    push(contextStackCursor, JSCompiler_inline_result));\\n}\\nfunction popHostContext(fiber) {\\n  contextFiberStackCursor.current === fiber &&\\n    (pop(contextStackCursor), pop(contextFiberStackCursor));\\n  hostTransitionProviderCursor.current === fiber &&\\n    (pop(hostTransitionProviderCursor),\\n    (HostTransitionContext._currentValue = sharedNotPendingObject));\\n}\\nvar hasOwnProperty = Object.prototype.hasOwnProperty,\\n  scheduleCallback$3 = Scheduler.unstable_scheduleCallback,\\n  cancelCallback$1 = Scheduler.unstable_cancelCallback,\\n  shouldYield = Scheduler.unstable_shouldYield,\\n  requestPaint = Scheduler.unstable_requestPaint,\\n  now = Scheduler.unstable_now,\\n  getCurrentPriorityLevel = Scheduler.unstable_getCurrentPriorityLevel,\\n  ImmediatePriority = Scheduler.unstable_ImmediatePriority,\\n  UserBlockingPriority = Scheduler.unstable_UserBlockingPriority,\\n  NormalPriority$1 = Scheduler.unstable_NormalPriority,\\n  LowPriority = Scheduler.unstable_LowPriority,\\n  IdlePriority = Scheduler.unstable_IdlePriority,\\n  log$1 = Scheduler.log,\\n  unstable_setDisableYieldValue = Scheduler.unstable_setDisableYieldValue,\\n  rendererID = null,\\n  injectedHook = null;\\nfunction setIsStrictModeForDevtools(newIsStrictMode) {\\n  \"function\" === typeof log$1 && unstable_setDisableYieldValue(newIsStrictMode);\\n  if (injectedHook && \"function\" === typeof injectedHook.setStrictMode)\\n    try {\\n      injectedHook.setStrictMode(rendererID, newIsStrictMode);\\n    } catch (err) {}\\n}\\nvar clz32 = Math.clz32 ? Math.clz32 : clz32Fallback,\\n  log = Math.log,\\n  LN2 = Math.LN2;\\nfunction clz32Fallback(x) {\\n  x >>>= 0;\\n  return 0 === x ? 32 : (31 - ((log(x) / LN2) | 0)) | 0;\\n}\\nvar nextTransitionLane = 256,\\n  nextRetryLane = 4194304;\\nfunction getHighestPriorityLanes(lanes) {\\n  var pendingSyncLanes = lanes & 42;\\n  if (0 !== pendingSyncLanes) return pendingSyncLanes;\\n  switch (lanes & -lanes) {\\n    case 1:\\n      return 1;\\n    case 2:\\n      return 2;\\n    case 4:\\n      return 4;\\n    case 8:\\n      return 8;\\n    case 16:\\n      return 16;\\n    case 32:\\n      return 32;\\n    case 64:\\n      return 64;\\n    case 128:\\n      return 128;\\n    case 256:\\n    case 512:\\n    case 1024:\\n    case 2048:\\n    case 4096:\\n    case 8192:\\n    case 16384:\\n    case 32768:\\n    case 65536:\\n    case 131072:\\n    case 262144:\\n    case 524288:\\n    case 1048576:\\n    case 2097152:\\n      return lanes & 4194048;\\n    case 4194304:\\n    case 8388608:\\n    case 16777216:\\n    case 33554432:\\n      return lanes & 62914560;\\n    case 67108864:\\n      return 67108864;\\n    case 134217728:\\n      return 134217728;\\n    case 268435456:\\n      return 268435456;\\n    case 536870912:\\n      return 536870912;\\n    case 1073741824:\\n      return 0;\\n    default:\\n      return lanes;\\n  }\\n}\\nfunction getNextLanes(root, wipLanes, rootHasPendingCommit) {\\n  var pendingLanes = root.pendingLanes;\\n  if (0 === pendingLanes) return 0;\\n  var nextLanes = 0,\\n    suspendedLanes = root.suspendedLanes,\\n    pingedLanes = root.pingedLanes;\\n  root = root.warmLanes;\\n  var nonIdlePendingLanes = pendingLanes & 134217727;\\n  0 !== nonIdlePendingLanes\\n    ? ((pendingLanes = nonIdlePendingLanes & ~suspendedLanes),\\n      0 !== pendingLanes\\n        ? (nextLanes = getHighestPriorityLanes(pendingLanes))\\n        : ((pingedLanes &= nonIdlePendingLanes),\\n          0 !== pingedLanes\\n            ? (nextLanes = getHighestPriorityLanes(pingedLanes))\\n            : rootHasPendingCommit ||\\n              ((rootHasPendingCommit = nonIdlePendingLanes & ~root),\\n              0 !== rootHasPendingCommit &&\\n                (nextLanes = getHighestPriorityLanes(rootHasPendingCommit)))))\\n    : ((nonIdlePendingLanes = pendingLanes & ~suspendedLanes),\\n      0 !== nonIdlePendingLanes\\n        ? (nextLanes = getHighestPriorityLanes(nonIdlePendingLanes))\\n        : 0 !== pingedLanes\\n          ? (nextLanes = getHighestPriorityLanes(pingedLanes))\\n          : rootHasPendingCommit ||\\n            ((rootHasPendingCommit = pendingLanes & ~root),\\n            0 !== rootHasPendingCommit &&\\n              (nextLanes = getHighestPriorityLanes(rootHasPendingCommit))));\\n  return 0 === nextLanes\\n    ? 0\\n    : 0 !== wipLanes &&\\n        wipLanes !== nextLanes &&\\n        0 === (wipLanes & suspendedLanes) &&\\n        ((suspendedLanes = nextLanes & -nextLanes),\\n        (rootHasPendingCommit = wipLanes & -wipLanes),\\n        suspendedLanes >= rootHasPendingCommit ||\\n          (32 === suspendedLanes && 0 !== (rootHasPendingCommit & 4194048)))\\n      ? wipLanes\\n      : nextLanes;\\n}\\nfunction checkIfRootIsPrerendering(root, renderLanes) {\\n  return (\\n    0 ===\\n    (root.pendingLanes &\\n      ~(root.suspendedLanes & ~root.pingedLanes) &\\n      renderLanes)\\n  );\\n}\\nfunction computeExpirationTime(lane, currentTime) {\\n  switch (lane) {\\n    case 1:\\n    case 2:\\n    case 4:\\n    case 8:\\n    case 64:\\n      return currentTime + 250;\\n    case 16:\\n    case 32:\\n    case 128:\\n    case 256:\\n    case 512:\\n    case 1024:\\n    case 2048:\\n    case 4096:\\n    case 8192:\\n    case 16384:\\n    case 32768:\\n    case 65536:\\n    case 131072:\\n    case 262144:\\n    case 524288:\\n    case 1048576:\\n    case 2097152:\\n      return currentTime + 5e3;\\n    case 4194304:\\n    case 8388608:\\n    case 16777216:\\n    case 33554432:\\n      return -1;\\n    case 67108864:\\n    case 134217728:\\n    case 268435456:\\n    case 536870912:\\n    case 1073741824:\\n      return -1;\\n    default:\\n      return -1;\\n  }\\n}\\nfunction claimNextTransitionLane() {\\n  var lane = nextTransitionLane;\\n  nextTransitionLane <<= 1;\\n  0 === (nextTransitionLane & 4194048) && (nextTransitionLane = 256);\\n  return lane;\\n}\\nfunction claimNextRetryLane() {\\n  var lane = nextRetryLane;\\n  nextRetryLane <<= 1;\\n  0 === (nextRetryLane & 62914560) && (nextRetryLane = 4194304);\\n  return lane;\\n}\\nfunction createLaneMap(initial) {\\n  for (var laneMap = [], i = 0; 31 > i; i++) laneMap.push(initial);\\n  return laneMap;\\n}\\nfunction markRootUpdated$1(root, updateLane) {\\n  root.pendingLanes |= updateLane;\\n  268435456 !== updateLane &&\\n    ((root.suspendedLanes = 0), (root.pingedLanes = 0), (root.warmLanes = 0));\\n}\\nfunction markRootFinished(\\n  root,\\n  finishedLanes,\\n  remainingLanes,\\n  spawnedLane,\\n  updatedLanes,\\n  suspendedRetryLanes\\n) {\\n  var previouslyPendingLanes = root.pendingLanes;\\n  root.pendingLanes = remainingLanes;\\n  root.suspendedLanes = 0;\\n  root.pingedLanes = 0;\\n  root.warmLanes = 0;\\n  root.expiredLanes &= remainingLanes;\\n  root.entangledLanes &= remainingLanes;\\n  root.errorRecoveryDisabledLanes &= remainingLanes;\\n  root.shellSuspendCounter = 0;\\n  var entanglements = root.entanglements,\\n    expirationTimes = root.expirationTimes,\\n    hiddenUpdates = root.hiddenUpdates;\\n  for (\\n    remainingLanes = previouslyPendingLanes & ~remainingLanes;\\n    0 < remainingLanes;\\n\\n  ) {\\n    var index$5 = 31 - clz32(remainingLanes),\\n      lane = 1 << index$5;\\n    entanglements[index$5] = 0;\\n    expirationTimes[index$5] = -1;\\n    var hiddenUpdatesForLane = hiddenUpdates[index$5];\\n    if (null !== hiddenUpdatesForLane)\\n      for (\\n        hiddenUpdates[index$5] = null, index$5 = 0;\\n        index$5 < hiddenUpdatesForLane.length;\\n        index$5++\\n      ) {\\n        var update = hiddenUpdatesForLane[index$5];\\n        null !== update && (update.lane &= -536870913);\\n      }\\n    remainingLanes &= ~lane;\\n  }\\n  0 !== spawnedLane && markSpawnedDeferredLane(root, spawnedLane, 0);\\n  0 !== suspendedRetryLanes &&\\n    0 === updatedLanes &&\\n    0 !== root.tag &&\\n    (root.suspendedLanes |=\\n      suspendedRetryLanes & ~(previouslyPendingLanes & ~finishedLanes));\\n}\\nfunction markSpawnedDeferredLane(root, spawnedLane, entangledLanes) {\\n  root.pendingLanes |= spawnedLane;\\n  root.suspendedLanes &= ~spawnedLane;\\n  var spawnedLaneIndex = 31 - clz32(spawnedLane);\\n  root.entangledLanes |= spawnedLane;\\n  root.entanglements[spawnedLaneIndex] =\\n    root.entanglements[spawnedLaneIndex] |\\n    1073741824 |\\n    (entangledLanes & 4194090);\\n}\\nfunction markRootEntangled(root, entangledLanes) {\\n  var rootEntangledLanes = (root.entangledLanes |= entangledLanes);\\n  for (root = root.entanglements; rootEntangledLanes; ) {\\n    var index$6 = 31 - clz32(rootEntangledLanes),\\n      lane = 1 << index$6;\\n    (lane & entangledLanes) | (root[index$6] & entangledLanes) &&\\n      (root[index$6] |= entangledLanes);\\n    rootEntangledLanes &= ~lane;\\n  }\\n}\\nfunction getBumpedLaneForHydrationByLane(lane) {\\n  switch (lane) {\\n    case 2:\\n      lane = 1;\\n      break;\\n    case 8:\\n      lane = 4;\\n      break;\\n    case 32:\\n      lane = 16;\\n      break;\\n    case 256:\\n    case 512:\\n    case 1024:\\n    case 2048:\\n    case 4096:\\n    case 8192:\\n    case 16384:\\n    case 32768:\\n    case 65536:\\n    case 131072:\\n    case 262144:\\n    case 524288:\\n    case 1048576:\\n    case 2097152:\\n    case 4194304:\\n    case 8388608:\\n    case 16777216:\\n    case 33554432:\\n      lane = 128;\\n      break;\\n    case 268435456:\\n      lane = 134217728;\\n      break;\\n    default:\\n      lane = 0;\\n  }\\n  return lane;\\n}\\nfunction lanesToEventPriority(lanes) {\\n  lanes &= -lanes;\\n  return 2 < lanes\\n    ? 8 < lanes\\n      ? 0 !== (lanes & 134217727)\\n        ? 32\\n        : 268435456\\n      : 8\\n    : 2;\\n}\\nfunction resolveUpdatePriority() {\\n  var updatePriority = ReactDOMSharedInternals.p;\\n  if (0 !== updatePriority) return updatePriority;\\n  updatePriority = window.event;\\n  return void 0 === updatePriority ? 32 : getEventPriority(updatePriority.type);\\n}\\nfunction runWithPriority(priority, fn) {\\n  var previousPriority = ReactDOMSharedInternals.p;\\n  try {\\n    return (ReactDOMSharedInternals.p = priority), fn();\\n  } finally {\\n    ReactDOMSharedInternals.p = previousPriority;\\n  }\\n}\\nvar randomKey = Math.random().toString(36).slice(2),\\n  internalInstanceKey = \"__reactFiber$\" + randomKey,\\n  internalPropsKey = \"__reactProps$\" + randomKey,\\n  internalContainerInstanceKey = \"__reactContainer$\" + randomKey,\\n  internalEventHandlersKey = \"__reactEvents$\" + randomKey,\\n  internalEventHandlerListenersKey = \"__reactListeners$\" + randomKey,\\n  internalEventHandlesSetKey = \"__reactHandles$\" + randomKey,\\n  internalRootNodeResourcesKey = \"__reactResources$\" + randomKey,\\n  internalHoistableMarker = \"__reactMarker$\" + randomKey;\\nfunction detachDeletedInstance(node) {\\n  delete node[internalInstanceKey];\\n  delete node[internalPropsKey];\\n  delete node[internalEventHandlersKey];\\n  delete node[internalEventHandlerListenersKey];\\n  delete node[internalEventHandlesSetKey];\\n}\\nfunction getClosestInstanceFromNode(targetNode) {\\n  var targetInst = targetNode[internalInstanceKey];\\n  if (targetInst) return targetInst;\\n  for (var parentNode = targetNode.parentNode; parentNode; ) {\\n    if (\\n      (targetInst =\\n        parentNode[internalContainerInstanceKey] ||\\n        parentNode[internalInstanceKey])\\n    ) {\\n      parentNode = targetInst.alternate;\\n      if (\\n        null !== targetInst.child ||\\n        (null !== parentNode && null !== parentNode.child)\\n      )\\n        for (\\n          targetNode = getParentSuspenseInstance(targetNode);\\n          null !== targetNode;\\n\\n        ) {\\n          if ((parentNode = targetNode[internalInstanceKey])) return parentNode;\\n          targetNode = getParentSuspenseInstance(targetNode);\\n        }\\n      return targetInst;\\n    }\\n    targetNode = parentNode;\\n    parentNode = targetNode.parentNode;\\n  }\\n  return null;\\n}\\nfunction getInstanceFromNode(node) {\\n  if (\\n    (node = node[internalInstanceKey] || node[internalContainerInstanceKey])\\n  ) {\\n    var tag = node.tag;\\n    if (\\n      5 === tag ||\\n      6 === tag ||\\n      13 === tag ||\\n      26 === tag ||\\n      27 === tag ||\\n      3 === tag\\n    )\\n      return node;\\n  }\\n  return null;\\n}\\nfunction getNodeFromInstance(inst) {\\n  var tag = inst.tag;\\n  if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return inst.stateNode;\\n  throw Error(formatProdErrorMessage(33));\\n}\\nfunction getResourcesFromRoot(root) {\\n  var resources = root[internalRootNodeResourcesKey];\\n  resources ||\\n    (resources = root[internalRootNodeResourcesKey] =\\n      { hoistableStyles: new Map(), hoistableScripts: new Map() });\\n  return resources;\\n}\\nfunction markNodeAsHoistable(node) {\\n  node[internalHoistableMarker] = !0;\\n}\\nvar allNativeEvents = new Set(),\\n  registrationNameDependencies = {};\\nfunction registerTwoPhaseEvent(registrationName, dependencies) {\\n  registerDirectEvent(registrationName, dependencies);\\n  registerDirectEvent(registrationName + \"Capture\", dependencies);\\n}\\nfunction registerDirectEvent(registrationName, dependencies) {\\n  registrationNameDependencies[registrationName] = dependencies;\\n  for (\\n    registrationName = 0;\\n    registrationName < dependencies.length;\\n    registrationName++\\n  )\\n    allNativeEvents.add(dependencies[registrationName]);\\n}\\nvar VALID_ATTRIBUTE_NAME_REGEX = RegExp(\\n    \"^[:A-Z_a-z\\\\\\\\u00C0-\\\\\\\\u00D6\\\\\\\\u00D8-\\\\\\\\u00F6\\\\\\\\u00F8-\\\\\\\\u02FF\\\\\\\\u0370-\\\\\\\\u037D\\\\\\\\u037F-\\\\\\\\u1FFF\\\\\\\\u200C-\\\\\\\\u200D\\\\\\\\u2070-\\\\\\\\u218F\\\\\\\\u2C00-\\\\\\\\u2FEF\\\\\\\\u3001-\\\\\\\\uD7FF\\\\\\\\uF900-\\\\\\\\uFDCF\\\\\\\\uFDF0-\\\\\\\\uFFFD][:A-Z_a-z\\\\\\\\u00C0-\\\\\\\\u00D6\\\\\\\\u00D8-\\\\\\\\u00F6\\\\\\\\u00F8-\\\\\\\\u02FF\\\\\\\\u0370-\\\\\\\\u037D\\\\\\\\u037F-\\\\\\\\u1FFF\\\\\\\\u200C-\\\\\\\\u200D\\\\\\\\u2070-\\\\\\\\u218F\\\\\\\\u2C00-\\\\\\\\u2FEF\\\\\\\\u3001-\\\\\\\\uD7FF\\\\\\\\uF900-\\\\\\\\uFDCF\\\\\\\\uFDF0-\\\\\\\\uFFFD\\\\\\\\-.0-9\\\\\\\\u00B7\\\\\\\\u0300-\\\\\\\\u036F\\\\\\\\u203F-\\\\\\\\u2040]*$\"\\n  ),\\n  illegalAttributeNameCache = {},\\n  validatedAttributeNameCache = {};\\nfunction isAttributeNameSafe(attributeName) {\\n  if (hasOwnProperty.call(validatedAttributeNameCache, attributeName))\\n    return !0;\\n  if (hasOwnProperty.call(illegalAttributeNameCache, attributeName)) return !1;\\n  if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName))\\n    return (validatedAttributeNameCache[attributeName] = !0);\\n  illegalAttributeNameCache[attributeName] = !0;\\n  return !1;\\n}\\nfunction setValueForAttribute(node, name, value) {\\n  if (isAttributeNameSafe(name))\\n    if (null === value) node.removeAttribute(name);\\n    else {\\n      switch (typeof value) {\\n        case \"undefined\":\\n        case \"function\":\\n        case \"symbol\":\\n          node.removeAttribute(name);\\n          return;\\n        case \"boolean\":\\n          var prefix$8 = name.toLowerCase().slice(0, 5);\\n          if (\"data-\" !== prefix$8 && \"aria-\" !== prefix$8) {\\n            node.removeAttribute(name);\\n            return;\\n          }\\n      }\\n      node.setAttribute(name, \"\" + value);\\n    }\\n}\\nfunction setValueForKnownAttribute(node, name, value) {\\n  if (null === value) node.removeAttribute(name);\\n  else {\\n    switch (typeof value) {\\n      case \"undefined\":\\n      case \"function\":\\n      case \"symbol\":\\n      case \"boolean\":\\n        node.removeAttribute(name);\\n        return;\\n    }\\n    node.setAttribute(name, \"\" + value);\\n  }\\n}\\nfunction setValueForNamespacedAttribute(node, namespace, name, value) {\\n  if (null === value) node.removeAttribute(name);\\n  else {\\n    switch (typeof value) {\\n      case \"undefined\":\\n      case \"function\":\\n      case \"symbol\":\\n      case \"boolean\":\\n        node.removeAttribute(name);\\n        return;\\n    }\\n    node.setAttributeNS(namespace, name, \"\" + value);\\n  }\\n}\\nvar prefix, suffix;\\nfunction describeBuiltInComponentFrame(name) {\\n  if (void 0 === prefix)\\n    try {\\n      throw Error();\\n    } catch (x) {\\n      var match = x.stack.trim().match(/\\\\n( *(at )?)/);\\n      prefix = (match && match[1]) || \"\";\\n      suffix =\\n        -1 < x.stack.indexOf(\"\\\\n    at\")\\n          ? \" (<anonymous>)\"\\n          : -1 < x.stack.indexOf(\"@\")\\n            ? \"@unknown:0:0\"\\n            : \"\";\\n    }\\n  return \"\\\\n\" + prefix + name + suffix;\\n}\\nvar reentry = !1;\\nfunction describeNativeComponentFrame(fn, construct) {\\n  if (!fn || reentry) return \"\";\\n  reentry = !0;\\n  var previousPrepareStackTrace = Error.prepareStackTrace;\\n  Error.prepareStackTrace = void 0;\\n  try {\\n    var RunInRootFrame = {\\n      DetermineComponentFrameRoot: function () {\\n        try {\\n          if (construct) {\\n            var Fake = function () {\\n              throw Error();\\n            };\\n            Object.defineProperty(Fake.prototype, \"props\", {\\n              set: function () {\\n                throw Error();\\n              }\\n            });\\n            if (\"object\" === typeof Reflect && Reflect.construct) {\\n              try {\\n                Reflect.construct(Fake, []);\\n              } catch (x) {\\n                var control = x;\\n              }\\n              Reflect.construct(fn, [], Fake);\\n            } else {\\n              try {\\n                Fake.call();\\n              } catch (x$9) {\\n                control = x$9;\\n              }\\n              fn.call(Fake.prototype);\\n            }\\n          } else {\\n            try {\\n              throw Error();\\n            } catch (x$10) {\\n              control = x$10;\\n            }\\n            (Fake = fn()) &&\\n              \"function\" === typeof Fake.catch &&\\n              Fake.catch(function () {});\\n          }\\n        } catch (sample) {\\n          if (sample && control && \"string\" === typeof sample.stack)\\n            return [sample.stack, control.stack];\\n        }\\n        return [null, null];\\n      }\\n    };\\n    RunInRootFrame.DetermineComponentFrameRoot.displayName =\\n      \"DetermineComponentFrameRoot\";\\n    var namePropDescriptor = Object.getOwnPropertyDescriptor(\\n      RunInRootFrame.DetermineComponentFrameRoot,\\n      \"name\"\\n    );\\n    namePropDescriptor &&\\n      namePropDescriptor.configurable &&\\n      Object.defineProperty(\\n        RunInRootFrame.DetermineComponentFrameRoot,\\n        \"name\",\\n        { value: \"DetermineComponentFrameRoot\" }\\n      );\\n    var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(),\\n      sampleStack = _RunInRootFrame$Deter[0],\\n      controlStack = _RunInRootFrame$Deter[1];\\n    if (sampleStack && controlStack) {\\n      var sampleLines = sampleStack.split(\"\\\\n\"),\\n        controlLines = controlStack.split(\"\\\\n\");\\n      for (\\n        namePropDescriptor = RunInRootFrame = 0;\\n        RunInRootFrame < sampleLines.length &&\\n        !sampleLines[RunInRootFrame].includes(\"DetermineComponentFrameRoot\");\\n\\n      )\\n        RunInRootFrame++;\\n      for (\\n        ;\\n        namePropDescriptor < controlLines.length &&\\n        !controlLines[namePropDescriptor].includes(\\n          \"DetermineComponentFrameRoot\"\\n        );\\n\\n      )\\n        namePropDescriptor++;\\n      if (\\n        RunInRootFrame === sampleLines.length ||\\n        namePropDescriptor === controlLines.length\\n      )\\n        for (\\n          RunInRootFrame = sampleLines.length - 1,\\n            namePropDescriptor = controlLines.length - 1;\\n          1 <= RunInRootFrame &&\\n          0 <= namePropDescriptor &&\\n          sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor];\\n\\n        )\\n          namePropDescriptor--;\\n      for (\\n        ;\\n        1 <= RunInRootFrame && 0 <= namePropDescriptor;\\n        RunInRootFrame--, namePropDescriptor--\\n      )\\n        if (sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]) {\\n          if (1 !== RunInRootFrame || 1 !== namePropDescriptor) {\\n            do\\n              if (\\n                (RunInRootFrame--,\\n                namePropDescriptor--,\\n                0 > namePropDescriptor ||\\n                  sampleLines[RunInRootFrame] !==\\n                    controlLines[namePropDescriptor])\\n              ) {\\n                var frame =\\n                  \"\\\\n\" +\\n                  sampleLines[RunInRootFrame].replace(\" at new \", \" at \");\\n                fn.displayName &&\\n                  frame.includes(\"<anonymous>\") &&\\n                  (frame = frame.replace(\"<anonymous>\", fn.displayName));\\n                return frame;\\n              }\\n            while (1 <= RunInRootFrame && 0 <= namePropDescriptor);\\n          }\\n          break;\\n        }\\n    }\\n  } finally {\\n    (reentry = !1), (Error.prepareStackTrace = previousPrepareStackTrace);\\n  }\\n  return (previousPrepareStackTrace = fn ? fn.displayName || fn.name : \"\")\\n    ? describeBuiltInComponentFrame(previousPrepareStackTrace)\\n    : \"\";\\n}\\nfunction describeFiber(fiber) {\\n  switch (fiber.tag) {\\n    case 26:\\n    case 27:\\n    case 5:\\n      return describeBuiltInComponentFrame(fiber.type);\\n    case 16:\\n      return describeBuiltInComponentFrame(\"Lazy\");\\n    case 13:\\n      return describeBuiltInComponentFrame(\"Suspense\");\\n    case 19:\\n      return describeBuiltInComponentFrame(\"SuspenseList\");\\n    case 0:\\n    case 15:\\n      return describeNativeComponentFrame(fiber.type, !1);\\n    case 11:\\n      return describeNativeComponentFrame(fiber.type.render, !1);\\n    case 1:\\n      return describeNativeComponentFrame(fiber.type, !0);\\n    case 31:\\n      return describeBuiltInComponentFrame(\"Activity\");\\n    default:\\n      return \"\";\\n  }\\n}\\nfunction getStackByFiberInDevAndProd(workInProgress) {\\n  try {\\n    var info = \"\";\\n    do\\n      (info += describeFiber(workInProgress)),\\n        (workInProgress = workInProgress.return);\\n    while (workInProgress);\\n    return info;\\n  } catch (x) {\\n    return \"\\\\nError generating stack: \" + x.message + \"\\\\n\" + x.stack;\\n  }\\n}\\nfunction getToStringValue(value) {\\n  switch (typeof value) {\\n    case \"bigint\":\\n    case \"boolean\":\\n    case \"number\":\\n    case \"string\":\\n    case \"undefined\":\\n      return value;\\n    case \"object\":\\n      return value;\\n    default:\\n      return \"\";\\n  }\\n}\\nfunction isCheckable(elem) {\\n  var type = elem.type;\\n  return (\\n    (elem = elem.nodeName) &&\\n    \"input\" === elem.toLowerCase() &&\\n    (\"checkbox\" === type || \"radio\" === type)\\n  );\\n}\\nfunction trackValueOnNode(node) {\\n  var valueField = isCheckable(node) ? \"checked\" : \"value\",\\n    descriptor = Object.getOwnPropertyDescriptor(\\n      node.constructor.prototype,\\n      valueField\\n    ),\\n    currentValue = \"\" + node[valueField];\\n  if (\\n    !node.hasOwnProperty(valueField) &&\\n    \"undefined\" !== typeof descriptor &&\\n    \"function\" === typeof descriptor.get &&\\n    \"function\" === typeof descriptor.set\\n  ) {\\n    var get = descriptor.get,\\n      set = descriptor.set;\\n    Object.defineProperty(node, valueField, {\\n      configurable: !0,\\n      get: function () {\\n        return get.call(this);\\n      },\\n      set: function (value) {\\n        currentValue = \"\" + value;\\n        set.call(this, value);\\n      }\\n    });\\n    Object.defineProperty(node, valueField, {\\n      enumerable: descriptor.enumerable\\n    });\\n    return {\\n      getValue: function () {\\n        return currentValue;\\n      },\\n      setValue: function (value) {\\n        currentValue = \"\" + value;\\n      },\\n      stopTracking: function () {\\n        node._valueTracker = null;\\n        delete node[valueField];\\n      }\\n    };\\n  }\\n}\\nfunction track(node) {\\n  node._valueTracker || (node._valueTracker = trackValueOnNode(node));\\n}\\nfunction updateValueIfChanged(node) {\\n  if (!node) return !1;\\n  var tracker = node._valueTracker;\\n  if (!tracker) return !0;\\n  var lastValue = tracker.getValue();\\n  var value = \"\";\\n  node &&\\n    (value = isCheckable(node)\\n      ? node.checked\\n        ? \"true\"\\n        : \"false\"\\n      : node.value);\\n  node = value;\\n  return node !== lastValue ? (tracker.setValue(node), !0) : !1;\\n}\\nfunction getActiveElement(doc) {\\n  doc = doc || (\"undefined\" !== typeof document ? document : void 0);\\n  if (\"undefined\" === typeof doc) return null;\\n  try {\\n    return doc.activeElement || doc.body;\\n  } catch (e) {\\n    return doc.body;\\n  }\\n}\\nvar escapeSelectorAttributeValueInsideDoubleQuotesRegex = /[\\\\n\"\\\\\\\\]/g;\\nfunction escapeSelectorAttributeValueInsideDoubleQuotes(value) {\\n  return value.replace(\\n    escapeSelectorAttributeValueInsideDoubleQuotesRegex,\\n    function (ch) {\\n      return \"\\\\\\\\\" + ch.charCodeAt(0).toString(16) + \" \";\\n    }\\n  );\\n}\\nfunction updateInput(\\n  element,\\n  value,\\n  defaultValue,\\n  lastDefaultValue,\\n  checked,\\n  defaultChecked,\\n  type,\\n  name\\n) {\\n  element.name = \"\";\\n  null != type &&\\n  \"function\" !== typeof type &&\\n  \"symbol\" !== typeof type &&\\n  \"boolean\" !== typeof type\\n    ? (element.type = type)\\n    : element.removeAttribute(\"type\");\\n  if (null != value)\\n    if (\"number\" === type) {\\n      if ((0 === value && \"\" === element.value) || element.value != value)\\n        element.value = \"\" + getToStringValue(value);\\n    } else\\n      element.value !== \"\" + getToStringValue(value) &&\\n        (element.value = \"\" + getToStringValue(value));\\n  else\\n    (\"submit\" !== type && \"reset\" !== type) || element.removeAttribute(\"value\");\\n  null != value\\n    ? setDefaultValue(element, type, getToStringValue(value))\\n    : null != defaultValue\\n      ? setDefaultValue(element, type, getToStringValue(defaultValue))\\n      : null != lastDefaultValue && element.removeAttribute(\"value\");\\n  null == checked &&\\n    null != defaultChecked &&\\n    (element.defaultChecked = !!defaultChecked);\\n  null != checked &&\\n    (element.checked =\\n      checked && \"function\" !== typeof checked && \"symbol\" !== typeof checked);\\n  null != name &&\\n  \"function\" !== typeof name &&\\n  \"symbol\" !== typeof name &&\\n  \"boolean\" !== typeof name\\n    ? (element.name = \"\" + getToStringValue(name))\\n    : element.removeAttribute(\"name\");\\n}\\nfunction initInput(\\n  element,\\n  value,\\n  defaultValue,\\n  checked,\\n  defaultChecked,\\n  type,\\n  name,\\n  isHydrating\\n) {\\n  null != type &&\\n    \"function\" !== typeof type &&\\n    \"symbol\" !== typeof type &&\\n    \"boolean\" !== typeof type &&\\n    (element.type = type);\\n  if (null != value || null != defaultValue) {\\n    if (\\n      !(\\n        (\"submit\" !== type && \"reset\" !== type) ||\\n        (void 0 !== value && null !== value)\\n      )\\n    )\\n      return;\\n    defaultValue =\\n      null != defaultValue ? \"\" + getToStringValue(defaultValue) : \"\";\\n    value = null != value ? \"\" + getToStringValue(value) : defaultValue;\\n    isHydrating || value === element.value || (element.value = value);\\n    element.defaultValue = value;\\n  }\\n  checked = null != checked ? checked : defaultChecked;\\n  checked =\\n    \"function\" !== typeof checked && \"symbol\" !== typeof checked && !!checked;\\n  element.checked = isHydrating ? element.checked : !!checked;\\n  element.defaultChecked = !!checked;\\n  null != name &&\\n    \"function\" !== typeof name &&\\n    \"symbol\" !== typeof name &&\\n    \"boolean\" !== typeof name &&\\n    (element.name = name);\\n}\\nfunction setDefaultValue(node, type, value) {\\n  (\"number\" === type && getActiveElement(node.ownerDocument) === node) ||\\n    node.defaultValue === \"\" + value ||\\n    (node.defaultValue = \"\" + value);\\n}\\nfunction updateOptions(node, multiple, propValue, setDefaultSelected) {\\n  node = node.options;\\n  if (multiple) {\\n    multiple = {};\\n    for (var i = 0; i < propValue.length; i++)\\n      multiple[\"$\" + propValue[i]] = !0;\\n    for (propValue = 0; propValue < node.length; propValue++)\\n      (i = multiple.hasOwnProperty(\"$\" + node[propValue].value)),\\n        node[propValue].selected !== i && (node[propValue].selected = i),\\n        i && setDefaultSelected && (node[propValue].defaultSelected = !0);\\n  } else {\\n    propValue = \"\" + getToStringValue(propValue);\\n    multiple = null;\\n    for (i = 0; i < node.length; i++) {\\n      if (node[i].value === propValue) {\\n        node[i].selected = !0;\\n        setDefaultSelected && (node[i].defaultSelected = !0);\\n        return;\\n      }\\n      null !== multiple || node[i].disabled || (multiple = node[i]);\\n    }\\n    null !== multiple && (multiple.selected = !0);\\n  }\\n}\\nfunction updateTextarea(element, value, defaultValue) {\\n  if (\\n    null != value &&\\n    ((value = \"\" + getToStringValue(value)),\\n    value !== element.value && (element.value = value),\\n    null == defaultValue)\\n  ) {\\n    element.defaultValue !== value && (element.defaultValue = value);\\n    return;\\n  }\\n  element.defaultValue =\\n    null != defaultValue ? \"\" + getToStringValue(defaultValue) : \"\";\\n}\\nfunction initTextarea(element, value, defaultValue, children) {\\n  if (null == value) {\\n    if (null != children) {\\n      if (null != defaultValue) throw Error(formatProdErrorMessage(92));\\n      if (isArrayImpl(children)) {\\n        if (1 < children.length) throw Error(formatProdErrorMessage(93));\\n        children = children[0];\\n      }\\n      defaultValue = children;\\n    }\\n    null == defaultValue && (defaultValue = \"\");\\n    value = defaultValue;\\n  }\\n  defaultValue = getToStringValue(value);\\n  element.defaultValue = defaultValue;\\n  children = element.textContent;\\n  children === defaultValue &&\\n    \"\" !== children &&\\n    null !== children &&\\n    (element.value = children);\\n}\\nfunction setTextContent(node, text) {\\n  if (text) {\\n    var firstChild = node.firstChild;\\n    if (\\n      firstChild &&\\n      firstChild === node.lastChild &&\\n      3 === firstChild.nodeType\\n    ) {\\n      firstChild.nodeValue = text;\\n      return;\\n    }\\n  }\\n  node.textContent = text;\\n}\\nvar unitlessNumbers = new Set(\\n  \"animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp\".split(\\n    \" \"\\n  )\\n);\\nfunction setValueForStyle(style, styleName, value) {\\n  var isCustomProperty = 0 === styleName.indexOf(\"--\");\\n  null == value || \"boolean\" === typeof value || \"\" === value\\n    ? isCustomProperty\\n      ? style.setProperty(styleName, \"\")\\n      : \"float\" === styleName\\n        ? (style.cssFloat = \"\")\\n        : (style[styleName] = \"\")\\n    : isCustomProperty\\n      ? style.setProperty(styleName, value)\\n      : \"number\" !== typeof value ||\\n          0 === value ||\\n          unitlessNumbers.has(styleName)\\n        ? \"float\" === styleName\\n          ? (style.cssFloat = value)\\n          : (style[styleName] = (\"\" + value).trim())\\n        : (style[styleName] = value + \"px\");\\n}\\nfunction setValueForStyles(node, styles, prevStyles) {\\n  if (null != styles && \"object\" !== typeof styles)\\n    throw Error(formatProdErrorMessage(62));\\n  node = node.style;\\n  if (null != prevStyles) {\\n    for (var styleName in prevStyles)\\n      !prevStyles.hasOwnProperty(styleName) ||\\n        (null != styles && styles.hasOwnProperty(styleName)) ||\\n        (0 === styleName.indexOf(\"--\")\\n          ? node.setProperty(styleName, \"\")\\n          : \"float\" === styleName\\n            ? (node.cssFloat = \"\")\\n            : (node[styleName] = \"\"));\\n    for (var styleName$16 in styles)\\n      (styleName = styles[styleName$16]),\\n        styles.hasOwnProperty(styleName$16) &&\\n          prevStyles[styleName$16] !== styleName &&\\n          setValueForStyle(node, styleName$16, styleName);\\n  } else\\n    for (var styleName$17 in styles)\\n      styles.hasOwnProperty(styleName$17) &&\\n        setValueForStyle(node, styleName$17, styles[styleName$17]);\\n}\\nfunction isCustomElement(tagName) {\\n  if (-1 === tagName.indexOf(\"-\")) return !1;\\n  switch (tagName) {\\n    case \"annotation-xml\":\\n    case \"color-profile\":\\n    case \"font-face\":\\n    case \"font-face-src\":\\n    case \"font-face-uri\":\\n    case \"font-face-format\":\\n    case \"font-face-name\":\\n    case \"missing-glyph\":\\n      return !1;\\n    default:\\n      return !0;\\n  }\\n}\\nvar aliases = new Map([\\n    [\"acceptCharset\", \"accept-charset\"],\\n    [\"htmlFor\", \"for\"],\\n    [\"httpEquiv\", \"http-equiv\"],\\n    [\"crossOrigin\", \"crossorigin\"],\\n    [\"accentHeight\", \"accent-height\"],\\n    [\"alignmentBaseline\", \"alignment-baseline\"],\\n    [\"arabicForm\", \"arabic-form\"],\\n    [\"baselineShift\", \"baseline-shift\"],\\n    [\"capHeight\", \"cap-height\"],\\n    [\"clipPath\", \"clip-path\"],\\n    [\"clipRule\", \"clip-rule\"],\\n    [\"colorInterpolation\", \"color-interpolation\"],\\n    [\"colorInterpolationFilters\", \"color-interpolation-filters\"],\\n    [\"colorProfile\", \"color-profile\"],\\n    [\"colorRendering\", \"color-rendering\"],\\n    [\"dominantBaseline\", \"dominant-baseline\"],\\n    [\"enableBackground\", \"enable-background\"],\\n    [\"fillOpacity\", \"fill-opacity\"],\\n    [\"fillRule\", \"fill-rule\"],\\n    [\"floodColor\", \"flood-color\"],\\n    [\"floodOpacity\", \"flood-opacity\"],\\n    [\"fontFamily\", \"font-family\"],\\n    [\"fontSize\", \"font-size\"],\\n    [\"fontSizeAdjust\", \"font-size-adjust\"],\\n    [\"fontStretch\", \"font-stretch\"],\\n    [\"fontStyle\", \"font-style\"],\\n    [\"fontVariant\", \"font-variant\"],\\n    [\"fontWeight\", \"font-weight\"],\\n    [\"glyphName\", \"glyph-name\"],\\n    [\"glyphOrientationHorizontal\", \"glyph-orientation-horizontal\"],\\n    [\"glyphOrientationVertical\", \"glyph-orientation-vertical\"],\\n    [\"horizAdvX\", \"horiz-adv-x\"],\\n    [\"horizOriginX\", \"horiz-origin-x\"],\\n    [\"imageRendering\", \"image-rendering\"],\\n    [\"letterSpacing\", \"letter-spacing\"],\\n    [\"lightingColor\", \"lighting-color\"],\\n    [\"markerEnd\", \"marker-end\"],\\n    [\"markerMid\", \"marker-mid\"],\\n    [\"markerStart\", \"marker-start\"],\\n    [\"overlinePosition\", \"overline-position\"],\\n    [\"overlineThickness\", \"overline-thickness\"],\\n    [\"paintOrder\", \"paint-order\"],\\n    [\"panose-1\", \"panose-1\"],\\n    [\"pointerEvents\", \"pointer-events\"],\\n    [\"renderingIntent\", \"rendering-intent\"],\\n    [\"shapeRendering\", \"shape-rendering\"],\\n    [\"stopColor\", \"stop-color\"],\\n    [\"stopOpacity\", \"stop-opacity\"],\\n    [\"strikethroughPosition\", \"strikethrough-position\"],\\n    [\"strikethroughThickness\", \"strikethrough-thickness\"],\\n    [\"strokeDasharray\", \"stroke-dasharray\"],\\n    [\"strokeDashoffset\", \"stroke-dashoffset\"],\\n    [\"strokeLinecap\", \"stroke-linecap\"],\\n    [\"strokeLinejoin\", \"stroke-linejoin\"],\\n    [\"strokeMiterlimit\", \"stroke-miterlimit\"],\\n    [\"strokeOpacity\", \"stroke-opacity\"],\\n    [\"strokeWidth\", \"stroke-width\"],\\n    [\"textAnchor\", \"text-anchor\"],\\n    [\"textDecoration\", \"text-decoration\"],\\n    [\"textRendering\", \"text-rendering\"],\\n    [\"transformOrigin\", \"transform-origin\"],\\n    [\"underlinePosition\", \"underline-position\"],\\n    [\"underlineThickness\", \"underline-thickness\"],\\n    [\"unicodeBidi\", \"unicode-bidi\"],\\n    [\"unicodeRange\", \"unicode-range\"],\\n    [\"unitsPerEm\", \"units-per-em\"],\\n    [\"vAlphabetic\", \"v-alphabetic\"],\\n    [\"vHanging\", \"v-hanging\"],\\n    [\"vIdeographic\", \"v-ideographic\"],\\n    [\"vMathematical\", \"v-mathematical\"],\\n    [\"vectorEffect\", \"vector-effect\"],\\n    [\"vertAdvY\", \"vert-adv-y\"],\\n    [\"vertOriginX\", \"vert-origin-x\"],\\n    [\"vertOriginY\", \"vert-origin-y\"],\\n    [\"wordSpacing\", \"word-spacing\"],\\n    [\"writingMode\", \"writing-mode\"],\\n    [\"xmlnsXlink\", \"xmlns:xlink\"],\\n    [\"xHeight\", \"x-height\"]\\n  ]),\\n  isJavaScriptProtocol =\\n    /^[\\\\u0000-\\\\u001F ]*j[\\\\r\\\\n\\\\t]*a[\\\\r\\\\n\\\\t]*v[\\\\r\\\\n\\\\t]*a[\\\\r\\\\n\\\\t]*s[\\\\r\\\\n\\\\t]*c[\\\\r\\\\n\\\\t]*r[\\\\r\\\\n\\\\t]*i[\\\\r\\\\n\\\\t]*p[\\\\r\\\\n\\\\t]*t[\\\\r\\\\n\\\\t]*:/i;\\nfunction sanitizeURL(url) {\\n  return isJavaScriptProtocol.test(\"\" + url)\\n    ? \"javascript:throw new Error(\\'React has blocked a javascript: URL as a security precaution.\\')\"\\n    : url;\\n}\\nvar currentReplayingEvent = null;\\nfunction getEventTarget(nativeEvent) {\\n  nativeEvent = nativeEvent.target || nativeEvent.srcElement || window;\\n  nativeEvent.correspondingUseElement &&\\n    (nativeEvent = nativeEvent.correspondingUseElement);\\n  return 3 === nativeEvent.nodeType ? nativeEvent.parentNode : nativeEvent;\\n}\\nvar restoreTarget = null,\\n  restoreQueue = null;\\nfunction restoreStateOfTarget(target) {\\n  var internalInstance = getInstanceFromNode(target);\\n  if (internalInstance && (target = internalInstance.stateNode)) {\\n    var props = target[internalPropsKey] || null;\\n    a: switch (((target = internalInstance.stateNode), internalInstance.type)) {\\n      case \"input\":\\n        updateInput(\\n          target,\\n          props.value,\\n          props.defaultValue,\\n          props.defaultValue,\\n          props.checked,\\n          props.defaultChecked,\\n          props.type,\\n          props.name\\n        );\\n        internalInstance = props.name;\\n        if (\"radio\" === props.type && null != internalInstance) {\\n          for (props = target; props.parentNode; ) props = props.parentNode;\\n          props = props.querySelectorAll(\\n            \\'input[name=\"\\' +\\n              escapeSelectorAttributeValueInsideDoubleQuotes(\\n                \"\" + internalInstance\\n              ) +\\n              \\'\"][type=\"radio\"]\\'\\n          );\\n          for (\\n            internalInstance = 0;\\n            internalInstance < props.length;\\n            internalInstance++\\n          ) {\\n            var otherNode = props[internalInstance];\\n            if (otherNode !== target && otherNode.form === target.form) {\\n              var otherProps = otherNode[internalPropsKey] || null;\\n              if (!otherProps) throw Error(formatProdErrorMessage(90));\\n              updateInput(\\n                otherNode,\\n                otherProps.value,\\n                otherProps.defaultValue,\\n                otherProps.defaultValue,\\n                otherProps.checked,\\n                otherProps.defaultChecked,\\n                otherProps.type,\\n                otherProps.name\\n              );\\n            }\\n          }\\n          for (\\n            internalInstance = 0;\\n            internalInstance < props.length;\\n            internalInstance++\\n          )\\n            (otherNode = props[internalInstance]),\\n              otherNode.form === target.form && updateValueIfChanged(otherNode);\\n        }\\n        break a;\\n      case \"textarea\":\\n        updateTextarea(target, props.value, props.defaultValue);\\n        break a;\\n      case \"select\":\\n        (internalInstance = props.value),\\n          null != internalInstance &&\\n            updateOptions(target, !!props.multiple, internalInstance, !1);\\n    }\\n  }\\n}\\nvar isInsideEventHandler = !1;\\nfunction batchedUpdates$1(fn, a, b) {\\n  if (isInsideEventHandler) return fn(a, b);\\n  isInsideEventHandler = !0;\\n  try {\\n    var JSCompiler_inline_result = fn(a);\\n    return JSCompiler_inline_result;\\n  } finally {\\n    if (\\n      ((isInsideEventHandler = !1),\\n      null !== restoreTarget || null !== restoreQueue)\\n    )\\n      if (\\n        (flushSyncWork$1(),\\n        restoreTarget &&\\n          ((a = restoreTarget),\\n          (fn = restoreQueue),\\n          (restoreQueue = restoreTarget = null),\\n          restoreStateOfTarget(a),\\n          fn))\\n      )\\n        for (a = 0; a < fn.length; a++) restoreStateOfTarget(fn[a]);\\n  }\\n}\\nfunction getListener(inst, registrationName) {\\n  var stateNode = inst.stateNode;\\n  if (null === stateNode) return null;\\n  var props = stateNode[internalPropsKey] || null;\\n  if (null === props) return null;\\n  stateNode = props[registrationName];\\n  a: switch (registrationName) {\\n    case \"onClick\":\\n    case \"onClickCapture\":\\n    case \"onDoubleClick\":\\n    case \"onDoubleClickCapture\":\\n    case \"onMouseDown\":\\n    case \"onMouseDownCapture\":\\n    case \"onMouseMove\":\\n    case \"onMouseMoveCapture\":\\n    case \"onMouseUp\":\\n    case \"onMouseUpCapture\":\\n    case \"onMouseEnter\":\\n      (props = !props.disabled) ||\\n        ((inst = inst.type),\\n        (props = !(\\n          \"button\" === inst ||\\n          \"input\" === inst ||\\n          \"select\" === inst ||\\n          \"textarea\" === inst\\n        )));\\n      inst = !props;\\n      break a;\\n    default:\\n      inst = !1;\\n  }\\n  if (inst) return null;\\n  if (stateNode && \"function\" !== typeof stateNode)\\n    throw Error(\\n      formatProdErrorMessage(231, registrationName, typeof stateNode)\\n    );\\n  return stateNode;\\n}\\nvar canUseDOM = !(\\n    \"undefined\" === typeof window ||\\n    \"undefined\" === typeof window.document ||\\n    \"undefined\" === typeof window.document.createElement\\n  ),\\n  passiveBrowserEventsSupported = !1;\\nif (canUseDOM)\\n  try {\\n    var options = {};\\n    Object.defineProperty(options, \"passive\", {\\n      get: function () {\\n        passiveBrowserEventsSupported = !0;\\n      }\\n    });\\n    window.addEventListener(\"test\", options, options);\\n    window.removeEventListener(\"test\", options, options);\\n  } catch (e) {\\n    passiveBrowserEventsSupported = !1;\\n  }\\nvar root = null,\\n  startText = null,\\n  fallbackText = null;\\nfunction getData() {\\n  if (fallbackText) return fallbackText;\\n  var start,\\n    startValue = startText,\\n    startLength = startValue.length,\\n    end,\\n    endValue = \"value\" in root ? root.value : root.textContent,\\n    endLength = endValue.length;\\n  for (\\n    start = 0;\\n    start < startLength && startValue[start] === endValue[start];\\n    start++\\n  );\\n  var minEnd = startLength - start;\\n  for (\\n    end = 1;\\n    end <= minEnd &&\\n    startValue[startLength - end] === endValue[endLength - end];\\n    end++\\n  );\\n  return (fallbackText = endValue.slice(start, 1 < end ? 1 - end : void 0));\\n}\\nfunction getEventCharCode(nativeEvent) {\\n  var keyCode = nativeEvent.keyCode;\\n  \"charCode\" in nativeEvent\\n    ? ((nativeEvent = nativeEvent.charCode),\\n      0 === nativeEvent && 13 === keyCode && (nativeEvent = 13))\\n    : (nativeEvent = keyCode);\\n  10 === nativeEvent && (nativeEvent = 13);\\n  return 32 <= nativeEvent || 13 === nativeEvent ? nativeEvent : 0;\\n}\\nfunction functionThatReturnsTrue() {\\n  return !0;\\n}\\nfunction functionThatReturnsFalse() {\\n  return !1;\\n}\\nfunction createSyntheticEvent(Interface) {\\n  function SyntheticBaseEvent(\\n    reactName,\\n    reactEventType,\\n    targetInst,\\n    nativeEvent,\\n    nativeEventTarget\\n  ) {\\n    this._reactName = reactName;\\n    this._targetInst = targetInst;\\n    this.type = reactEventType;\\n    this.nativeEvent = nativeEvent;\\n    this.target = nativeEventTarget;\\n    this.currentTarget = null;\\n    for (var propName in Interface)\\n      Interface.hasOwnProperty(propName) &&\\n        ((reactName = Interface[propName]),\\n        (this[propName] = reactName\\n          ? reactName(nativeEvent)\\n          : nativeEvent[propName]));\\n    this.isDefaultPrevented = (\\n      null != nativeEvent.defaultPrevented\\n        ? nativeEvent.defaultPrevented\\n        : !1 === nativeEvent.returnValue\\n    )\\n      ? functionThatReturnsTrue\\n      : functionThatReturnsFalse;\\n    this.isPropagationStopped = functionThatReturnsFalse;\\n    return this;\\n  }\\n  assign(SyntheticBaseEvent.prototype, {\\n    preventDefault: function () {\\n      this.defaultPrevented = !0;\\n      var event = this.nativeEvent;\\n      event &&\\n        (event.preventDefault\\n          ? event.preventDefault()\\n          : \"unknown\" !== typeof event.returnValue && (event.returnValue = !1),\\n        (this.isDefaultPrevented = functionThatReturnsTrue));\\n    },\\n    stopPropagation: function () {\\n      var event = this.nativeEvent;\\n      event &&\\n        (event.stopPropagation\\n          ? event.stopPropagation()\\n          : \"unknown\" !== typeof event.cancelBubble &&\\n            (event.cancelBubble = !0),\\n        (this.isPropagationStopped = functionThatReturnsTrue));\\n    },\\n    persist: function () {},\\n    isPersistent: functionThatReturnsTrue\\n  });\\n  return SyntheticBaseEvent;\\n}\\nvar EventInterface = {\\n    eventPhase: 0,\\n    bubbles: 0,\\n    cancelable: 0,\\n    timeStamp: function (event) {\\n      return event.timeStamp || Date.now();\\n    },\\n    defaultPrevented: 0,\\n    isTrusted: 0\\n  },\\n  SyntheticEvent = createSyntheticEvent(EventInterface),\\n  UIEventInterface = assign({}, EventInterface, { view: 0, detail: 0 }),\\n  SyntheticUIEvent = createSyntheticEvent(UIEventInterface),\\n  lastMovementX,\\n  lastMovementY,\\n  lastMouseEvent,\\n  MouseEventInterface = assign({}, UIEventInterface, {\\n    screenX: 0,\\n    screenY: 0,\\n    clientX: 0,\\n    clientY: 0,\\n    pageX: 0,\\n    pageY: 0,\\n    ctrlKey: 0,\\n    shiftKey: 0,\\n    altKey: 0,\\n    metaKey: 0,\\n    getModifierState: getEventModifierState,\\n    button: 0,\\n    buttons: 0,\\n    relatedTarget: function (event) {\\n      return void 0 === event.relatedTarget\\n        ? event.fromElement === event.srcElement\\n          ? event.toElement\\n          : event.fromElement\\n        : event.relatedTarget;\\n    },\\n    movementX: function (event) {\\n      if (\"movementX\" in event) return event.movementX;\\n      event !== lastMouseEvent &&\\n        (lastMouseEvent && \"mousemove\" === event.type\\n          ? ((lastMovementX = event.screenX - lastMouseEvent.screenX),\\n            (lastMovementY = event.screenY - lastMouseEvent.screenY))\\n          : (lastMovementY = lastMovementX = 0),\\n        (lastMouseEvent = event));\\n      return lastMovementX;\\n    },\\n    movementY: function (event) {\\n      return \"movementY\" in event ? event.movementY : lastMovementY;\\n    }\\n  }),\\n  SyntheticMouseEvent = createSyntheticEvent(MouseEventInterface),\\n  DragEventInterface = assign({}, MouseEventInterface, { dataTransfer: 0 }),\\n  SyntheticDragEvent = createSyntheticEvent(DragEventInterface),\\n  FocusEventInterface = assign({}, UIEventInterface, { relatedTarget: 0 }),\\n  SyntheticFocusEvent = createSyntheticEvent(FocusEventInterface),\\n  AnimationEventInterface = assign({}, EventInterface, {\\n    animationName: 0,\\n    elapsedTime: 0,\\n    pseudoElement: 0\\n  }),\\n  SyntheticAnimationEvent = createSyntheticEvent(AnimationEventInterface),\\n  ClipboardEventInterface = assign({}, EventInterface, {\\n    clipboardData: function (event) {\\n      return \"clipboardData\" in event\\n        ? event.clipboardData\\n        : window.clipboardData;\\n    }\\n  }),\\n  SyntheticClipboardEvent = createSyntheticEvent(ClipboardEventInterface),\\n  CompositionEventInterface = assign({}, EventInterface, { data: 0 }),\\n  SyntheticCompositionEvent = createSyntheticEvent(CompositionEventInterface),\\n  normalizeKey = {\\n    Esc: \"Escape\",\\n    Spacebar: \" \",\\n    Left: \"ArrowLeft\",\\n    Up: \"ArrowUp\",\\n    Right: \"ArrowRight\",\\n    Down: \"ArrowDown\",\\n    Del: \"Delete\",\\n    Win: \"OS\",\\n    Menu: \"ContextMenu\",\\n    Apps: \"ContextMenu\",\\n    Scroll: \"ScrollLock\",\\n    MozPrintableKey: \"Unidentified\"\\n  },\\n  translateToKey = {\\n    8: \"Backspace\",\\n    9: \"Tab\",\\n    12: \"Clear\",\\n    13: \"Enter\",\\n    16: \"Shift\",\\n    17: \"Control\",\\n    18: \"Alt\",\\n    19: \"Pause\",\\n    20: \"CapsLock\",\\n    27: \"Escape\",\\n    32: \" \",\\n    33: \"PageUp\",\\n    34: \"PageDown\",\\n    35: \"End\",\\n    36: \"Home\",\\n    37: \"ArrowLeft\",\\n    38: \"ArrowUp\",\\n    39: \"ArrowRight\",\\n    40: \"ArrowDown\",\\n    45: \"Insert\",\\n    46: \"Delete\",\\n    112: \"F1\",\\n    113: \"F2\",\\n    114: \"F3\",\\n    115: \"F4\",\\n    116: \"F5\",\\n    117: \"F6\",\\n    118: \"F7\",\\n    119: \"F8\",\\n    120: \"F9\",\\n    121: \"F10\",\\n    122: \"F11\",\\n    123: \"F12\",\\n    144: \"NumLock\",\\n    145: \"ScrollLock\",\\n    224: \"Meta\"\\n  },\\n  modifierKeyToProp = {\\n    Alt: \"altKey\",\\n    Control: \"ctrlKey\",\\n    Meta: \"metaKey\",\\n    Shift: \"shiftKey\"\\n  };\\nfunction modifierStateGetter(keyArg) {\\n  var nativeEvent = this.nativeEvent;\\n  return nativeEvent.getModifierState\\n    ? nativeEvent.getModifierState(keyArg)\\n    : (keyArg = modifierKeyToProp[keyArg])\\n      ? !!nativeEvent[keyArg]\\n      : !1;\\n}\\nfunction getEventModifierState() {\\n  return modifierStateGetter;\\n}\\nvar KeyboardEventInterface = assign({}, UIEventInterface, {\\n    key: function (nativeEvent) {\\n      if (nativeEvent.key) {\\n        var key = normalizeKey[nativeEvent.key] || nativeEvent.key;\\n        if (\"Unidentified\" !== key) return key;\\n      }\\n      return \"keypress\" === nativeEvent.type\\n        ? ((nativeEvent = getEventCharCode(nativeEvent)),\\n          13 === nativeEvent ? \"Enter\" : String.fromCharCode(nativeEvent))\\n        : \"keydown\" === nativeEvent.type || \"keyup\" === nativeEvent.type\\n          ? translateToKey[nativeEvent.keyCode] || \"Unidentified\"\\n          : \"\";\\n    },\\n    code: 0,\\n    location: 0,\\n    ctrlKey: 0,\\n    shiftKey: 0,\\n    altKey: 0,\\n    metaKey: 0,\\n    repeat: 0,\\n    locale: 0,\\n    getModifierState: getEventModifierState,\\n    charCode: function (event) {\\n      return \"keypress\" === event.type ? getEventCharCode(event) : 0;\\n    },\\n    keyCode: function (event) {\\n      return \"keydown\" === event.type || \"keyup\" === event.type\\n        ? event.keyCode\\n        : 0;\\n    },\\n    which: function (event) {\\n      return \"keypress\" === event.type\\n        ? getEventCharCode(event)\\n        : \"keydown\" === event.type || \"keyup\" === event.type\\n          ? event.keyCode\\n          : 0;\\n    }\\n  }),\\n  SyntheticKeyboardEvent = createSyntheticEvent(KeyboardEventInterface),\\n  PointerEventInterface = assign({}, MouseEventInterface, {\\n    pointerId: 0,\\n    width: 0,\\n    height: 0,\\n    pressure: 0,\\n    tangentialPressure: 0,\\n    tiltX: 0,\\n    tiltY: 0,\\n    twist: 0,\\n    pointerType: 0,\\n    isPrimary: 0\\n  }),\\n  SyntheticPointerEvent = createSyntheticEvent(PointerEventInterface),\\n  TouchEventInterface = assign({}, UIEventInterface, {\\n    touches: 0,\\n    targetTouches: 0,\\n    changedTouches: 0,\\n    altKey: 0,\\n    metaKey: 0,\\n    ctrlKey: 0,\\n    shiftKey: 0,\\n    getModifierState: getEventModifierState\\n  }),\\n  SyntheticTouchEvent = createSyntheticEvent(TouchEventInterface),\\n  TransitionEventInterface = assign({}, EventInterface, {\\n    propertyName: 0,\\n    elapsedTime: 0,\\n    pseudoElement: 0\\n  }),\\n  SyntheticTransitionEvent = createSyntheticEvent(TransitionEventInterface),\\n  WheelEventInterface = assign({}, MouseEventInterface, {\\n    deltaX: function (event) {\\n      return \"deltaX\" in event\\n        ? event.deltaX\\n        : \"wheelDeltaX\" in event\\n          ? -event.wheelDeltaX\\n          : 0;\\n    },\\n    deltaY: function (event) {\\n      return \"deltaY\" in event\\n        ? event.deltaY\\n        : \"wheelDeltaY\" in event\\n          ? -event.wheelDeltaY\\n          : \"wheelDelta\" in event\\n            ? -event.wheelDelta\\n            : 0;\\n    },\\n    deltaZ: 0,\\n    deltaMode: 0\\n  }),\\n  SyntheticWheelEvent = createSyntheticEvent(WheelEventInterface),\\n  ToggleEventInterface = assign({}, EventInterface, {\\n    newState: 0,\\n    oldState: 0\\n  }),\\n  SyntheticToggleEvent = createSyntheticEvent(ToggleEventInterface),\\n  END_KEYCODES = [9, 13, 27, 32],\\n  canUseCompositionEvent = canUseDOM && \"CompositionEvent\" in window,\\n  documentMode = null;\\ncanUseDOM &&\\n  \"documentMode\" in document &&\\n  (documentMode = document.documentMode);\\nvar canUseTextInputEvent = canUseDOM && \"TextEvent\" in window && !documentMode,\\n  useFallbackCompositionData =\\n    canUseDOM &&\\n    (!canUseCompositionEvent ||\\n      (documentMode && 8 < documentMode && 11 >= documentMode)),\\n  SPACEBAR_CHAR = String.fromCharCode(32),\\n  hasSpaceKeypress = !1;\\nfunction isFallbackCompositionEnd(domEventName, nativeEvent) {\\n  switch (domEventName) {\\n    case \"keyup\":\\n      return -1 !== END_KEYCODES.indexOf(nativeEvent.keyCode);\\n    case \"keydown\":\\n      return 229 !== nativeEvent.keyCode;\\n    case \"keypress\":\\n    case \"mousedown\":\\n    case \"focusout\":\\n      return !0;\\n    default:\\n      return !1;\\n  }\\n}\\nfunction getDataFromCustomEvent(nativeEvent) {\\n  nativeEvent = nativeEvent.detail;\\n  return \"object\" === typeof nativeEvent && \"data\" in nativeEvent\\n    ? nativeEvent.data\\n    : null;\\n}\\nvar isComposing = !1;\\nfunction getNativeBeforeInputChars(domEventName, nativeEvent) {\\n  switch (domEventName) {\\n    case \"compositionend\":\\n      return getDataFromCustomEvent(nativeEvent);\\n    case \"keypress\":\\n      if (32 !== nativeEvent.which) return null;\\n      hasSpaceKeypress = !0;\\n      return SPACEBAR_CHAR;\\n    case \"textInput\":\\n      return (\\n        (domEventName = nativeEvent.data),\\n        domEventName === SPACEBAR_CHAR && hasSpaceKeypress ? null : domEventName\\n      );\\n    default:\\n      return null;\\n  }\\n}\\nfunction getFallbackBeforeInputChars(domEventName, nativeEvent) {\\n  if (isComposing)\\n    return \"compositionend\" === domEventName ||\\n      (!canUseCompositionEvent &&\\n        isFallbackCompositionEnd(domEventName, nativeEvent))\\n      ? ((domEventName = getData()),\\n        (fallbackText = startText = root = null),\\n        (isComposing = !1),\\n        domEventName)\\n      : null;\\n  switch (domEventName) {\\n    case \"paste\":\\n      return null;\\n    case \"keypress\":\\n      if (\\n        !(nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) ||\\n        (nativeEvent.ctrlKey && nativeEvent.altKey)\\n      ) {\\n        if (nativeEvent.char && 1 < nativeEvent.char.length)\\n          return nativeEvent.char;\\n        if (nativeEvent.which) return String.fromCharCode(nativeEvent.which);\\n      }\\n      return null;\\n    case \"compositionend\":\\n      return useFallbackCompositionData && \"ko\" !== nativeEvent.locale\\n        ? null\\n        : nativeEvent.data;\\n    default:\\n      return null;\\n  }\\n}\\nvar supportedInputTypes = {\\n  color: !0,\\n  date: !0,\\n  datetime: !0,\\n  \"datetime-local\": !0,\\n  email: !0,\\n  month: !0,\\n  number: !0,\\n  password: !0,\\n  range: !0,\\n  search: !0,\\n  tel: !0,\\n  text: !0,\\n  time: !0,\\n  url: !0,\\n  week: !0\\n};\\nfunction isTextInputElement(elem) {\\n  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();\\n  return \"input\" === nodeName\\n    ? !!supportedInputTypes[elem.type]\\n    : \"textarea\" === nodeName\\n      ? !0\\n      : !1;\\n}\\nfunction createAndAccumulateChangeEvent(\\n  dispatchQueue,\\n  inst,\\n  nativeEvent,\\n  target\\n) {\\n  restoreTarget\\n    ? restoreQueue\\n      ? restoreQueue.push(target)\\n      : (restoreQueue = [target])\\n    : (restoreTarget = target);\\n  inst = accumulateTwoPhaseListeners(inst, \"onChange\");\\n  0 < inst.length &&\\n    ((nativeEvent = new SyntheticEvent(\\n      \"onChange\",\\n      \"change\",\\n      null,\\n      nativeEvent,\\n      target\\n    )),\\n    dispatchQueue.push({ event: nativeEvent, listeners: inst }));\\n}\\nvar activeElement$1 = null,\\n  activeElementInst$1 = null;\\nfunction runEventInBatch(dispatchQueue) {\\n  processDispatchQueue(dispatchQueue, 0);\\n}\\nfunction getInstIfValueChanged(targetInst) {\\n  var targetNode = getNodeFromInstance(targetInst);\\n  if (updateValueIfChanged(targetNode)) return targetInst;\\n}\\nfunction getTargetInstForChangeEvent(domEventName, targetInst) {\\n  if (\"change\" === domEventName) return targetInst;\\n}\\nvar isInputEventSupported = !1;\\nif (canUseDOM) {\\n  var JSCompiler_inline_result$jscomp$282;\\n  if (canUseDOM) {\\n    var isSupported$jscomp$inline_417 = \"oninput\" in document;\\n    if (!isSupported$jscomp$inline_417) {\\n      var element$jscomp$inline_418 = document.createElement(\"div\");\\n      element$jscomp$inline_418.setAttribute(\"oninput\", \"return;\");\\n      isSupported$jscomp$inline_417 =\\n        \"function\" === typeof element$jscomp$inline_418.oninput;\\n    }\\n    JSCompiler_inline_result$jscomp$282 = isSupported$jscomp$inline_417;\\n  } else JSCompiler_inline_result$jscomp$282 = !1;\\n  isInputEventSupported =\\n    JSCompiler_inline_result$jscomp$282 &&\\n    (!document.documentMode || 9 < document.documentMode);\\n}\\nfunction stopWatchingForValueChange() {\\n  activeElement$1 &&\\n    (activeElement$1.detachEvent(\"onpropertychange\", handlePropertyChange),\\n    (activeElementInst$1 = activeElement$1 = null));\\n}\\nfunction handlePropertyChange(nativeEvent) {\\n  if (\\n    \"value\" === nativeEvent.propertyName &&\\n    getInstIfValueChanged(activeElementInst$1)\\n  ) {\\n    var dispatchQueue = [];\\n    createAndAccumulateChangeEvent(\\n      dispatchQueue,\\n      activeElementInst$1,\\n      nativeEvent,\\n      getEventTarget(nativeEvent)\\n    );\\n    batchedUpdates$1(runEventInBatch, dispatchQueue);\\n  }\\n}\\nfunction handleEventsForInputEventPolyfill(domEventName, target, targetInst) {\\n  \"focusin\" === domEventName\\n    ? (stopWatchingForValueChange(),\\n      (activeElement$1 = target),\\n      (activeElementInst$1 = targetInst),\\n      activeElement$1.attachEvent(\"onpropertychange\", handlePropertyChange))\\n    : \"focusout\" === domEventName && stopWatchingForValueChange();\\n}\\nfunction getTargetInstForInputEventPolyfill(domEventName) {\\n  if (\\n    \"selectionchange\" === domEventName ||\\n    \"keyup\" === domEventName ||\\n    \"keydown\" === domEventName\\n  )\\n    return getInstIfValueChanged(activeElementInst$1);\\n}\\nfunction getTargetInstForClickEvent(domEventName, targetInst) {\\n  if (\"click\" === domEventName) return getInstIfValueChanged(targetInst);\\n}\\nfunction getTargetInstForInputOrChangeEvent(domEventName, targetInst) {\\n  if (\"input\" === domEventName || \"change\" === domEventName)\\n    return getInstIfValueChanged(targetInst);\\n}\\nfunction is(x, y) {\\n  return (x === y && (0 !== x || 1 / x === 1 / y)) || (x !== x && y !== y);\\n}\\nvar objectIs = \"function\" === typeof Object.is ? Object.is : is;\\nfunction shallowEqual(objA, objB) {\\n  if (objectIs(objA, objB)) return !0;\\n  if (\\n    \"object\" !== typeof objA ||\\n    null === objA ||\\n    \"object\" !== typeof objB ||\\n    null === objB\\n  )\\n    return !1;\\n  var keysA = Object.keys(objA),\\n    keysB = Object.keys(objB);\\n  if (keysA.length !== keysB.length) return !1;\\n  for (keysB = 0; keysB < keysA.length; keysB++) {\\n    var currentKey = keysA[keysB];\\n    if (\\n      !hasOwnProperty.call(objB, currentKey) ||\\n      !objectIs(objA[currentKey], objB[currentKey])\\n    )\\n      return !1;\\n  }\\n  return !0;\\n}\\nfunction getLeafNode(node) {\\n  for (; node && node.firstChild; ) node = node.firstChild;\\n  return node;\\n}\\nfunction getNodeForCharacterOffset(root, offset) {\\n  var node = getLeafNode(root);\\n  root = 0;\\n  for (var nodeEnd; node; ) {\\n    if (3 === node.nodeType) {\\n      nodeEnd = root + node.textContent.length;\\n      if (root <= offset && nodeEnd >= offset)\\n        return { node: node, offset: offset - root };\\n      root = nodeEnd;\\n    }\\n    a: {\\n      for (; node; ) {\\n        if (node.nextSibling) {\\n          node = node.nextSibling;\\n          break a;\\n        }\\n        node = node.parentNode;\\n      }\\n      node = void 0;\\n    }\\n    node = getLeafNode(node);\\n  }\\n}\\nfunction containsNode(outerNode, innerNode) {\\n  return outerNode && innerNode\\n    ? outerNode === innerNode\\n      ? !0\\n      : outerNode && 3 === outerNode.nodeType\\n        ? !1\\n        : innerNode && 3 === innerNode.nodeType\\n          ? containsNode(outerNode, innerNode.parentNode)\\n          : \"contains\" in outerNode\\n            ? outerNode.contains(innerNode)\\n            : outerNode.compareDocumentPosition\\n              ? !!(outerNode.compareDocumentPosition(innerNode) & 16)\\n              : !1\\n    : !1;\\n}\\nfunction getActiveElementDeep(containerInfo) {\\n  containerInfo =\\n    null != containerInfo &&\\n    null != containerInfo.ownerDocument &&\\n    null != containerInfo.ownerDocument.defaultView\\n      ? containerInfo.ownerDocument.defaultView\\n      : window;\\n  for (\\n    var element = getActiveElement(containerInfo.document);\\n    element instanceof containerInfo.HTMLIFrameElement;\\n\\n  ) {\\n    try {\\n      var JSCompiler_inline_result =\\n        \"string\" === typeof element.contentWindow.location.href;\\n    } catch (err) {\\n      JSCompiler_inline_result = !1;\\n    }\\n    if (JSCompiler_inline_result) containerInfo = element.contentWindow;\\n    else break;\\n    element = getActiveElement(containerInfo.document);\\n  }\\n  return element;\\n}\\nfunction hasSelectionCapabilities(elem) {\\n  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();\\n  return (\\n    nodeName &&\\n    ((\"input\" === nodeName &&\\n      (\"text\" === elem.type ||\\n        \"search\" === elem.type ||\\n        \"tel\" === elem.type ||\\n        \"url\" === elem.type ||\\n        \"password\" === elem.type)) ||\\n      \"textarea\" === nodeName ||\\n      \"true\" === elem.contentEditable)\\n  );\\n}\\nvar skipSelectionChangeEvent =\\n    canUseDOM && \"documentMode\" in document && 11 >= document.documentMode,\\n  activeElement = null,\\n  activeElementInst = null,\\n  lastSelection = null,\\n  mouseDown = !1;\\nfunction constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget) {\\n  var doc =\\n    nativeEventTarget.window === nativeEventTarget\\n      ? nativeEventTarget.document\\n      : 9 === nativeEventTarget.nodeType\\n        ? nativeEventTarget\\n        : nativeEventTarget.ownerDocument;\\n  mouseDown ||\\n    null == activeElement ||\\n    activeElement !== getActiveElement(doc) ||\\n    ((doc = activeElement),\\n    \"selectionStart\" in doc && hasSelectionCapabilities(doc)\\n      ? (doc = { start: doc.selectionStart, end: doc.selectionEnd })\\n      : ((doc = (\\n          (doc.ownerDocument && doc.ownerDocument.defaultView) ||\\n          window\\n        ).getSelection()),\\n        (doc = {\\n          anchorNode: doc.anchorNode,\\n          anchorOffset: doc.anchorOffset,\\n          focusNode: doc.focusNode,\\n          focusOffset: doc.focusOffset\\n        })),\\n    (lastSelection && shallowEqual(lastSelection, doc)) ||\\n      ((lastSelection = doc),\\n      (doc = accumulateTwoPhaseListeners(activeElementInst, \"onSelect\")),\\n      0 < doc.length &&\\n        ((nativeEvent = new SyntheticEvent(\\n          \"onSelect\",\\n          \"select\",\\n          null,\\n          nativeEvent,\\n          nativeEventTarget\\n        )),\\n        dispatchQueue.push({ event: nativeEvent, listeners: doc }),\\n        (nativeEvent.target = activeElement))));\\n}\\nfunction makePrefixMap(styleProp, eventName) {\\n  var prefixes = {};\\n  prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();\\n  prefixes[\"Webkit\" + styleProp] = \"webkit\" + eventName;\\n  prefixes[\"Moz\" + styleProp] = \"moz\" + eventName;\\n  return prefixes;\\n}\\nvar vendorPrefixes = {\\n    animationend: makePrefixMap(\"Animation\", \"AnimationEnd\"),\\n    animationiteration: makePrefixMap(\"Animation\", \"AnimationIteration\"),\\n    animationstart: makePrefixMap(\"Animation\", \"AnimationStart\"),\\n    transitionrun: makePrefixMap(\"Transition\", \"TransitionRun\"),\\n    transitionstart: makePrefixMap(\"Transition\", \"TransitionStart\"),\\n    transitioncancel: makePrefixMap(\"Transition\", \"TransitionCancel\"),\\n    transitionend: makePrefixMap(\"Transition\", \"TransitionEnd\")\\n  },\\n  prefixedEventNames = {},\\n  style = {};\\ncanUseDOM &&\\n  ((style = document.createElement(\"div\").style),\\n  \"AnimationEvent\" in window ||\\n    (delete vendorPrefixes.animationend.animation,\\n    delete vendorPrefixes.animationiteration.animation,\\n    delete vendorPrefixes.animationstart.animation),\\n  \"TransitionEvent\" in window ||\\n    delete vendorPrefixes.transitionend.transition);\\nfunction getVendorPrefixedEventName(eventName) {\\n  if (prefixedEventNames[eventName]) return prefixedEventNames[eventName];\\n  if (!vendorPrefixes[eventName]) return eventName;\\n  var prefixMap = vendorPrefixes[eventName],\\n    styleProp;\\n  for (styleProp in prefixMap)\\n    if (prefixMap.hasOwnProperty(styleProp) && styleProp in style)\\n      return (prefixedEventNames[eventName] = prefixMap[styleProp]);\\n  return eventName;\\n}\\nvar ANIMATION_END = getVendorPrefixedEventName(\"animationend\"),\\n  ANIMATION_ITERATION = getVendorPrefixedEventName(\"animationiteration\"),\\n  ANIMATION_START = getVendorPrefixedEventName(\"animationstart\"),\\n  TRANSITION_RUN = getVendorPrefixedEventName(\"transitionrun\"),\\n  TRANSITION_START = getVendorPrefixedEventName(\"transitionstart\"),\\n  TRANSITION_CANCEL = getVendorPrefixedEventName(\"transitioncancel\"),\\n  TRANSITION_END = getVendorPrefixedEventName(\"transitionend\"),\\n  topLevelEventsToReactNames = new Map(),\\n  simpleEventPluginEvents =\\n    \"abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel\".split(\\n      \" \"\\n    );\\nsimpleEventPluginEvents.push(\"scrollEnd\");\\nfunction registerSimpleEvent(domEventName, reactName) {\\n  topLevelEventsToReactNames.set(domEventName, reactName);\\n  registerTwoPhaseEvent(reactName, [domEventName]);\\n}\\nvar CapturedStacks = new WeakMap();\\nfunction createCapturedValueAtFiber(value, source) {\\n  if (\"object\" === typeof value && null !== value) {\\n    var existing = CapturedStacks.get(value);\\n    if (void 0 !== existing) return existing;\\n    source = {\\n      value: value,\\n      source: source,\\n      stack: getStackByFiberInDevAndProd(source)\\n    };\\n    CapturedStacks.set(value, source);\\n    return source;\\n  }\\n  return {\\n    value: value,\\n    source: source,\\n    stack: getStackByFiberInDevAndProd(source)\\n  };\\n}\\nvar concurrentQueues = [],\\n  concurrentQueuesIndex = 0,\\n  concurrentlyUpdatedLanes = 0;\\nfunction finishQueueingConcurrentUpdates() {\\n  for (\\n    var endIndex = concurrentQueuesIndex,\\n      i = (concurrentlyUpdatedLanes = concurrentQueuesIndex = 0);\\n    i < endIndex;\\n\\n  ) {\\n    var fiber = concurrentQueues[i];\\n    concurrentQueues[i++] = null;\\n    var queue = concurrentQueues[i];\\n    concurrentQueues[i++] = null;\\n    var update = concurrentQueues[i];\\n    concurrentQueues[i++] = null;\\n    var lane = concurrentQueues[i];\\n    concurrentQueues[i++] = null;\\n    if (null !== queue && null !== update) {\\n      var pending = queue.pending;\\n      null === pending\\n        ? (update.next = update)\\n        : ((update.next = pending.next), (pending.next = update));\\n      queue.pending = update;\\n    }\\n    0 !== lane && markUpdateLaneFromFiberToRoot(fiber, update, lane);\\n  }\\n}\\nfunction enqueueUpdate$1(fiber, queue, update, lane) {\\n  concurrentQueues[concurrentQueuesIndex++] = fiber;\\n  concurrentQueues[concurrentQueuesIndex++] = queue;\\n  concurrentQueues[concurrentQueuesIndex++] = update;\\n  concurrentQueues[concurrentQueuesIndex++] = lane;\\n  concurrentlyUpdatedLanes |= lane;\\n  fiber.lanes |= lane;\\n  fiber = fiber.alternate;\\n  null !== fiber && (fiber.lanes |= lane);\\n}\\nfunction enqueueConcurrentHookUpdate(fiber, queue, update, lane) {\\n  enqueueUpdate$1(fiber, queue, update, lane);\\n  return getRootForUpdatedFiber(fiber);\\n}\\nfunction enqueueConcurrentRenderForLane(fiber, lane) {\\n  enqueueUpdate$1(fiber, null, null, lane);\\n  return getRootForUpdatedFiber(fiber);\\n}\\nfunction markUpdateLaneFromFiberToRoot(sourceFiber, update, lane) {\\n  sourceFiber.lanes |= lane;\\n  var alternate = sourceFiber.alternate;\\n  null !== alternate && (alternate.lanes |= lane);\\n  for (var isHidden = !1, parent = sourceFiber.return; null !== parent; )\\n    (parent.childLanes |= lane),\\n      (alternate = parent.alternate),\\n      null !== alternate && (alternate.childLanes |= lane),\\n      22 === parent.tag &&\\n        ((sourceFiber = parent.stateNode),\\n        null === sourceFiber || sourceFiber._visibility & 1 || (isHidden = !0)),\\n      (sourceFiber = parent),\\n      (parent = parent.return);\\n  return 3 === sourceFiber.tag\\n    ? ((parent = sourceFiber.stateNode),\\n      isHidden &&\\n        null !== update &&\\n        ((isHidden = 31 - clz32(lane)),\\n        (sourceFiber = parent.hiddenUpdates),\\n        (alternate = sourceFiber[isHidden]),\\n        null === alternate\\n          ? (sourceFiber[isHidden] = [update])\\n          : alternate.push(update),\\n        (update.lane = lane | 536870912)),\\n      parent)\\n    : null;\\n}\\nfunction getRootForUpdatedFiber(sourceFiber) {\\n  if (50 < nestedUpdateCount)\\n    throw (\\n      ((nestedUpdateCount = 0),\\n      (rootWithNestedUpdates = null),\\n      Error(formatProdErrorMessage(185)))\\n    );\\n  for (var parent = sourceFiber.return; null !== parent; )\\n    (sourceFiber = parent), (parent = sourceFiber.return);\\n  return 3 === sourceFiber.tag ? sourceFiber.stateNode : null;\\n}\\nvar emptyContextObject = {};\\nfunction FiberNode(tag, pendingProps, key, mode) {\\n  this.tag = tag;\\n  this.key = key;\\n  this.sibling =\\n    this.child =\\n    this.return =\\n    this.stateNode =\\n    this.type =\\n    this.elementType =\\n      null;\\n  this.index = 0;\\n  this.refCleanup = this.ref = null;\\n  this.pendingProps = pendingProps;\\n  this.dependencies =\\n    this.memoizedState =\\n    this.updateQueue =\\n    this.memoizedProps =\\n      null;\\n  this.mode = mode;\\n  this.subtreeFlags = this.flags = 0;\\n  this.deletions = null;\\n  this.childLanes = this.lanes = 0;\\n  this.alternate = null;\\n}\\nfunction createFiberImplClass(tag, pendingProps, key, mode) {\\n  return new FiberNode(tag, pendingProps, key, mode);\\n}\\nfunction shouldConstruct(Component) {\\n  Component = Component.prototype;\\n  return !(!Component || !Component.isReactComponent);\\n}\\nfunction createWorkInProgress(current, pendingProps) {\\n  var workInProgress = current.alternate;\\n  null === workInProgress\\n    ? ((workInProgress = createFiberImplClass(\\n        current.tag,\\n        pendingProps,\\n        current.key,\\n        current.mode\\n      )),\\n      (workInProgress.elementType = current.elementType),\\n      (workInProgress.type = current.type),\\n      (workInProgress.stateNode = current.stateNode),\\n      (workInProgress.alternate = current),\\n      (current.alternate = workInProgress))\\n    : ((workInProgress.pendingProps = pendingProps),\\n      (workInProgress.type = current.type),\\n      (workInProgress.flags = 0),\\n      (workInProgress.subtreeFlags = 0),\\n      (workInProgress.deletions = null));\\n  workInProgress.flags = current.flags & 65011712;\\n  workInProgress.childLanes = current.childLanes;\\n  workInProgress.lanes = current.lanes;\\n  workInProgress.child = current.child;\\n  workInProgress.memoizedProps = current.memoizedProps;\\n  workInProgress.memoizedState = current.memoizedState;\\n  workInProgress.updateQueue = current.updateQueue;\\n  pendingProps = current.dependencies;\\n  workInProgress.dependencies =\\n    null === pendingProps\\n      ? null\\n      : { lanes: pendingProps.lanes, firstContext: pendingProps.firstContext };\\n  workInProgress.sibling = current.sibling;\\n  workInProgress.index = current.index;\\n  workInProgress.ref = current.ref;\\n  workInProgress.refCleanup = current.refCleanup;\\n  return workInProgress;\\n}\\nfunction resetWorkInProgress(workInProgress, renderLanes) {\\n  workInProgress.flags &= 65011714;\\n  var current = workInProgress.alternate;\\n  null === current\\n    ? ((workInProgress.childLanes = 0),\\n      (workInProgress.lanes = renderLanes),\\n      (workInProgress.child = null),\\n      (workInProgress.subtreeFlags = 0),\\n      (workInProgress.memoizedProps = null),\\n      (workInProgress.memoizedState = null),\\n      (workInProgress.updateQueue = null),\\n      (workInProgress.dependencies = null),\\n      (workInProgress.stateNode = null))\\n    : ((workInProgress.childLanes = current.childLanes),\\n      (workInProgress.lanes = current.lanes),\\n      (workInProgress.child = current.child),\\n      (workInProgress.subtreeFlags = 0),\\n      (workInProgress.deletions = null),\\n      (workInProgress.memoizedProps = current.memoizedProps),\\n      (workInProgress.memoizedState = current.memoizedState),\\n      (workInProgress.updateQueue = current.updateQueue),\\n      (workInProgress.type = current.type),\\n      (renderLanes = current.dependencies),\\n      (workInProgress.dependencies =\\n        null === renderLanes\\n          ? null\\n          : {\\n              lanes: renderLanes.lanes,\\n              firstContext: renderLanes.firstContext\\n            }));\\n  return workInProgress;\\n}\\nfunction createFiberFromTypeAndProps(\\n  type,\\n  key,\\n  pendingProps,\\n  owner,\\n  mode,\\n  lanes\\n) {\\n  var fiberTag = 0;\\n  owner = type;\\n  if (\"function\" === typeof type) shouldConstruct(type) && (fiberTag = 1);\\n  else if (\"string\" === typeof type)\\n    fiberTag = isHostHoistableType(\\n      type,\\n      pendingProps,\\n      contextStackCursor.current\\n    )\\n      ? 26\\n      : \"html\" === type || \"head\" === type || \"body\" === type\\n        ? 27\\n        : 5;\\n  else\\n    a: switch (type) {\\n      case REACT_ACTIVITY_TYPE:\\n        return (\\n          (type = createFiberImplClass(31, pendingProps, key, mode)),\\n          (type.elementType = REACT_ACTIVITY_TYPE),\\n          (type.lanes = lanes),\\n          type\\n        );\\n      case REACT_FRAGMENT_TYPE:\\n        return createFiberFromFragment(pendingProps.children, mode, lanes, key);\\n      case REACT_STRICT_MODE_TYPE:\\n        fiberTag = 8;\\n        mode |= 24;\\n        break;\\n      case REACT_PROFILER_TYPE:\\n        return (\\n          (type = createFiberImplClass(12, pendingProps, key, mode | 2)),\\n          (type.elementType = REACT_PROFILER_TYPE),\\n          (type.lanes = lanes),\\n          type\\n        );\\n      case REACT_SUSPENSE_TYPE:\\n        return (\\n          (type = createFiberImplClass(13, pendingProps, key, mode)),\\n          (type.elementType = REACT_SUSPENSE_TYPE),\\n          (type.lanes = lanes),\\n          type\\n        );\\n      case REACT_SUSPENSE_LIST_TYPE:\\n        return (\\n          (type = createFiberImplClass(19, pendingProps, key, mode)),\\n          (type.elementType = REACT_SUSPENSE_LIST_TYPE),\\n          (type.lanes = lanes),\\n          type\\n        );\\n      default:\\n        if (\"object\" === typeof type && null !== type)\\n          switch (type.$$typeof) {\\n            case REACT_PROVIDER_TYPE:\\n            case REACT_CONTEXT_TYPE:\\n              fiberTag = 10;\\n              break a;\\n            case REACT_CONSUMER_TYPE:\\n              fiberTag = 9;\\n              break a;\\n            case REACT_FORWARD_REF_TYPE:\\n              fiberTag = 11;\\n              break a;\\n            case REACT_MEMO_TYPE:\\n              fiberTag = 14;\\n              break a;\\n            case REACT_LAZY_TYPE:\\n              fiberTag = 16;\\n              owner = null;\\n              break a;\\n          }\\n        fiberTag = 29;\\n        pendingProps = Error(\\n          formatProdErrorMessage(130, null === type ? \"null\" : typeof type, \"\")\\n        );\\n        owner = null;\\n    }\\n  key = createFiberImplClass(fiberTag, pendingProps, key, mode);\\n  key.elementType = type;\\n  key.type = owner;\\n  key.lanes = lanes;\\n  return key;\\n}\\nfunction createFiberFromFragment(elements, mode, lanes, key) {\\n  elements = createFiberImplClass(7, elements, key, mode);\\n  elements.lanes = lanes;\\n  return elements;\\n}\\nfunction createFiberFromText(content, mode, lanes) {\\n  content = createFiberImplClass(6, content, null, mode);\\n  content.lanes = lanes;\\n  return content;\\n}\\nfunction createFiberFromPortal(portal, mode, lanes) {\\n  mode = createFiberImplClass(\\n    4,\\n    null !== portal.children ? portal.children : [],\\n    portal.key,\\n    mode\\n  );\\n  mode.lanes = lanes;\\n  mode.stateNode = {\\n    containerInfo: portal.containerInfo,\\n    pendingChildren: null,\\n    implementation: portal.implementation\\n  };\\n  return mode;\\n}\\nvar forkStack = [],\\n  forkStackIndex = 0,\\n  treeForkProvider = null,\\n  treeForkCount = 0,\\n  idStack = [],\\n  idStackIndex = 0,\\n  treeContextProvider = null,\\n  treeContextId = 1,\\n  treeContextOverflow = \"\";\\nfunction pushTreeFork(workInProgress, totalChildren) {\\n  forkStack[forkStackIndex++] = treeForkCount;\\n  forkStack[forkStackIndex++] = treeForkProvider;\\n  treeForkProvider = workInProgress;\\n  treeForkCount = totalChildren;\\n}\\nfunction pushTreeId(workInProgress, totalChildren, index) {\\n  idStack[idStackIndex++] = treeContextId;\\n  idStack[idStackIndex++] = treeContextOverflow;\\n  idStack[idStackIndex++] = treeContextProvider;\\n  treeContextProvider = workInProgress;\\n  var baseIdWithLeadingBit = treeContextId;\\n  workInProgress = treeContextOverflow;\\n  var baseLength = 32 - clz32(baseIdWithLeadingBit) - 1;\\n  baseIdWithLeadingBit &= ~(1 << baseLength);\\n  index += 1;\\n  var length = 32 - clz32(totalChildren) + baseLength;\\n  if (30 < length) {\\n    var numberOfOverflowBits = baseLength - (baseLength % 5);\\n    length = (\\n      baseIdWithLeadingBit &\\n      ((1 << numberOfOverflowBits) - 1)\\n    ).toString(32);\\n    baseIdWithLeadingBit >>= numberOfOverflowBits;\\n    baseLength -= numberOfOverflowBits;\\n    treeContextId =\\n      (1 << (32 - clz32(totalChildren) + baseLength)) |\\n      (index << baseLength) |\\n      baseIdWithLeadingBit;\\n    treeContextOverflow = length + workInProgress;\\n  } else\\n    (treeContextId =\\n      (1 << length) | (index << baseLength) | baseIdWithLeadingBit),\\n      (treeContextOverflow = workInProgress);\\n}\\nfunction pushMaterializedTreeId(workInProgress) {\\n  null !== workInProgress.return &&\\n    (pushTreeFork(workInProgress, 1), pushTreeId(workInProgress, 1, 0));\\n}\\nfunction popTreeContext(workInProgress) {\\n  for (; workInProgress === treeForkProvider; )\\n    (treeForkProvider = forkStack[--forkStackIndex]),\\n      (forkStack[forkStackIndex] = null),\\n      (treeForkCount = forkStack[--forkStackIndex]),\\n      (forkStack[forkStackIndex] = null);\\n  for (; workInProgress === treeContextProvider; )\\n    (treeContextProvider = idStack[--idStackIndex]),\\n      (idStack[idStackIndex] = null),\\n      (treeContextOverflow = idStack[--idStackIndex]),\\n      (idStack[idStackIndex] = null),\\n      (treeContextId = idStack[--idStackIndex]),\\n      (idStack[idStackIndex] = null);\\n}\\nvar hydrationParentFiber = null,\\n  nextHydratableInstance = null,\\n  isHydrating = !1,\\n  hydrationErrors = null,\\n  rootOrSingletonContext = !1,\\n  HydrationMismatchException = Error(formatProdErrorMessage(519));\\nfunction throwOnHydrationMismatch(fiber) {\\n  var error = Error(formatProdErrorMessage(418, \"\"));\\n  queueHydrationError(createCapturedValueAtFiber(error, fiber));\\n  throw HydrationMismatchException;\\n}\\nfunction prepareToHydrateHostInstance(fiber) {\\n  var instance = fiber.stateNode,\\n    type = fiber.type,\\n    props = fiber.memoizedProps;\\n  instance[internalInstanceKey] = fiber;\\n  instance[internalPropsKey] = props;\\n  switch (type) {\\n    case \"dialog\":\\n      listenToNonDelegatedEvent(\"cancel\", instance);\\n      listenToNonDelegatedEvent(\"close\", instance);\\n      break;\\n    case \"iframe\":\\n    case \"object\":\\n    case \"embed\":\\n      listenToNonDelegatedEvent(\"load\", instance);\\n      break;\\n    case \"video\":\\n    case \"audio\":\\n      for (type = 0; type < mediaEventTypes.length; type++)\\n        listenToNonDelegatedEvent(mediaEventTypes[type], instance);\\n      break;\\n    case \"source\":\\n      listenToNonDelegatedEvent(\"error\", instance);\\n      break;\\n    case \"img\":\\n    case \"image\":\\n    case \"link\":\\n      listenToNonDelegatedEvent(\"error\", instance);\\n      listenToNonDelegatedEvent(\"load\", instance);\\n      break;\\n    case \"details\":\\n      listenToNonDelegatedEvent(\"toggle\", instance);\\n      break;\\n    case \"input\":\\n      listenToNonDelegatedEvent(\"invalid\", instance);\\n      initInput(\\n        instance,\\n        props.value,\\n        props.defaultValue,\\n        props.checked,\\n        props.defaultChecked,\\n        props.type,\\n        props.name,\\n        !0\\n      );\\n      track(instance);\\n      break;\\n    case \"select\":\\n      listenToNonDelegatedEvent(\"invalid\", instance);\\n      break;\\n    case \"textarea\":\\n      listenToNonDelegatedEvent(\"invalid\", instance),\\n        initTextarea(instance, props.value, props.defaultValue, props.children),\\n        track(instance);\\n  }\\n  type = props.children;\\n  (\"string\" !== typeof type &&\\n    \"number\" !== typeof type &&\\n    \"bigint\" !== typeof type) ||\\n  instance.textContent === \"\" + type ||\\n  !0 === props.suppressHydrationWarning ||\\n  checkForUnmatchedText(instance.textContent, type)\\n    ? (null != props.popover &&\\n        (listenToNonDelegatedEvent(\"beforetoggle\", instance),\\n        listenToNonDelegatedEvent(\"toggle\", instance)),\\n      null != props.onScroll && listenToNonDelegatedEvent(\"scroll\", instance),\\n      null != props.onScrollEnd &&\\n        listenToNonDelegatedEvent(\"scrollend\", instance),\\n      null != props.onClick && (instance.onclick = noop$1),\\n      (instance = !0))\\n    : (instance = !1);\\n  instance || throwOnHydrationMismatch(fiber);\\n}\\nfunction popToNextHostParent(fiber) {\\n  for (hydrationParentFiber = fiber.return; hydrationParentFiber; )\\n    switch (hydrationParentFiber.tag) {\\n      case 5:\\n      case 13:\\n        rootOrSingletonContext = !1;\\n        return;\\n      case 27:\\n      case 3:\\n        rootOrSingletonContext = !0;\\n        return;\\n      default:\\n        hydrationParentFiber = hydrationParentFiber.return;\\n    }\\n}\\nfunction popHydrationState(fiber) {\\n  if (fiber !== hydrationParentFiber) return !1;\\n  if (!isHydrating) return popToNextHostParent(fiber), (isHydrating = !0), !1;\\n  var tag = fiber.tag,\\n    JSCompiler_temp;\\n  if ((JSCompiler_temp = 3 !== tag && 27 !== tag)) {\\n    if ((JSCompiler_temp = 5 === tag))\\n      (JSCompiler_temp = fiber.type),\\n        (JSCompiler_temp =\\n          !(\"form\" !== JSCompiler_temp && \"button\" !== JSCompiler_temp) ||\\n          shouldSetTextContent(fiber.type, fiber.memoizedProps));\\n    JSCompiler_temp = !JSCompiler_temp;\\n  }\\n  JSCompiler_temp && nextHydratableInstance && throwOnHydrationMismatch(fiber);\\n  popToNextHostParent(fiber);\\n  if (13 === tag) {\\n    fiber = fiber.memoizedState;\\n    fiber = null !== fiber ? fiber.dehydrated : null;\\n    if (!fiber) throw Error(formatProdErrorMessage(317));\\n    a: {\\n      fiber = fiber.nextSibling;\\n      for (tag = 0; fiber; ) {\\n        if (8 === fiber.nodeType)\\n          if (((JSCompiler_temp = fiber.data), \"/$\" === JSCompiler_temp)) {\\n            if (0 === tag) {\\n              nextHydratableInstance = getNextHydratable(fiber.nextSibling);\\n              break a;\\n            }\\n            tag--;\\n          } else\\n            (\"$\" !== JSCompiler_temp &&\\n              \"$!\" !== JSCompiler_temp &&\\n              \"$?\" !== JSCompiler_temp) ||\\n              tag++;\\n        fiber = fiber.nextSibling;\\n      }\\n      nextHydratableInstance = null;\\n    }\\n  } else\\n    27 === tag\\n      ? ((tag = nextHydratableInstance),\\n        isSingletonScope(fiber.type)\\n          ? ((fiber = previousHydratableOnEnteringScopedSingleton),\\n            (previousHydratableOnEnteringScopedSingleton = null),\\n            (nextHydratableInstance = fiber))\\n          : (nextHydratableInstance = tag))\\n      : (nextHydratableInstance = hydrationParentFiber\\n          ? getNextHydratable(fiber.stateNode.nextSibling)\\n          : null);\\n  return !0;\\n}\\nfunction resetHydrationState() {\\n  nextHydratableInstance = hydrationParentFiber = null;\\n  isHydrating = !1;\\n}\\nfunction upgradeHydrationErrorsToRecoverable() {\\n  var queuedErrors = hydrationErrors;\\n  null !== queuedErrors &&\\n    (null === workInProgressRootRecoverableErrors\\n      ? (workInProgressRootRecoverableErrors = queuedErrors)\\n      : workInProgressRootRecoverableErrors.push.apply(\\n          workInProgressRootRecoverableErrors,\\n          queuedErrors\\n        ),\\n    (hydrationErrors = null));\\n  return queuedErrors;\\n}\\nfunction queueHydrationError(error) {\\n  null === hydrationErrors\\n    ? (hydrationErrors = [error])\\n    : hydrationErrors.push(error);\\n}\\nvar valueCursor = createCursor(null),\\n  currentlyRenderingFiber$1 = null,\\n  lastContextDependency = null;\\nfunction pushProvider(providerFiber, context, nextValue) {\\n  push(valueCursor, context._currentValue);\\n  context._currentValue = nextValue;\\n}\\nfunction popProvider(context) {\\n  context._currentValue = valueCursor.current;\\n  pop(valueCursor);\\n}\\nfunction scheduleContextWorkOnParentPath(parent, renderLanes, propagationRoot) {\\n  for (; null !== parent; ) {\\n    var alternate = parent.alternate;\\n    (parent.childLanes & renderLanes) !== renderLanes\\n      ? ((parent.childLanes |= renderLanes),\\n        null !== alternate && (alternate.childLanes |= renderLanes))\\n      : null !== alternate &&\\n        (alternate.childLanes & renderLanes) !== renderLanes &&\\n        (alternate.childLanes |= renderLanes);\\n    if (parent === propagationRoot) break;\\n    parent = parent.return;\\n  }\\n}\\nfunction propagateContextChanges(\\n  workInProgress,\\n  contexts,\\n  renderLanes,\\n  forcePropagateEntireTree\\n) {\\n  var fiber = workInProgress.child;\\n  null !== fiber && (fiber.return = workInProgress);\\n  for (; null !== fiber; ) {\\n    var list = fiber.dependencies;\\n    if (null !== list) {\\n      var nextFiber = fiber.child;\\n      list = list.firstContext;\\n      a: for (; null !== list; ) {\\n        var dependency = list;\\n        list = fiber;\\n        for (var i = 0; i < contexts.length; i++)\\n          if (dependency.context === contexts[i]) {\\n            list.lanes |= renderLanes;\\n            dependency = list.alternate;\\n            null !== dependency && (dependency.lanes |= renderLanes);\\n            scheduleContextWorkOnParentPath(\\n              list.return,\\n              renderLanes,\\n              workInProgress\\n            );\\n            forcePropagateEntireTree || (nextFiber = null);\\n            break a;\\n          }\\n        list = dependency.next;\\n      }\\n    } else if (18 === fiber.tag) {\\n      nextFiber = fiber.return;\\n      if (null === nextFiber) throw Error(formatProdErrorMessage(341));\\n      nextFiber.lanes |= renderLanes;\\n      list = nextFiber.alternate;\\n      null !== list && (list.lanes |= renderLanes);\\n      scheduleContextWorkOnParentPath(nextFiber, renderLanes, workInProgress);\\n      nextFiber = null;\\n    } else nextFiber = fiber.child;\\n    if (null !== nextFiber) nextFiber.return = fiber;\\n    else\\n      for (nextFiber = fiber; null !== nextFiber; ) {\\n        if (nextFiber === workInProgress) {\\n          nextFiber = null;\\n          break;\\n        }\\n        fiber = nextFiber.sibling;\\n        if (null !== fiber) {\\n          fiber.return = nextFiber.return;\\n          nextFiber = fiber;\\n          break;\\n        }\\n        nextFiber = nextFiber.return;\\n      }\\n    fiber = nextFiber;\\n  }\\n}\\nfunction propagateParentContextChanges(\\n  current,\\n  workInProgress,\\n  renderLanes,\\n  forcePropagateEntireTree\\n) {\\n  current = null;\\n  for (\\n    var parent = workInProgress, isInsidePropagationBailout = !1;\\n    null !== parent;\\n\\n  ) {\\n    if (!isInsidePropagationBailout)\\n      if (0 !== (parent.flags & 524288)) isInsidePropagationBailout = !0;\\n      else if (0 !== (parent.flags & 262144)) break;\\n    if (10 === parent.tag) {\\n      var currentParent = parent.alternate;\\n      if (null === currentParent) throw Error(formatProdErrorMessage(387));\\n      currentParent = currentParent.memoizedProps;\\n      if (null !== currentParent) {\\n        var context = parent.type;\\n        objectIs(parent.pendingProps.value, currentParent.value) ||\\n          (null !== current ? current.push(context) : (current = [context]));\\n      }\\n    } else if (parent === hostTransitionProviderCursor.current) {\\n      currentParent = parent.alternate;\\n      if (null === currentParent) throw Error(formatProdErrorMessage(387));\\n      currentParent.memoizedState.memoizedState !==\\n        parent.memoizedState.memoizedState &&\\n        (null !== current\\n          ? current.push(HostTransitionContext)\\n          : (current = [HostTransitionContext]));\\n    }\\n    parent = parent.return;\\n  }\\n  null !== current &&\\n    propagateContextChanges(\\n      workInProgress,\\n      current,\\n      renderLanes,\\n      forcePropagateEntireTree\\n    );\\n  workInProgress.flags |= 262144;\\n}\\nfunction checkIfContextChanged(currentDependencies) {\\n  for (\\n    currentDependencies = currentDependencies.firstContext;\\n    null !== currentDependencies;\\n\\n  ) {\\n    if (\\n      !objectIs(\\n        currentDependencies.context._currentValue,\\n        currentDependencies.memoizedValue\\n      )\\n    )\\n      return !0;\\n    currentDependencies = currentDependencies.next;\\n  }\\n  return !1;\\n}\\nfunction prepareToReadContext(workInProgress) {\\n  currentlyRenderingFiber$1 = workInProgress;\\n  lastContextDependency = null;\\n  workInProgress = workInProgress.dependencies;\\n  null !== workInProgress && (workInProgress.firstContext = null);\\n}\\nfunction readContext(context) {\\n  return readContextForConsumer(currentlyRenderingFiber$1, context);\\n}\\nfunction readContextDuringReconciliation(consumer, context) {\\n  null === currentlyRenderingFiber$1 && prepareToReadContext(consumer);\\n  return readContextForConsumer(consumer, context);\\n}\\nfunction readContextForConsumer(consumer, context) {\\n  var value = context._currentValue;\\n  context = { context: context, memoizedValue: value, next: null };\\n  if (null === lastContextDependency) {\\n    if (null === consumer) throw Error(formatProdErrorMessage(308));\\n    lastContextDependency = context;\\n    consumer.dependencies = { lanes: 0, firstContext: context };\\n    consumer.flags |= 524288;\\n  } else lastContextDependency = lastContextDependency.next = context;\\n  return value;\\n}\\nvar AbortControllerLocal =\\n    \"undefined\" !== typeof AbortController\\n      ? AbortController\\n      : function () {\\n          var listeners = [],\\n            signal = (this.signal = {\\n              aborted: !1,\\n              addEventListener: function (type, listener) {\\n                listeners.push(listener);\\n              }\\n            });\\n          this.abort = function () {\\n            signal.aborted = !0;\\n            listeners.forEach(function (listener) {\\n              return listener();\\n            });\\n          };\\n        },\\n  scheduleCallback$2 = Scheduler.unstable_scheduleCallback,\\n  NormalPriority = Scheduler.unstable_NormalPriority,\\n  CacheContext = {\\n    $$typeof: REACT_CONTEXT_TYPE,\\n    Consumer: null,\\n    Provider: null,\\n    _currentValue: null,\\n    _currentValue2: null,\\n    _threadCount: 0\\n  };\\nfunction createCache() {\\n  return {\\n    controller: new AbortControllerLocal(),\\n    data: new Map(),\\n    refCount: 0\\n  };\\n}\\nfunction releaseCache(cache) {\\n  cache.refCount--;\\n  0 === cache.refCount &&\\n    scheduleCallback$2(NormalPriority, function () {\\n      cache.controller.abort();\\n    });\\n}\\nvar currentEntangledListeners = null,\\n  currentEntangledPendingCount = 0,\\n  currentEntangledLane = 0,\\n  currentEntangledActionThenable = null;\\nfunction entangleAsyncAction(transition, thenable) {\\n  if (null === currentEntangledListeners) {\\n    var entangledListeners = (currentEntangledListeners = []);\\n    currentEntangledPendingCount = 0;\\n    currentEntangledLane = requestTransitionLane();\\n    currentEntangledActionThenable = {\\n      status: \"pending\",\\n      value: void 0,\\n      then: function (resolve) {\\n        entangledListeners.push(resolve);\\n      }\\n    };\\n  }\\n  currentEntangledPendingCount++;\\n  thenable.then(pingEngtangledActionScope, pingEngtangledActionScope);\\n  return thenable;\\n}\\nfunction pingEngtangledActionScope() {\\n  if (\\n    0 === --currentEntangledPendingCount &&\\n    null !== currentEntangledListeners\\n  ) {\\n    null !== currentEntangledActionThenable &&\\n      (currentEntangledActionThenable.status = \"fulfilled\");\\n    var listeners = currentEntangledListeners;\\n    currentEntangledListeners = null;\\n    currentEntangledLane = 0;\\n    currentEntangledActionThenable = null;\\n    for (var i = 0; i < listeners.length; i++) (0, listeners[i])();\\n  }\\n}\\nfunction chainThenableValue(thenable, result) {\\n  var listeners = [],\\n    thenableWithOverride = {\\n      status: \"pending\",\\n      value: null,\\n      reason: null,\\n      then: function (resolve) {\\n        listeners.push(resolve);\\n      }\\n    };\\n  thenable.then(\\n    function () {\\n      thenableWithOverride.status = \"fulfilled\";\\n      thenableWithOverride.value = result;\\n      for (var i = 0; i < listeners.length; i++) (0, listeners[i])(result);\\n    },\\n    function (error) {\\n      thenableWithOverride.status = \"rejected\";\\n      thenableWithOverride.reason = error;\\n      for (error = 0; error < listeners.length; error++)\\n        (0, listeners[error])(void 0);\\n    }\\n  );\\n  return thenableWithOverride;\\n}\\nvar prevOnStartTransitionFinish = ReactSharedInternals.S;\\nReactSharedInternals.S = function (transition, returnValue) {\\n  \"object\" === typeof returnValue &&\\n    null !== returnValue &&\\n    \"function\" === typeof returnValue.then &&\\n    entangleAsyncAction(transition, returnValue);\\n  null !== prevOnStartTransitionFinish &&\\n    prevOnStartTransitionFinish(transition, returnValue);\\n};\\nvar resumedCache = createCursor(null);\\nfunction peekCacheFromPool() {\\n  var cacheResumedFromPreviousRender = resumedCache.current;\\n  return null !== cacheResumedFromPreviousRender\\n    ? cacheResumedFromPreviousRender\\n    : workInProgressRoot.pooledCache;\\n}\\nfunction pushTransition(offscreenWorkInProgress, prevCachePool) {\\n  null === prevCachePool\\n    ? push(resumedCache, resumedCache.current)\\n    : push(resumedCache, prevCachePool.pool);\\n}\\nfunction getSuspendedCache() {\\n  var cacheFromPool = peekCacheFromPool();\\n  return null === cacheFromPool\\n    ? null\\n    : { parent: CacheContext._currentValue, pool: cacheFromPool };\\n}\\nvar SuspenseException = Error(formatProdErrorMessage(460)),\\n  SuspenseyCommitException = Error(formatProdErrorMessage(474)),\\n  SuspenseActionException = Error(formatProdErrorMessage(542)),\\n  noopSuspenseyCommitThenable = { then: function () {} };\\nfunction isThenableResolved(thenable) {\\n  thenable = thenable.status;\\n  return \"fulfilled\" === thenable || \"rejected\" === thenable;\\n}\\nfunction noop$3() {}\\nfunction trackUsedThenable(thenableState, thenable, index) {\\n  index = thenableState[index];\\n  void 0 === index\\n    ? thenableState.push(thenable)\\n    : index !== thenable && (thenable.then(noop$3, noop$3), (thenable = index));\\n  switch (thenable.status) {\\n    case \"fulfilled\":\\n      return thenable.value;\\n    case \"rejected\":\\n      throw (\\n        ((thenableState = thenable.reason),\\n        checkIfUseWrappedInAsyncCatch(thenableState),\\n        thenableState)\\n      );\\n    default:\\n      if (\"string\" === typeof thenable.status) thenable.then(noop$3, noop$3);\\n      else {\\n        thenableState = workInProgressRoot;\\n        if (null !== thenableState && 100 < thenableState.shellSuspendCounter)\\n          throw Error(formatProdErrorMessage(482));\\n        thenableState = thenable;\\n        thenableState.status = \"pending\";\\n        thenableState.then(\\n          function (fulfilledValue) {\\n            if (\"pending\" === thenable.status) {\\n              var fulfilledThenable = thenable;\\n              fulfilledThenable.status = \"fulfilled\";\\n              fulfilledThenable.value = fulfilledValue;\\n            }\\n          },\\n          function (error) {\\n            if (\"pending\" === thenable.status) {\\n              var rejectedThenable = thenable;\\n              rejectedThenable.status = \"rejected\";\\n              rejectedThenable.reason = error;\\n            }\\n          }\\n        );\\n      }\\n      switch (thenable.status) {\\n        case \"fulfilled\":\\n          return thenable.value;\\n        case \"rejected\":\\n          throw (\\n            ((thenableState = thenable.reason),\\n            checkIfUseWrappedInAsyncCatch(thenableState),\\n            thenableState)\\n          );\\n      }\\n      suspendedThenable = thenable;\\n      throw SuspenseException;\\n  }\\n}\\nvar suspendedThenable = null;\\nfunction getSuspendedThenable() {\\n  if (null === suspendedThenable) throw Error(formatProdErrorMessage(459));\\n  var thenable = suspendedThenable;\\n  suspendedThenable = null;\\n  return thenable;\\n}\\nfunction checkIfUseWrappedInAsyncCatch(rejectedReason) {\\n  if (\\n    rejectedReason === SuspenseException ||\\n    rejectedReason === SuspenseActionException\\n  )\\n    throw Error(formatProdErrorMessage(483));\\n}\\nvar hasForceUpdate = !1;\\nfunction initializeUpdateQueue(fiber) {\\n  fiber.updateQueue = {\\n    baseState: fiber.memoizedState,\\n    firstBaseUpdate: null,\\n    lastBaseUpdate: null,\\n    shared: { pending: null, lanes: 0, hiddenCallbacks: null },\\n    callbacks: null\\n  };\\n}\\nfunction cloneUpdateQueue(current, workInProgress) {\\n  current = current.updateQueue;\\n  workInProgress.updateQueue === current &&\\n    (workInProgress.updateQueue = {\\n      baseState: current.baseState,\\n      firstBaseUpdate: current.firstBaseUpdate,\\n      lastBaseUpdate: current.lastBaseUpdate,\\n      shared: current.shared,\\n      callbacks: null\\n    });\\n}\\nfunction createUpdate(lane) {\\n  return { lane: lane, tag: 0, payload: null, callback: null, next: null };\\n}\\nfunction enqueueUpdate(fiber, update, lane) {\\n  var updateQueue = fiber.updateQueue;\\n  if (null === updateQueue) return null;\\n  updateQueue = updateQueue.shared;\\n  if (0 !== (executionContext & 2)) {\\n    var pending = updateQueue.pending;\\n    null === pending\\n      ? (update.next = update)\\n      : ((update.next = pending.next), (pending.next = update));\\n    updateQueue.pending = update;\\n    update = getRootForUpdatedFiber(fiber);\\n    markUpdateLaneFromFiberToRoot(fiber, null, lane);\\n    return update;\\n  }\\n  enqueueUpdate$1(fiber, updateQueue, update, lane);\\n  return getRootForUpdatedFiber(fiber);\\n}\\nfunction entangleTransitions(root, fiber, lane) {\\n  fiber = fiber.updateQueue;\\n  if (null !== fiber && ((fiber = fiber.shared), 0 !== (lane & 4194048))) {\\n    var queueLanes = fiber.lanes;\\n    queueLanes &= root.pendingLanes;\\n    lane |= queueLanes;\\n    fiber.lanes = lane;\\n    markRootEntangled(root, lane);\\n  }\\n}\\nfunction enqueueCapturedUpdate(workInProgress, capturedUpdate) {\\n  var queue = workInProgress.updateQueue,\\n    current = workInProgress.alternate;\\n  if (\\n    null !== current &&\\n    ((current = current.updateQueue), queue === current)\\n  ) {\\n    var newFirst = null,\\n      newLast = null;\\n    queue = queue.firstBaseUpdate;\\n    if (null !== queue) {\\n      do {\\n        var clone = {\\n          lane: queue.lane,\\n          tag: queue.tag,\\n          payload: queue.payload,\\n          callback: null,\\n          next: null\\n        };\\n        null === newLast\\n          ? (newFirst = newLast = clone)\\n          : (newLast = newLast.next = clone);\\n        queue = queue.next;\\n      } while (null !== queue);\\n      null === newLast\\n        ? (newFirst = newLast = capturedUpdate)\\n        : (newLast = newLast.next = capturedUpdate);\\n    } else newFirst = newLast = capturedUpdate;\\n    queue = {\\n      baseState: current.baseState,\\n      firstBaseUpdate: newFirst,\\n      lastBaseUpdate: newLast,\\n      shared: current.shared,\\n      callbacks: current.callbacks\\n    };\\n    workInProgress.updateQueue = queue;\\n    return;\\n  }\\n  workInProgress = queue.lastBaseUpdate;\\n  null === workInProgress\\n    ? (queue.firstBaseUpdate = capturedUpdate)\\n    : (workInProgress.next = capturedUpdate);\\n  queue.lastBaseUpdate = capturedUpdate;\\n}\\nvar didReadFromEntangledAsyncAction = !1;\\nfunction suspendIfUpdateReadFromEntangledAsyncAction() {\\n  if (didReadFromEntangledAsyncAction) {\\n    var entangledActionThenable = currentEntangledActionThenable;\\n    if (null !== entangledActionThenable) throw entangledActionThenable;\\n  }\\n}\\nfunction processUpdateQueue(\\n  workInProgress$jscomp$0,\\n  props,\\n  instance$jscomp$0,\\n  renderLanes\\n) {\\n  didReadFromEntangledAsyncAction = !1;\\n  var queue = workInProgress$jscomp$0.updateQueue;\\n  hasForceUpdate = !1;\\n  var firstBaseUpdate = queue.firstBaseUpdate,\\n    lastBaseUpdate = queue.lastBaseUpdate,\\n    pendingQueue = queue.shared.pending;\\n  if (null !== pendingQueue) {\\n    queue.shared.pending = null;\\n    var lastPendingUpdate = pendingQueue,\\n      firstPendingUpdate = lastPendingUpdate.next;\\n    lastPendingUpdate.next = null;\\n    null === lastBaseUpdate\\n      ? (firstBaseUpdate = firstPendingUpdate)\\n      : (lastBaseUpdate.next = firstPendingUpdate);\\n    lastBaseUpdate = lastPendingUpdate;\\n    var current = workInProgress$jscomp$0.alternate;\\n    null !== current &&\\n      ((current = current.updateQueue),\\n      (pendingQueue = current.lastBaseUpdate),\\n      pendingQueue !== lastBaseUpdate &&\\n        (null === pendingQueue\\n          ? (current.firstBaseUpdate = firstPendingUpdate)\\n          : (pendingQueue.next = firstPendingUpdate),\\n        (current.lastBaseUpdate = lastPendingUpdate)));\\n  }\\n  if (null !== firstBaseUpdate) {\\n    var newState = queue.baseState;\\n    lastBaseUpdate = 0;\\n    current = firstPendingUpdate = lastPendingUpdate = null;\\n    pendingQueue = firstBaseUpdate;\\n    do {\\n      var updateLane = pendingQueue.lane & -536870913,\\n        isHiddenUpdate = updateLane !== pendingQueue.lane;\\n      if (\\n        isHiddenUpdate\\n          ? (workInProgressRootRenderLanes & updateLane) === updateLane\\n          : (renderLanes & updateLane) === updateLane\\n      ) {\\n        0 !== updateLane &&\\n          updateLane === currentEntangledLane &&\\n          (didReadFromEntangledAsyncAction = !0);\\n        null !== current &&\\n          (current = current.next =\\n            {\\n              lane: 0,\\n              tag: pendingQueue.tag,\\n              payload: pendingQueue.payload,\\n              callback: null,\\n              next: null\\n            });\\n        a: {\\n          var workInProgress = workInProgress$jscomp$0,\\n            update = pendingQueue;\\n          updateLane = props;\\n          var instance = instance$jscomp$0;\\n          switch (update.tag) {\\n            case 1:\\n              workInProgress = update.payload;\\n              if (\"function\" === typeof workInProgress) {\\n                newState = workInProgress.call(instance, newState, updateLane);\\n                break a;\\n              }\\n              newState = workInProgress;\\n              break a;\\n            case 3:\\n              workInProgress.flags = (workInProgress.flags & -65537) | 128;\\n            case 0:\\n              workInProgress = update.payload;\\n              updateLane =\\n                \"function\" === typeof workInProgress\\n                  ? workInProgress.call(instance, newState, updateLane)\\n                  : workInProgress;\\n              if (null === updateLane || void 0 === updateLane) break a;\\n              newState = assign({}, newState, updateLane);\\n              break a;\\n            case 2:\\n              hasForceUpdate = !0;\\n          }\\n        }\\n        updateLane = pendingQueue.callback;\\n        null !== updateLane &&\\n          ((workInProgress$jscomp$0.flags |= 64),\\n          isHiddenUpdate && (workInProgress$jscomp$0.flags |= 8192),\\n          (isHiddenUpdate = queue.callbacks),\\n          null === isHiddenUpdate\\n            ? (queue.callbacks = [updateLane])\\n            : isHiddenUpdate.push(updateLane));\\n      } else\\n        (isHiddenUpdate = {\\n          lane: updateLane,\\n          tag: pendingQueue.tag,\\n          payload: pendingQueue.payload,\\n          callback: pendingQueue.callback,\\n          next: null\\n        }),\\n          null === current\\n            ? ((firstPendingUpdate = current = isHiddenUpdate),\\n              (lastPendingUpdate = newState))\\n            : (current = current.next = isHiddenUpdate),\\n          (lastBaseUpdate |= updateLane);\\n      pendingQueue = pendingQueue.next;\\n      if (null === pendingQueue)\\n        if (((pendingQueue = queue.shared.pending), null === pendingQueue))\\n          break;\\n        else\\n          (isHiddenUpdate = pendingQueue),\\n            (pendingQueue = isHiddenUpdate.next),\\n            (isHiddenUpdate.next = null),\\n            (queue.lastBaseUpdate = isHiddenUpdate),\\n            (queue.shared.pending = null);\\n    } while (1);\\n    null === current && (lastPendingUpdate = newState);\\n    queue.baseState = lastPendingUpdate;\\n    queue.firstBaseUpdate = firstPendingUpdate;\\n    queue.lastBaseUpdate = current;\\n    null === firstBaseUpdate && (queue.shared.lanes = 0);\\n    workInProgressRootSkippedLanes |= lastBaseUpdate;\\n    workInProgress$jscomp$0.lanes = lastBaseUpdate;\\n    workInProgress$jscomp$0.memoizedState = newState;\\n  }\\n}\\nfunction callCallback(callback, context) {\\n  if (\"function\" !== typeof callback)\\n    throw Error(formatProdErrorMessage(191, callback));\\n  callback.call(context);\\n}\\nfunction commitCallbacks(updateQueue, context) {\\n  var callbacks = updateQueue.callbacks;\\n  if (null !== callbacks)\\n    for (\\n      updateQueue.callbacks = null, updateQueue = 0;\\n      updateQueue < callbacks.length;\\n      updateQueue++\\n    )\\n      callCallback(callbacks[updateQueue], context);\\n}\\nvar currentTreeHiddenStackCursor = createCursor(null),\\n  prevEntangledRenderLanesCursor = createCursor(0);\\nfunction pushHiddenContext(fiber, context) {\\n  fiber = entangledRenderLanes;\\n  push(prevEntangledRenderLanesCursor, fiber);\\n  push(currentTreeHiddenStackCursor, context);\\n  entangledRenderLanes = fiber | context.baseLanes;\\n}\\nfunction reuseHiddenContextOnStack() {\\n  push(prevEntangledRenderLanesCursor, entangledRenderLanes);\\n  push(currentTreeHiddenStackCursor, currentTreeHiddenStackCursor.current);\\n}\\nfunction popHiddenContext() {\\n  entangledRenderLanes = prevEntangledRenderLanesCursor.current;\\n  pop(currentTreeHiddenStackCursor);\\n  pop(prevEntangledRenderLanesCursor);\\n}\\nvar renderLanes = 0,\\n  currentlyRenderingFiber = null,\\n  currentHook = null,\\n  workInProgressHook = null,\\n  didScheduleRenderPhaseUpdate = !1,\\n  didScheduleRenderPhaseUpdateDuringThisPass = !1,\\n  shouldDoubleInvokeUserFnsInHooksDEV = !1,\\n  localIdCounter = 0,\\n  thenableIndexCounter$1 = 0,\\n  thenableState$1 = null,\\n  globalClientIdCounter = 0;\\nfunction throwInvalidHookError() {\\n  throw Error(formatProdErrorMessage(321));\\n}\\nfunction areHookInputsEqual(nextDeps, prevDeps) {\\n  if (null === prevDeps) return !1;\\n  for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++)\\n    if (!objectIs(nextDeps[i], prevDeps[i])) return !1;\\n  return !0;\\n}\\nfunction renderWithHooks(\\n  current,\\n  workInProgress,\\n  Component,\\n  props,\\n  secondArg,\\n  nextRenderLanes\\n) {\\n  renderLanes = nextRenderLanes;\\n  currentlyRenderingFiber = workInProgress;\\n  workInProgress.memoizedState = null;\\n  workInProgress.updateQueue = null;\\n  workInProgress.lanes = 0;\\n  ReactSharedInternals.H =\\n    null === current || null === current.memoizedState\\n      ? HooksDispatcherOnMount\\n      : HooksDispatcherOnUpdate;\\n  shouldDoubleInvokeUserFnsInHooksDEV = !1;\\n  nextRenderLanes = Component(props, secondArg);\\n  shouldDoubleInvokeUserFnsInHooksDEV = !1;\\n  didScheduleRenderPhaseUpdateDuringThisPass &&\\n    (nextRenderLanes = renderWithHooksAgain(\\n      workInProgress,\\n      Component,\\n      props,\\n      secondArg\\n    ));\\n  finishRenderingHooks(current);\\n  return nextRenderLanes;\\n}\\nfunction finishRenderingHooks(current) {\\n  ReactSharedInternals.H = ContextOnlyDispatcher;\\n  var didRenderTooFewHooks = null !== currentHook && null !== currentHook.next;\\n  renderLanes = 0;\\n  workInProgressHook = currentHook = currentlyRenderingFiber = null;\\n  didScheduleRenderPhaseUpdate = !1;\\n  thenableIndexCounter$1 = 0;\\n  thenableState$1 = null;\\n  if (didRenderTooFewHooks) throw Error(formatProdErrorMessage(300));\\n  null === current ||\\n    didReceiveUpdate ||\\n    ((current = current.dependencies),\\n    null !== current &&\\n      checkIfContextChanged(current) &&\\n      (didReceiveUpdate = !0));\\n}\\nfunction renderWithHooksAgain(workInProgress, Component, props, secondArg) {\\n  currentlyRenderingFiber = workInProgress;\\n  var numberOfReRenders = 0;\\n  do {\\n    didScheduleRenderPhaseUpdateDuringThisPass && (thenableState$1 = null);\\n    thenableIndexCounter$1 = 0;\\n    didScheduleRenderPhaseUpdateDuringThisPass = !1;\\n    if (25 <= numberOfReRenders) throw Error(formatProdErrorMessage(301));\\n    numberOfReRenders += 1;\\n    workInProgressHook = currentHook = null;\\n    if (null != workInProgress.updateQueue) {\\n      var children = workInProgress.updateQueue;\\n      children.lastEffect = null;\\n      children.events = null;\\n      children.stores = null;\\n      null != children.memoCache && (children.memoCache.index = 0);\\n    }\\n    ReactSharedInternals.H = HooksDispatcherOnRerender;\\n    children = Component(props, secondArg);\\n  } while (didScheduleRenderPhaseUpdateDuringThisPass);\\n  return children;\\n}\\nfunction TransitionAwareHostComponent() {\\n  var dispatcher = ReactSharedInternals.H,\\n    maybeThenable = dispatcher.useState()[0];\\n  maybeThenable =\\n    \"function\" === typeof maybeThenable.then\\n      ? useThenable(maybeThenable)\\n      : maybeThenable;\\n  dispatcher = dispatcher.useState()[0];\\n  (null !== currentHook ? currentHook.memoizedState : null) !== dispatcher &&\\n    (currentlyRenderingFiber.flags |= 1024);\\n  return maybeThenable;\\n}\\nfunction checkDidRenderIdHook() {\\n  var didRenderIdHook = 0 !== localIdCounter;\\n  localIdCounter = 0;\\n  return didRenderIdHook;\\n}\\nfunction bailoutHooks(current, workInProgress, lanes) {\\n  workInProgress.updateQueue = current.updateQueue;\\n  workInProgress.flags &= -2053;\\n  current.lanes &= ~lanes;\\n}\\nfunction resetHooksOnUnwind(workInProgress) {\\n  if (didScheduleRenderPhaseUpdate) {\\n    for (\\n      workInProgress = workInProgress.memoizedState;\\n      null !== workInProgress;\\n\\n    ) {\\n      var queue = workInProgress.queue;\\n      null !== queue && (queue.pending = null);\\n      workInProgress = workInProgress.next;\\n    }\\n    didScheduleRenderPhaseUpdate = !1;\\n  }\\n  renderLanes = 0;\\n  workInProgressHook = currentHook = currentlyRenderingFiber = null;\\n  didScheduleRenderPhaseUpdateDuringThisPass = !1;\\n  thenableIndexCounter$1 = localIdCounter = 0;\\n  thenableState$1 = null;\\n}\\nfunction mountWorkInProgressHook() {\\n  var hook = {\\n    memoizedState: null,\\n    baseState: null,\\n    baseQueue: null,\\n    queue: null,\\n    next: null\\n  };\\n  null === workInProgressHook\\n    ? (currentlyRenderingFiber.memoizedState = workInProgressHook = hook)\\n    : (workInProgressHook = workInProgressHook.next = hook);\\n  return workInProgressHook;\\n}\\nfunction updateWorkInProgressHook() {\\n  if (null === currentHook) {\\n    var nextCurrentHook = currentlyRenderingFiber.alternate;\\n    nextCurrentHook =\\n      null !== nextCurrentHook ? nextCurrentHook.memoizedState : null;\\n  } else nextCurrentHook = currentHook.next;\\n  var nextWorkInProgressHook =\\n    null === workInProgressHook\\n      ? currentlyRenderingFiber.memoizedState\\n      : workInProgressHook.next;\\n  if (null !== nextWorkInProgressHook)\\n    (workInProgressHook = nextWorkInProgressHook),\\n      (currentHook = nextCurrentHook);\\n  else {\\n    if (null === nextCurrentHook) {\\n      if (null === currentlyRenderingFiber.alternate)\\n        throw Error(formatProdErrorMessage(467));\\n      throw Error(formatProdErrorMessage(310));\\n    }\\n    currentHook = nextCurrentHook;\\n    nextCurrentHook = {\\n      memoizedState: currentHook.memoizedState,\\n      baseState: currentHook.baseState,\\n      baseQueue: currentHook.baseQueue,\\n      queue: currentHook.queue,\\n      next: null\\n    };\\n    null === workInProgressHook\\n      ? (currentlyRenderingFiber.memoizedState = workInProgressHook =\\n          nextCurrentHook)\\n      : (workInProgressHook = workInProgressHook.next = nextCurrentHook);\\n  }\\n  return workInProgressHook;\\n}\\nfunction createFunctionComponentUpdateQueue() {\\n  return { lastEffect: null, events: null, stores: null, memoCache: null };\\n}\\nfunction useThenable(thenable) {\\n  var index = thenableIndexCounter$1;\\n  thenableIndexCounter$1 += 1;\\n  null === thenableState$1 && (thenableState$1 = []);\\n  thenable = trackUsedThenable(thenableState$1, thenable, index);\\n  index = currentlyRenderingFiber;\\n  null ===\\n    (null === workInProgressHook\\n      ? index.memoizedState\\n      : workInProgressHook.next) &&\\n    ((index = index.alternate),\\n    (ReactSharedInternals.H =\\n      null === index || null === index.memoizedState\\n        ? HooksDispatcherOnMount\\n        : HooksDispatcherOnUpdate));\\n  return thenable;\\n}\\nfunction use(usable) {\\n  if (null !== usable && \"object\" === typeof usable) {\\n    if (\"function\" === typeof usable.then) return useThenable(usable);\\n    if (usable.$$typeof === REACT_CONTEXT_TYPE) return readContext(usable);\\n  }\\n  throw Error(formatProdErrorMessage(438, String(usable)));\\n}\\nfunction useMemoCache(size) {\\n  var memoCache = null,\\n    updateQueue = currentlyRenderingFiber.updateQueue;\\n  null !== updateQueue && (memoCache = updateQueue.memoCache);\\n  if (null == memoCache) {\\n    var current = currentlyRenderingFiber.alternate;\\n    null !== current &&\\n      ((current = current.updateQueue),\\n      null !== current &&\\n        ((current = current.memoCache),\\n        null != current &&\\n          (memoCache = {\\n            data: current.data.map(function (array) {\\n              return array.slice();\\n            }),\\n            index: 0\\n          })));\\n  }\\n  null == memoCache && (memoCache = { data: [], index: 0 });\\n  null === updateQueue &&\\n    ((updateQueue = createFunctionComponentUpdateQueue()),\\n    (currentlyRenderingFiber.updateQueue = updateQueue));\\n  updateQueue.memoCache = memoCache;\\n  updateQueue = memoCache.data[memoCache.index];\\n  if (void 0 === updateQueue)\\n    for (\\n      updateQueue = memoCache.data[memoCache.index] = Array(size), current = 0;\\n      current < size;\\n      current++\\n    )\\n      updateQueue[current] = REACT_MEMO_CACHE_SENTINEL;\\n  memoCache.index++;\\n  return updateQueue;\\n}\\nfunction basicStateReducer(state, action) {\\n  return \"function\" === typeof action ? action(state) : action;\\n}\\nfunction updateReducer(reducer) {\\n  var hook = updateWorkInProgressHook();\\n  return updateReducerImpl(hook, currentHook, reducer);\\n}\\nfunction updateReducerImpl(hook, current, reducer) {\\n  var queue = hook.queue;\\n  if (null === queue) throw Error(formatProdErrorMessage(311));\\n  queue.lastRenderedReducer = reducer;\\n  var baseQueue = hook.baseQueue,\\n    pendingQueue = queue.pending;\\n  if (null !== pendingQueue) {\\n    if (null !== baseQueue) {\\n      var baseFirst = baseQueue.next;\\n      baseQueue.next = pendingQueue.next;\\n      pendingQueue.next = baseFirst;\\n    }\\n    current.baseQueue = baseQueue = pendingQueue;\\n    queue.pending = null;\\n  }\\n  pendingQueue = hook.baseState;\\n  if (null === baseQueue) hook.memoizedState = pendingQueue;\\n  else {\\n    current = baseQueue.next;\\n    var newBaseQueueFirst = (baseFirst = null),\\n      newBaseQueueLast = null,\\n      update = current,\\n      didReadFromEntangledAsyncAction$32 = !1;\\n    do {\\n      var updateLane = update.lane & -536870913;\\n      if (\\n        updateLane !== update.lane\\n          ? (workInProgressRootRenderLanes & updateLane) === updateLane\\n          : (renderLanes & updateLane) === updateLane\\n      ) {\\n        var revertLane = update.revertLane;\\n        if (0 === revertLane)\\n          null !== newBaseQueueLast &&\\n            (newBaseQueueLast = newBaseQueueLast.next =\\n              {\\n                lane: 0,\\n                revertLane: 0,\\n                action: update.action,\\n                hasEagerState: update.hasEagerState,\\n                eagerState: update.eagerState,\\n                next: null\\n              }),\\n            updateLane === currentEntangledLane &&\\n              (didReadFromEntangledAsyncAction$32 = !0);\\n        else if ((renderLanes & revertLane) === revertLane) {\\n          update = update.next;\\n          revertLane === currentEntangledLane &&\\n            (didReadFromEntangledAsyncAction$32 = !0);\\n          continue;\\n        } else\\n          (updateLane = {\\n            lane: 0,\\n            revertLane: update.revertLane,\\n            action: update.action,\\n            hasEagerState: update.hasEagerState,\\n            eagerState: update.eagerState,\\n            next: null\\n          }),\\n            null === newBaseQueueLast\\n              ? ((newBaseQueueFirst = newBaseQueueLast = updateLane),\\n                (baseFirst = pendingQueue))\\n              : (newBaseQueueLast = newBaseQueueLast.next = updateLane),\\n            (currentlyRenderingFiber.lanes |= revertLane),\\n            (workInProgressRootSkippedLanes |= revertLane);\\n        updateLane = update.action;\\n        shouldDoubleInvokeUserFnsInHooksDEV &&\\n          reducer(pendingQueue, updateLane);\\n        pendingQueue = update.hasEagerState\\n          ? update.eagerState\\n          : reducer(pendingQueue, updateLane);\\n      } else\\n        (revertLane = {\\n          lane: updateLane,\\n          revertLane: update.revertLane,\\n          action: update.action,\\n          hasEagerState: update.hasEagerState,\\n          eagerState: update.eagerState,\\n          next: null\\n        }),\\n          null === newBaseQueueLast\\n            ? ((newBaseQueueFirst = newBaseQueueLast = revertLane),\\n              (baseFirst = pendingQueue))\\n            : (newBaseQueueLast = newBaseQueueLast.next = revertLane),\\n          (currentlyRenderingFiber.lanes |= updateLane),\\n          (workInProgressRootSkippedLanes |= updateLane);\\n      update = update.next;\\n    } while (null !== update && update !== current);\\n    null === newBaseQueueLast\\n      ? (baseFirst = pendingQueue)\\n      : (newBaseQueueLast.next = newBaseQueueFirst);\\n    if (\\n      !objectIs(pendingQueue, hook.memoizedState) &&\\n      ((didReceiveUpdate = !0),\\n      didReadFromEntangledAsyncAction$32 &&\\n        ((reducer = currentEntangledActionThenable), null !== reducer))\\n    )\\n      throw reducer;\\n    hook.memoizedState = pendingQueue;\\n    hook.baseState = baseFirst;\\n    hook.baseQueue = newBaseQueueLast;\\n    queue.lastRenderedState = pendingQueue;\\n  }\\n  null === baseQueue && (queue.lanes = 0);\\n  return [hook.memoizedState, queue.dispatch];\\n}\\nfunction rerenderReducer(reducer) {\\n  var hook = updateWorkInProgressHook(),\\n    queue = hook.queue;\\n  if (null === queue) throw Error(formatProdErrorMessage(311));\\n  queue.lastRenderedReducer = reducer;\\n  var dispatch = queue.dispatch,\\n    lastRenderPhaseUpdate = queue.pending,\\n    newState = hook.memoizedState;\\n  if (null !== lastRenderPhaseUpdate) {\\n    queue.pending = null;\\n    var update = (lastRenderPhaseUpdate = lastRenderPhaseUpdate.next);\\n    do (newState = reducer(newState, update.action)), (update = update.next);\\n    while (update !== lastRenderPhaseUpdate);\\n    objectIs(newState, hook.memoizedState) || (didReceiveUpdate = !0);\\n    hook.memoizedState = newState;\\n    null === hook.baseQueue && (hook.baseState = newState);\\n    queue.lastRenderedState = newState;\\n  }\\n  return [newState, dispatch];\\n}\\nfunction updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {\\n  var fiber = currentlyRenderingFiber,\\n    hook = updateWorkInProgressHook(),\\n    isHydrating$jscomp$0 = isHydrating;\\n  if (isHydrating$jscomp$0) {\\n    if (void 0 === getServerSnapshot) throw Error(formatProdErrorMessage(407));\\n    getServerSnapshot = getServerSnapshot();\\n  } else getServerSnapshot = getSnapshot();\\n  var snapshotChanged = !objectIs(\\n    (currentHook || hook).memoizedState,\\n    getServerSnapshot\\n  );\\n  snapshotChanged &&\\n    ((hook.memoizedState = getServerSnapshot), (didReceiveUpdate = !0));\\n  hook = hook.queue;\\n  var create = subscribeToStore.bind(null, fiber, hook, subscribe);\\n  updateEffectImpl(2048, 8, create, [subscribe]);\\n  if (\\n    hook.getSnapshot !== getSnapshot ||\\n    snapshotChanged ||\\n    (null !== workInProgressHook && workInProgressHook.memoizedState.tag & 1)\\n  ) {\\n    fiber.flags |= 2048;\\n    pushSimpleEffect(\\n      9,\\n      createEffectInstance(),\\n      updateStoreInstance.bind(\\n        null,\\n        fiber,\\n        hook,\\n        getServerSnapshot,\\n        getSnapshot\\n      ),\\n      null\\n    );\\n    if (null === workInProgressRoot) throw Error(formatProdErrorMessage(349));\\n    isHydrating$jscomp$0 ||\\n      0 !== (renderLanes & 124) ||\\n      pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);\\n  }\\n  return getServerSnapshot;\\n}\\nfunction pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {\\n  fiber.flags |= 16384;\\n  fiber = { getSnapshot: getSnapshot, value: renderedSnapshot };\\n  getSnapshot = currentlyRenderingFiber.updateQueue;\\n  null === getSnapshot\\n    ? ((getSnapshot = createFunctionComponentUpdateQueue()),\\n      (currentlyRenderingFiber.updateQueue = getSnapshot),\\n      (getSnapshot.stores = [fiber]))\\n    : ((renderedSnapshot = getSnapshot.stores),\\n      null === renderedSnapshot\\n        ? (getSnapshot.stores = [fiber])\\n        : renderedSnapshot.push(fiber));\\n}\\nfunction updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {\\n  inst.value = nextSnapshot;\\n  inst.getSnapshot = getSnapshot;\\n  checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);\\n}\\nfunction subscribeToStore(fiber, inst, subscribe) {\\n  return subscribe(function () {\\n    checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);\\n  });\\n}\\nfunction checkIfSnapshotChanged(inst) {\\n  var latestGetSnapshot = inst.getSnapshot;\\n  inst = inst.value;\\n  try {\\n    var nextValue = latestGetSnapshot();\\n    return !objectIs(inst, nextValue);\\n  } catch (error) {\\n    return !0;\\n  }\\n}\\nfunction forceStoreRerender(fiber) {\\n  var root = enqueueConcurrentRenderForLane(fiber, 2);\\n  null !== root && scheduleUpdateOnFiber(root, fiber, 2);\\n}\\nfunction mountStateImpl(initialState) {\\n  var hook = mountWorkInProgressHook();\\n  if (\"function\" === typeof initialState) {\\n    var initialStateInitializer = initialState;\\n    initialState = initialStateInitializer();\\n    if (shouldDoubleInvokeUserFnsInHooksDEV) {\\n      setIsStrictModeForDevtools(!0);\\n      try {\\n        initialStateInitializer();\\n      } finally {\\n        setIsStrictModeForDevtools(!1);\\n      }\\n    }\\n  }\\n  hook.memoizedState = hook.baseState = initialState;\\n  hook.queue = {\\n    pending: null,\\n    lanes: 0,\\n    dispatch: null,\\n    lastRenderedReducer: basicStateReducer,\\n    lastRenderedState: initialState\\n  };\\n  return hook;\\n}\\nfunction updateOptimisticImpl(hook, current, passthrough, reducer) {\\n  hook.baseState = passthrough;\\n  return updateReducerImpl(\\n    hook,\\n    currentHook,\\n    \"function\" === typeof reducer ? reducer : basicStateReducer\\n  );\\n}\\nfunction dispatchActionState(\\n  fiber,\\n  actionQueue,\\n  setPendingState,\\n  setState,\\n  payload\\n) {\\n  if (isRenderPhaseUpdate(fiber)) throw Error(formatProdErrorMessage(485));\\n  fiber = actionQueue.action;\\n  if (null !== fiber) {\\n    var actionNode = {\\n      payload: payload,\\n      action: fiber,\\n      next: null,\\n      isTransition: !0,\\n      status: \"pending\",\\n      value: null,\\n      reason: null,\\n      listeners: [],\\n      then: function (listener) {\\n        actionNode.listeners.push(listener);\\n      }\\n    };\\n    null !== ReactSharedInternals.T\\n      ? setPendingState(!0)\\n      : (actionNode.isTransition = !1);\\n    setState(actionNode);\\n    setPendingState = actionQueue.pending;\\n    null === setPendingState\\n      ? ((actionNode.next = actionQueue.pending = actionNode),\\n        runActionStateAction(actionQueue, actionNode))\\n      : ((actionNode.next = setPendingState.next),\\n        (actionQueue.pending = setPendingState.next = actionNode));\\n  }\\n}\\nfunction runActionStateAction(actionQueue, node) {\\n  var action = node.action,\\n    payload = node.payload,\\n    prevState = actionQueue.state;\\n  if (node.isTransition) {\\n    var prevTransition = ReactSharedInternals.T,\\n      currentTransition = {};\\n    ReactSharedInternals.T = currentTransition;\\n    try {\\n      var returnValue = action(prevState, payload),\\n        onStartTransitionFinish = ReactSharedInternals.S;\\n      null !== onStartTransitionFinish &&\\n        onStartTransitionFinish(currentTransition, returnValue);\\n      handleActionReturnValue(actionQueue, node, returnValue);\\n    } catch (error) {\\n      onActionError(actionQueue, node, error);\\n    } finally {\\n      ReactSharedInternals.T = prevTransition;\\n    }\\n  } else\\n    try {\\n      (prevTransition = action(prevState, payload)),\\n        handleActionReturnValue(actionQueue, node, prevTransition);\\n    } catch (error$38) {\\n      onActionError(actionQueue, node, error$38);\\n    }\\n}\\nfunction handleActionReturnValue(actionQueue, node, returnValue) {\\n  null !== returnValue &&\\n  \"object\" === typeof returnValue &&\\n  \"function\" === typeof returnValue.then\\n    ? returnValue.then(\\n        function (nextState) {\\n          onActionSuccess(actionQueue, node, nextState);\\n        },\\n        function (error) {\\n          return onActionError(actionQueue, node, error);\\n        }\\n      )\\n    : onActionSuccess(actionQueue, node, returnValue);\\n}\\nfunction onActionSuccess(actionQueue, actionNode, nextState) {\\n  actionNode.status = \"fulfilled\";\\n  actionNode.value = nextState;\\n  notifyActionListeners(actionNode);\\n  actionQueue.state = nextState;\\n  actionNode = actionQueue.pending;\\n  null !== actionNode &&\\n    ((nextState = actionNode.next),\\n    nextState === actionNode\\n      ? (actionQueue.pending = null)\\n      : ((nextState = nextState.next),\\n        (actionNode.next = nextState),\\n        runActionStateAction(actionQueue, nextState)));\\n}\\nfunction onActionError(actionQueue, actionNode, error) {\\n  var last = actionQueue.pending;\\n  actionQueue.pending = null;\\n  if (null !== last) {\\n    last = last.next;\\n    do\\n      (actionNode.status = \"rejected\"),\\n        (actionNode.reason = error),\\n        notifyActionListeners(actionNode),\\n        (actionNode = actionNode.next);\\n    while (actionNode !== last);\\n  }\\n  actionQueue.action = null;\\n}\\nfunction notifyActionListeners(actionNode) {\\n  actionNode = actionNode.listeners;\\n  for (var i = 0; i < actionNode.length; i++) (0, actionNode[i])();\\n}\\nfunction actionStateReducer(oldState, newState) {\\n  return newState;\\n}\\nfunction mountActionState(action, initialStateProp) {\\n  if (isHydrating) {\\n    var ssrFormState = workInProgressRoot.formState;\\n    if (null !== ssrFormState) {\\n      a: {\\n        var JSCompiler_inline_result = currentlyRenderingFiber;\\n        if (isHydrating) {\\n          if (nextHydratableInstance) {\\n            b: {\\n              var JSCompiler_inline_result$jscomp$0 = nextHydratableInstance;\\n              for (\\n                var inRootOrSingleton = rootOrSingletonContext;\\n                8 !== JSCompiler_inline_result$jscomp$0.nodeType;\\n\\n              ) {\\n                if (!inRootOrSingleton) {\\n                  JSCompiler_inline_result$jscomp$0 = null;\\n                  break b;\\n                }\\n                JSCompiler_inline_result$jscomp$0 = getNextHydratable(\\n                  JSCompiler_inline_result$jscomp$0.nextSibling\\n                );\\n                if (null === JSCompiler_inline_result$jscomp$0) {\\n                  JSCompiler_inline_result$jscomp$0 = null;\\n                  break b;\\n                }\\n              }\\n              inRootOrSingleton = JSCompiler_inline_result$jscomp$0.data;\\n              JSCompiler_inline_result$jscomp$0 =\\n                \"F!\" === inRootOrSingleton || \"F\" === inRootOrSingleton\\n                  ? JSCompiler_inline_result$jscomp$0\\n                  : null;\\n            }\\n            if (JSCompiler_inline_result$jscomp$0) {\\n              nextHydratableInstance = getNextHydratable(\\n                JSCompiler_inline_result$jscomp$0.nextSibling\\n              );\\n              JSCompiler_inline_result =\\n                \"F!\" === JSCompiler_inline_result$jscomp$0.data;\\n              break a;\\n            }\\n          }\\n          throwOnHydrationMismatch(JSCompiler_inline_result);\\n        }\\n        JSCompiler_inline_result = !1;\\n      }\\n      JSCompiler_inline_result && (initialStateProp = ssrFormState[0]);\\n    }\\n  }\\n  ssrFormState = mountWorkInProgressHook();\\n  ssrFormState.memoizedState = ssrFormState.baseState = initialStateProp;\\n  JSCompiler_inline_result = {\\n    pending: null,\\n    lanes: 0,\\n    dispatch: null,\\n    lastRenderedReducer: actionStateReducer,\\n    lastRenderedState: initialStateProp\\n  };\\n  ssrFormState.queue = JSCompiler_inline_result;\\n  ssrFormState = dispatchSetState.bind(\\n    null,\\n    currentlyRenderingFiber,\\n    JSCompiler_inline_result\\n  );\\n  JSCompiler_inline_result.dispatch = ssrFormState;\\n  JSCompiler_inline_result = mountStateImpl(!1);\\n  inRootOrSingleton = dispatchOptimisticSetState.bind(\\n    null,\\n    currentlyRenderingFiber,\\n    !1,\\n    JSCompiler_inline_result.queue\\n  );\\n  JSCompiler_inline_result = mountWorkInProgressHook();\\n  JSCompiler_inline_result$jscomp$0 = {\\n    state: initialStateProp,\\n    dispatch: null,\\n    action: action,\\n    pending: null\\n  };\\n  JSCompiler_inline_result.queue = JSCompiler_inline_result$jscomp$0;\\n  ssrFormState = dispatchActionState.bind(\\n    null,\\n    currentlyRenderingFiber,\\n    JSCompiler_inline_result$jscomp$0,\\n    inRootOrSingleton,\\n    ssrFormState\\n  );\\n  JSCompiler_inline_result$jscomp$0.dispatch = ssrFormState;\\n  JSCompiler_inline_result.memoizedState = action;\\n  return [initialStateProp, ssrFormState, !1];\\n}\\nfunction updateActionState(action) {\\n  var stateHook = updateWorkInProgressHook();\\n  return updateActionStateImpl(stateHook, currentHook, action);\\n}\\nfunction updateActionStateImpl(stateHook, currentStateHook, action) {\\n  currentStateHook = updateReducerImpl(\\n    stateHook,\\n    currentStateHook,\\n    actionStateReducer\\n  )[0];\\n  stateHook = updateReducer(basicStateReducer)[0];\\n  if (\\n    \"object\" === typeof currentStateHook &&\\n    null !== currentStateHook &&\\n    \"function\" === typeof currentStateHook.then\\n  )\\n    try {\\n      var state = useThenable(currentStateHook);\\n    } catch (x) {\\n      if (x === SuspenseException) throw SuspenseActionException;\\n      throw x;\\n    }\\n  else state = currentStateHook;\\n  currentStateHook = updateWorkInProgressHook();\\n  var actionQueue = currentStateHook.queue,\\n    dispatch = actionQueue.dispatch;\\n  action !== currentStateHook.memoizedState &&\\n    ((currentlyRenderingFiber.flags |= 2048),\\n    pushSimpleEffect(\\n      9,\\n      createEffectInstance(),\\n      actionStateActionEffect.bind(null, actionQueue, action),\\n      null\\n    ));\\n  return [state, dispatch, stateHook];\\n}\\nfunction actionStateActionEffect(actionQueue, action) {\\n  actionQueue.action = action;\\n}\\nfunction rerenderActionState(action) {\\n  var stateHook = updateWorkInProgressHook(),\\n    currentStateHook = currentHook;\\n  if (null !== currentStateHook)\\n    return updateActionStateImpl(stateHook, currentStateHook, action);\\n  updateWorkInProgressHook();\\n  stateHook = stateHook.memoizedState;\\n  currentStateHook = updateWorkInProgressHook();\\n  var dispatch = currentStateHook.queue.dispatch;\\n  currentStateHook.memoizedState = action;\\n  return [stateHook, dispatch, !1];\\n}\\nfunction pushSimpleEffect(tag, inst, create, createDeps) {\\n  tag = { tag: tag, create: create, deps: createDeps, inst: inst, next: null };\\n  inst = currentlyRenderingFiber.updateQueue;\\n  null === inst &&\\n    ((inst = createFunctionComponentUpdateQueue()),\\n    (currentlyRenderingFiber.updateQueue = inst));\\n  create = inst.lastEffect;\\n  null === create\\n    ? (inst.lastEffect = tag.next = tag)\\n    : ((createDeps = create.next),\\n      (create.next = tag),\\n      (tag.next = createDeps),\\n      (inst.lastEffect = tag));\\n  return tag;\\n}\\nfunction createEffectInstance() {\\n  return { destroy: void 0, resource: void 0 };\\n}\\nfunction updateRef() {\\n  return updateWorkInProgressHook().memoizedState;\\n}\\nfunction mountEffectImpl(fiberFlags, hookFlags, create, createDeps) {\\n  var hook = mountWorkInProgressHook();\\n  createDeps = void 0 === createDeps ? null : createDeps;\\n  currentlyRenderingFiber.flags |= fiberFlags;\\n  hook.memoizedState = pushSimpleEffect(\\n    1 | hookFlags,\\n    createEffectInstance(),\\n    create,\\n    createDeps\\n  );\\n}\\nfunction updateEffectImpl(fiberFlags, hookFlags, create, deps) {\\n  var hook = updateWorkInProgressHook();\\n  deps = void 0 === deps ? null : deps;\\n  var inst = hook.memoizedState.inst;\\n  null !== currentHook &&\\n  null !== deps &&\\n  areHookInputsEqual(deps, currentHook.memoizedState.deps)\\n    ? (hook.memoizedState = pushSimpleEffect(hookFlags, inst, create, deps))\\n    : ((currentlyRenderingFiber.flags |= fiberFlags),\\n      (hook.memoizedState = pushSimpleEffect(\\n        1 | hookFlags,\\n        inst,\\n        create,\\n        deps\\n      )));\\n}\\nfunction mountEffect(create, createDeps) {\\n  mountEffectImpl(8390656, 8, create, createDeps);\\n}\\nfunction updateEffect(create, createDeps) {\\n  updateEffectImpl(2048, 8, create, createDeps);\\n}\\nfunction updateInsertionEffect(create, deps) {\\n  return updateEffectImpl(4, 2, create, deps);\\n}\\nfunction updateLayoutEffect(create, deps) {\\n  return updateEffectImpl(4, 4, create, deps);\\n}\\nfunction imperativeHandleEffect(create, ref) {\\n  if (\"function\" === typeof ref) {\\n    create = create();\\n    var refCleanup = ref(create);\\n    return function () {\\n      \"function\" === typeof refCleanup ? refCleanup() : ref(null);\\n    };\\n  }\\n  if (null !== ref && void 0 !== ref)\\n    return (\\n      (create = create()),\\n      (ref.current = create),\\n      function () {\\n        ref.current = null;\\n      }\\n    );\\n}\\nfunction updateImperativeHandle(ref, create, deps) {\\n  deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;\\n  updateEffectImpl(4, 4, imperativeHandleEffect.bind(null, create, ref), deps);\\n}\\nfunction mountDebugValue() {}\\nfunction updateCallback(callback, deps) {\\n  var hook = updateWorkInProgressHook();\\n  deps = void 0 === deps ? null : deps;\\n  var prevState = hook.memoizedState;\\n  if (null !== deps && areHookInputsEqual(deps, prevState[1]))\\n    return prevState[0];\\n  hook.memoizedState = [callback, deps];\\n  return callback;\\n}\\nfunction updateMemo(nextCreate, deps) {\\n  var hook = updateWorkInProgressHook();\\n  deps = void 0 === deps ? null : deps;\\n  var prevState = hook.memoizedState;\\n  if (null !== deps && areHookInputsEqual(deps, prevState[1]))\\n    return prevState[0];\\n  prevState = nextCreate();\\n  if (shouldDoubleInvokeUserFnsInHooksDEV) {\\n    setIsStrictModeForDevtools(!0);\\n    try {\\n      nextCreate();\\n    } finally {\\n      setIsStrictModeForDevtools(!1);\\n    }\\n  }\\n  hook.memoizedState = [prevState, deps];\\n  return prevState;\\n}\\nfunction mountDeferredValueImpl(hook, value, initialValue) {\\n  if (void 0 === initialValue || 0 !== (renderLanes & 1073741824))\\n    return (hook.memoizedState = value);\\n  hook.memoizedState = initialValue;\\n  hook = requestDeferredLane();\\n  currentlyRenderingFiber.lanes |= hook;\\n  workInProgressRootSkippedLanes |= hook;\\n  return initialValue;\\n}\\nfunction updateDeferredValueImpl(hook, prevValue, value, initialValue) {\\n  if (objectIs(value, prevValue)) return value;\\n  if (null !== currentTreeHiddenStackCursor.current)\\n    return (\\n      (hook = mountDeferredValueImpl(hook, value, initialValue)),\\n      objectIs(hook, prevValue) || (didReceiveUpdate = !0),\\n      hook\\n    );\\n  if (0 === (renderLanes & 42))\\n    return (didReceiveUpdate = !0), (hook.memoizedState = value);\\n  hook = requestDeferredLane();\\n  currentlyRenderingFiber.lanes |= hook;\\n  workInProgressRootSkippedLanes |= hook;\\n  return prevValue;\\n}\\nfunction startTransition(fiber, queue, pendingState, finishedState, callback) {\\n  var previousPriority = ReactDOMSharedInternals.p;\\n  ReactDOMSharedInternals.p =\\n    0 !== previousPriority && 8 > previousPriority ? previousPriority : 8;\\n  var prevTransition = ReactSharedInternals.T,\\n    currentTransition = {};\\n  ReactSharedInternals.T = currentTransition;\\n  dispatchOptimisticSetState(fiber, !1, queue, pendingState);\\n  try {\\n    var returnValue = callback(),\\n      onStartTransitionFinish = ReactSharedInternals.S;\\n    null !== onStartTransitionFinish &&\\n      onStartTransitionFinish(currentTransition, returnValue);\\n    if (\\n      null !== returnValue &&\\n      \"object\" === typeof returnValue &&\\n      \"function\" === typeof returnValue.then\\n    ) {\\n      var thenableForFinishedState = chainThenableValue(\\n        returnValue,\\n        finishedState\\n      );\\n      dispatchSetStateInternal(\\n        fiber,\\n        queue,\\n        thenableForFinishedState,\\n        requestUpdateLane(fiber)\\n      );\\n    } else\\n      dispatchSetStateInternal(\\n        fiber,\\n        queue,\\n        finishedState,\\n        requestUpdateLane(fiber)\\n      );\\n  } catch (error) {\\n    dispatchSetStateInternal(\\n      fiber,\\n      queue,\\n      { then: function () {}, status: \"rejected\", reason: error },\\n      requestUpdateLane()\\n    );\\n  } finally {\\n    (ReactDOMSharedInternals.p = previousPriority),\\n      (ReactSharedInternals.T = prevTransition);\\n  }\\n}\\nfunction noop$2() {}\\nfunction startHostTransition(formFiber, pendingState, action, formData) {\\n  if (5 !== formFiber.tag) throw Error(formatProdErrorMessage(476));\\n  var queue = ensureFormComponentIsStateful(formFiber).queue;\\n  startTransition(\\n    formFiber,\\n    queue,\\n    pendingState,\\n    sharedNotPendingObject,\\n    null === action\\n      ? noop$2\\n      : function () {\\n          requestFormReset$1(formFiber);\\n          return action(formData);\\n        }\\n  );\\n}\\nfunction ensureFormComponentIsStateful(formFiber) {\\n  var existingStateHook = formFiber.memoizedState;\\n  if (null !== existingStateHook) return existingStateHook;\\n  existingStateHook = {\\n    memoizedState: sharedNotPendingObject,\\n    baseState: sharedNotPendingObject,\\n    baseQueue: null,\\n    queue: {\\n      pending: null,\\n      lanes: 0,\\n      dispatch: null,\\n      lastRenderedReducer: basicStateReducer,\\n      lastRenderedState: sharedNotPendingObject\\n    },\\n    next: null\\n  };\\n  var initialResetState = {};\\n  existingStateHook.next = {\\n    memoizedState: initialResetState,\\n    baseState: initialResetState,\\n    baseQueue: null,\\n    queue: {\\n      pending: null,\\n      lanes: 0,\\n      dispatch: null,\\n      lastRenderedReducer: basicStateReducer,\\n      lastRenderedState: initialResetState\\n    },\\n    next: null\\n  };\\n  formFiber.memoizedState = existingStateHook;\\n  formFiber = formFiber.alternate;\\n  null !== formFiber && (formFiber.memoizedState = existingStateHook);\\n  return existingStateHook;\\n}\\nfunction requestFormReset$1(formFiber) {\\n  var resetStateQueue = ensureFormComponentIsStateful(formFiber).next.queue;\\n  dispatchSetStateInternal(formFiber, resetStateQueue, {}, requestUpdateLane());\\n}\\nfunction useHostTransitionStatus() {\\n  return readContext(HostTransitionContext);\\n}\\nfunction updateId() {\\n  return updateWorkInProgressHook().memoizedState;\\n}\\nfunction updateRefresh() {\\n  return updateWorkInProgressHook().memoizedState;\\n}\\nfunction refreshCache(fiber) {\\n  for (var provider = fiber.return; null !== provider; ) {\\n    switch (provider.tag) {\\n      case 24:\\n      case 3:\\n        var lane = requestUpdateLane();\\n        fiber = createUpdate(lane);\\n        var root$41 = enqueueUpdate(provider, fiber, lane);\\n        null !== root$41 &&\\n          (scheduleUpdateOnFiber(root$41, provider, lane),\\n          entangleTransitions(root$41, provider, lane));\\n        provider = { cache: createCache() };\\n        fiber.payload = provider;\\n        return;\\n    }\\n    provider = provider.return;\\n  }\\n}\\nfunction dispatchReducerAction(fiber, queue, action) {\\n  var lane = requestUpdateLane();\\n  action = {\\n    lane: lane,\\n    revertLane: 0,\\n    action: action,\\n    hasEagerState: !1,\\n    eagerState: null,\\n    next: null\\n  };\\n  isRenderPhaseUpdate(fiber)\\n    ? enqueueRenderPhaseUpdate(queue, action)\\n    : ((action = enqueueConcurrentHookUpdate(fiber, queue, action, lane)),\\n      null !== action &&\\n        (scheduleUpdateOnFiber(action, fiber, lane),\\n        entangleTransitionUpdate(action, queue, lane)));\\n}\\nfunction dispatchSetState(fiber, queue, action) {\\n  var lane = requestUpdateLane();\\n  dispatchSetStateInternal(fiber, queue, action, lane);\\n}\\nfunction dispatchSetStateInternal(fiber, queue, action, lane) {\\n  var update = {\\n    lane: lane,\\n    revertLane: 0,\\n    action: action,\\n    hasEagerState: !1,\\n    eagerState: null,\\n    next: null\\n  };\\n  if (isRenderPhaseUpdate(fiber)) enqueueRenderPhaseUpdate(queue, update);\\n  else {\\n    var alternate = fiber.alternate;\\n    if (\\n      0 === fiber.lanes &&\\n      (null === alternate || 0 === alternate.lanes) &&\\n      ((alternate = queue.lastRenderedReducer), null !== alternate)\\n    )\\n      try {\\n        var currentState = queue.lastRenderedState,\\n          eagerState = alternate(currentState, action);\\n        update.hasEagerState = !0;\\n        update.eagerState = eagerState;\\n        if (objectIs(eagerState, currentState))\\n          return (\\n            enqueueUpdate$1(fiber, queue, update, 0),\\n            null === workInProgressRoot && finishQueueingConcurrentUpdates(),\\n            !1\\n          );\\n      } catch (error) {\\n      } finally {\\n      }\\n    action = enqueueConcurrentHookUpdate(fiber, queue, update, lane);\\n    if (null !== action)\\n      return (\\n        scheduleUpdateOnFiber(action, fiber, lane),\\n        entangleTransitionUpdate(action, queue, lane),\\n        !0\\n      );\\n  }\\n  return !1;\\n}\\nfunction dispatchOptimisticSetState(fiber, throwIfDuringRender, queue, action) {\\n  action = {\\n    lane: 2,\\n    revertLane: requestTransitionLane(),\\n    action: action,\\n    hasEagerState: !1,\\n    eagerState: null,\\n    next: null\\n  };\\n  if (isRenderPhaseUpdate(fiber)) {\\n    if (throwIfDuringRender) throw Error(formatProdErrorMessage(479));\\n  } else\\n    (throwIfDuringRender = enqueueConcurrentHookUpdate(\\n      fiber,\\n      queue,\\n      action,\\n      2\\n    )),\\n      null !== throwIfDuringRender &&\\n        scheduleUpdateOnFiber(throwIfDuringRender, fiber, 2);\\n}\\nfunction isRenderPhaseUpdate(fiber) {\\n  var alternate = fiber.alternate;\\n  return (\\n    fiber === currentlyRenderingFiber ||\\n    (null !== alternate && alternate === currentlyRenderingFiber)\\n  );\\n}\\nfunction enqueueRenderPhaseUpdate(queue, update) {\\n  didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate =\\n    !0;\\n  var pending = queue.pending;\\n  null === pending\\n    ? (update.next = update)\\n    : ((update.next = pending.next), (pending.next = update));\\n  queue.pending = update;\\n}\\nfunction entangleTransitionUpdate(root, queue, lane) {\\n  if (0 !== (lane & 4194048)) {\\n    var queueLanes = queue.lanes;\\n    queueLanes &= root.pendingLanes;\\n    lane |= queueLanes;\\n    queue.lanes = lane;\\n    markRootEntangled(root, lane);\\n  }\\n}\\nvar ContextOnlyDispatcher = {\\n    readContext: readContext,\\n    use: use,\\n    useCallback: throwInvalidHookError,\\n    useContext: throwInvalidHookError,\\n    useEffect: throwInvalidHookError,\\n    useImperativeHandle: throwInvalidHookError,\\n    useLayoutEffect: throwInvalidHookError,\\n    useInsertionEffect: throwInvalidHookError,\\n    useMemo: throwInvalidHookError,\\n    useReducer: throwInvalidHookError,\\n    useRef: throwInvalidHookError,\\n    useState: throwInvalidHookError,\\n    useDebugValue: throwInvalidHookError,\\n    useDeferredValue: throwInvalidHookError,\\n    useTransition: throwInvalidHookError,\\n    useSyncExternalStore: throwInvalidHookError,\\n    useId: throwInvalidHookError,\\n    useHostTransitionStatus: throwInvalidHookError,\\n    useFormState: throwInvalidHookError,\\n    useActionState: throwInvalidHookError,\\n    useOptimistic: throwInvalidHookError,\\n    useMemoCache: throwInvalidHookError,\\n    useCacheRefresh: throwInvalidHookError\\n  },\\n  HooksDispatcherOnMount = {\\n    readContext: readContext,\\n    use: use,\\n    useCallback: function (callback, deps) {\\n      mountWorkInProgressHook().memoizedState = [\\n        callback,\\n        void 0 === deps ? null : deps\\n      ];\\n      return callback;\\n    },\\n    useContext: readContext,\\n    useEffect: mountEffect,\\n    useImperativeHandle: function (ref, create, deps) {\\n      deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;\\n      mountEffectImpl(\\n        4194308,\\n        4,\\n        imperativeHandleEffect.bind(null, create, ref),\\n        deps\\n      );\\n    },\\n    useLayoutEffect: function (create, deps) {\\n      return mountEffectImpl(4194308, 4, create, deps);\\n    },\\n    useInsertionEffect: function (create, deps) {\\n      mountEffectImpl(4, 2, create, deps);\\n    },\\n    useMemo: function (nextCreate, deps) {\\n      var hook = mountWorkInProgressHook();\\n      deps = void 0 === deps ? null : deps;\\n      var nextValue = nextCreate();\\n      if (shouldDoubleInvokeUserFnsInHooksDEV) {\\n        setIsStrictModeForDevtools(!0);\\n        try {\\n          nextCreate();\\n        } finally {\\n          setIsStrictModeForDevtools(!1);\\n        }\\n      }\\n      hook.memoizedState = [nextValue, deps];\\n      return nextValue;\\n    },\\n    useReducer: function (reducer, initialArg, init) {\\n      var hook = mountWorkInProgressHook();\\n      if (void 0 !== init) {\\n        var initialState = init(initialArg);\\n        if (shouldDoubleInvokeUserFnsInHooksDEV) {\\n          setIsStrictModeForDevtools(!0);\\n          try {\\n            init(initialArg);\\n          } finally {\\n            setIsStrictModeForDevtools(!1);\\n          }\\n        }\\n      } else initialState = initialArg;\\n      hook.memoizedState = hook.baseState = initialState;\\n      reducer = {\\n        pending: null,\\n        lanes: 0,\\n        dispatch: null,\\n        lastRenderedReducer: reducer,\\n        lastRenderedState: initialState\\n      };\\n      hook.queue = reducer;\\n      reducer = reducer.dispatch = dispatchReducerAction.bind(\\n        null,\\n        currentlyRenderingFiber,\\n        reducer\\n      );\\n      return [hook.memoizedState, reducer];\\n    },\\n    useRef: function (initialValue) {\\n      var hook = mountWorkInProgressHook();\\n      initialValue = { current: initialValue };\\n      return (hook.memoizedState = initialValue);\\n    },\\n    useState: function (initialState) {\\n      initialState = mountStateImpl(initialState);\\n      var queue = initialState.queue,\\n        dispatch = dispatchSetState.bind(null, currentlyRenderingFiber, queue);\\n      queue.dispatch = dispatch;\\n      return [initialState.memoizedState, dispatch];\\n    },\\n    useDebugValue: mountDebugValue,\\n    useDeferredValue: function (value, initialValue) {\\n      var hook = mountWorkInProgressHook();\\n      return mountDeferredValueImpl(hook, value, initialValue);\\n    },\\n    useTransition: function () {\\n      var stateHook = mountStateImpl(!1);\\n      stateHook = startTransition.bind(\\n        null,\\n        currentlyRenderingFiber,\\n        stateHook.queue,\\n        !0,\\n        !1\\n      );\\n      mountWorkInProgressHook().memoizedState = stateHook;\\n      return [!1, stateHook];\\n    },\\n    useSyncExternalStore: function (subscribe, getSnapshot, getServerSnapshot) {\\n      var fiber = currentlyRenderingFiber,\\n        hook = mountWorkInProgressHook();\\n      if (isHydrating) {\\n        if (void 0 === getServerSnapshot)\\n          throw Error(formatProdErrorMessage(407));\\n        getServerSnapshot = getServerSnapshot();\\n      } else {\\n        getServerSnapshot = getSnapshot();\\n        if (null === workInProgressRoot)\\n          throw Error(formatProdErrorMessage(349));\\n        0 !== (workInProgressRootRenderLanes & 124) ||\\n          pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);\\n      }\\n      hook.memoizedState = getServerSnapshot;\\n      var inst = { value: getServerSnapshot, getSnapshot: getSnapshot };\\n      hook.queue = inst;\\n      mountEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [\\n        subscribe\\n      ]);\\n      fiber.flags |= 2048;\\n      pushSimpleEffect(\\n        9,\\n        createEffectInstance(),\\n        updateStoreInstance.bind(\\n          null,\\n          fiber,\\n          inst,\\n          getServerSnapshot,\\n          getSnapshot\\n        ),\\n        null\\n      );\\n      return getServerSnapshot;\\n    },\\n    useId: function () {\\n      var hook = mountWorkInProgressHook(),\\n        identifierPrefix = workInProgressRoot.identifierPrefix;\\n      if (isHydrating) {\\n        var JSCompiler_inline_result = treeContextOverflow;\\n        var idWithLeadingBit = treeContextId;\\n        JSCompiler_inline_result =\\n          (\\n            idWithLeadingBit & ~(1 << (32 - clz32(idWithLeadingBit) - 1))\\n          ).toString(32) + JSCompiler_inline_result;\\n        identifierPrefix =\\n          \"\\\\u00ab\" + identifierPrefix + \"R\" + JSCompiler_inline_result;\\n        JSCompiler_inline_result = localIdCounter++;\\n        0 < JSCompiler_inline_result &&\\n          (identifierPrefix += \"H\" + JSCompiler_inline_result.toString(32));\\n        identifierPrefix += \"\\\\u00bb\";\\n      } else\\n        (JSCompiler_inline_result = globalClientIdCounter++),\\n          (identifierPrefix =\\n            \"\\\\u00ab\" +\\n            identifierPrefix +\\n            \"r\" +\\n            JSCompiler_inline_result.toString(32) +\\n            \"\\\\u00bb\");\\n      return (hook.memoizedState = identifierPrefix);\\n    },\\n    useHostTransitionStatus: useHostTransitionStatus,\\n    useFormState: mountActionState,\\n    useActionState: mountActionState,\\n    useOptimistic: function (passthrough) {\\n      var hook = mountWorkInProgressHook();\\n      hook.memoizedState = hook.baseState = passthrough;\\n      var queue = {\\n        pending: null,\\n        lanes: 0,\\n        dispatch: null,\\n        lastRenderedReducer: null,\\n        lastRenderedState: null\\n      };\\n      hook.queue = queue;\\n      hook = dispatchOptimisticSetState.bind(\\n        null,\\n        currentlyRenderingFiber,\\n        !0,\\n        queue\\n      );\\n      queue.dispatch = hook;\\n      return [passthrough, hook];\\n    },\\n    useMemoCache: useMemoCache,\\n    useCacheRefresh: function () {\\n      return (mountWorkInProgressHook().memoizedState = refreshCache.bind(\\n        null,\\n        currentlyRenderingFiber\\n      ));\\n    }\\n  },\\n  HooksDispatcherOnUpdate = {\\n    readContext: readContext,\\n    use: use,\\n    useCallback: updateCallback,\\n    useContext: readContext,\\n    useEffect: updateEffect,\\n    useImperativeHandle: updateImperativeHandle,\\n    useInsertionEffect: updateInsertionEffect,\\n    useLayoutEffect: updateLayoutEffect,\\n    useMemo: updateMemo,\\n    useReducer: updateReducer,\\n    useRef: updateRef,\\n    useState: function () {\\n      return updateReducer(basicStateReducer);\\n    },\\n    useDebugValue: mountDebugValue,\\n    useDeferredValue: function (value, initialValue) {\\n      var hook = updateWorkInProgressHook();\\n      return updateDeferredValueImpl(\\n        hook,\\n        currentHook.memoizedState,\\n        value,\\n        initialValue\\n      );\\n    },\\n    useTransition: function () {\\n      var booleanOrThenable = updateReducer(basicStateReducer)[0],\\n        start = updateWorkInProgressHook().memoizedState;\\n      return [\\n        \"boolean\" === typeof booleanOrThenable\\n          ? booleanOrThenable\\n          : useThenable(booleanOrThenable),\\n        start\\n      ];\\n    },\\n    useSyncExternalStore: updateSyncExternalStore,\\n    useId: updateId,\\n    useHostTransitionStatus: useHostTransitionStatus,\\n    useFormState: updateActionState,\\n    useActionState: updateActionState,\\n    useOptimistic: function (passthrough, reducer) {\\n      var hook = updateWorkInProgressHook();\\n      return updateOptimisticImpl(hook, currentHook, passthrough, reducer);\\n    },\\n    useMemoCache: useMemoCache,\\n    useCacheRefresh: updateRefresh\\n  },\\n  HooksDispatcherOnRerender = {\\n    readContext: readContext,\\n    use: use,\\n    useCallback: updateCallback,\\n    useContext: readContext,\\n    useEffect: updateEffect,\\n    useImperativeHandle: updateImperativeHandle,\\n    useInsertionEffect: updateInsertionEffect,\\n    useLayoutEffect: updateLayoutEffect,\\n    useMemo: updateMemo,\\n    useReducer: rerenderReducer,\\n    useRef: updateRef,\\n    useState: function () {\\n      return rerenderReducer(basicStateReducer);\\n    },\\n    useDebugValue: mountDebugValue,\\n    useDeferredValue: function (value, initialValue) {\\n      var hook = updateWorkInProgressHook();\\n      return null === currentHook\\n        ? mountDeferredValueImpl(hook, value, initialValue)\\n        : updateDeferredValueImpl(\\n            hook,\\n            currentHook.memoizedState,\\n            value,\\n            initialValue\\n          );\\n    },\\n    useTransition: function () {\\n      var booleanOrThenable = rerenderReducer(basicStateReducer)[0],\\n        start = updateWorkInProgressHook().memoizedState;\\n      return [\\n        \"boolean\" === typeof booleanOrThenable\\n          ? booleanOrThenable\\n          : useThenable(booleanOrThenable),\\n        start\\n      ];\\n    },\\n    useSyncExternalStore: updateSyncExternalStore,\\n    useId: updateId,\\n    useHostTransitionStatus: useHostTransitionStatus,\\n    useFormState: rerenderActionState,\\n    useActionState: rerenderActionState,\\n    useOptimistic: function (passthrough, reducer) {\\n      var hook = updateWorkInProgressHook();\\n      if (null !== currentHook)\\n        return updateOptimisticImpl(hook, currentHook, passthrough, reducer);\\n      hook.baseState = passthrough;\\n      return [passthrough, hook.queue.dispatch];\\n    },\\n    useMemoCache: useMemoCache,\\n    useCacheRefresh: updateRefresh\\n  },\\n  thenableState = null,\\n  thenableIndexCounter = 0;\\nfunction unwrapThenable(thenable) {\\n  var index = thenableIndexCounter;\\n  thenableIndexCounter += 1;\\n  null === thenableState && (thenableState = []);\\n  return trackUsedThenable(thenableState, thenable, index);\\n}\\nfunction coerceRef(workInProgress, element) {\\n  element = element.props.ref;\\n  workInProgress.ref = void 0 !== element ? element : null;\\n}\\nfunction throwOnInvalidObjectType(returnFiber, newChild) {\\n  if (newChild.$$typeof === REACT_LEGACY_ELEMENT_TYPE)\\n    throw Error(formatProdErrorMessage(525));\\n  returnFiber = Object.prototype.toString.call(newChild);\\n  throw Error(\\n    formatProdErrorMessage(\\n      31,\\n      \"[object Object]\" === returnFiber\\n        ? \"object with keys {\" + Object.keys(newChild).join(\", \") + \"}\"\\n        : returnFiber\\n    )\\n  );\\n}\\nfunction resolveLazy(lazyType) {\\n  var init = lazyType._init;\\n  return init(lazyType._payload);\\n}\\nfunction createChildReconciler(shouldTrackSideEffects) {\\n  function deleteChild(returnFiber, childToDelete) {\\n    if (shouldTrackSideEffects) {\\n      var deletions = returnFiber.deletions;\\n      null === deletions\\n        ? ((returnFiber.deletions = [childToDelete]), (returnFiber.flags |= 16))\\n        : deletions.push(childToDelete);\\n    }\\n  }\\n  function deleteRemainingChildren(returnFiber, currentFirstChild) {\\n    if (!shouldTrackSideEffects) return null;\\n    for (; null !== currentFirstChild; )\\n      deleteChild(returnFiber, currentFirstChild),\\n        (currentFirstChild = currentFirstChild.sibling);\\n    return null;\\n  }\\n  function mapRemainingChildren(currentFirstChild) {\\n    for (var existingChildren = new Map(); null !== currentFirstChild; )\\n      null !== currentFirstChild.key\\n        ? existingChildren.set(currentFirstChild.key, currentFirstChild)\\n        : existingChildren.set(currentFirstChild.index, currentFirstChild),\\n        (currentFirstChild = currentFirstChild.sibling);\\n    return existingChildren;\\n  }\\n  function useFiber(fiber, pendingProps) {\\n    fiber = createWorkInProgress(fiber, pendingProps);\\n    fiber.index = 0;\\n    fiber.sibling = null;\\n    return fiber;\\n  }\\n  function placeChild(newFiber, lastPlacedIndex, newIndex) {\\n    newFiber.index = newIndex;\\n    if (!shouldTrackSideEffects)\\n      return (newFiber.flags |= 1048576), lastPlacedIndex;\\n    newIndex = newFiber.alternate;\\n    if (null !== newIndex)\\n      return (\\n        (newIndex = newIndex.index),\\n        newIndex < lastPlacedIndex\\n          ? ((newFiber.flags |= 67108866), lastPlacedIndex)\\n          : newIndex\\n      );\\n    newFiber.flags |= 67108866;\\n    return lastPlacedIndex;\\n  }\\n  function placeSingleChild(newFiber) {\\n    shouldTrackSideEffects &&\\n      null === newFiber.alternate &&\\n      (newFiber.flags |= 67108866);\\n    return newFiber;\\n  }\\n  function updateTextNode(returnFiber, current, textContent, lanes) {\\n    if (null === current || 6 !== current.tag)\\n      return (\\n        (current = createFiberFromText(textContent, returnFiber.mode, lanes)),\\n        (current.return = returnFiber),\\n        current\\n      );\\n    current = useFiber(current, textContent);\\n    current.return = returnFiber;\\n    return current;\\n  }\\n  function updateElement(returnFiber, current, element, lanes) {\\n    var elementType = element.type;\\n    if (elementType === REACT_FRAGMENT_TYPE)\\n      return updateFragment(\\n        returnFiber,\\n        current,\\n        element.props.children,\\n        lanes,\\n        element.key\\n      );\\n    if (\\n      null !== current &&\\n      (current.elementType === elementType ||\\n        (\"object\" === typeof elementType &&\\n          null !== elementType &&\\n          elementType.$$typeof === REACT_LAZY_TYPE &&\\n          resolveLazy(elementType) === current.type))\\n    )\\n      return (\\n        (current = useFiber(current, element.props)),\\n        coerceRef(current, element),\\n        (current.return = returnFiber),\\n        current\\n      );\\n    current = createFiberFromTypeAndProps(\\n      element.type,\\n      element.key,\\n      element.props,\\n      null,\\n      returnFiber.mode,\\n      lanes\\n    );\\n    coerceRef(current, element);\\n    current.return = returnFiber;\\n    return current;\\n  }\\n  function updatePortal(returnFiber, current, portal, lanes) {\\n    if (\\n      null === current ||\\n      4 !== current.tag ||\\n      current.stateNode.containerInfo !== portal.containerInfo ||\\n      current.stateNode.implementation !== portal.implementation\\n    )\\n      return (\\n        (current = createFiberFromPortal(portal, returnFiber.mode, lanes)),\\n        (current.return = returnFiber),\\n        current\\n      );\\n    current = useFiber(current, portal.children || []);\\n    current.return = returnFiber;\\n    return current;\\n  }\\n  function updateFragment(returnFiber, current, fragment, lanes, key) {\\n    if (null === current || 7 !== current.tag)\\n      return (\\n        (current = createFiberFromFragment(\\n          fragment,\\n          returnFiber.mode,\\n          lanes,\\n          key\\n        )),\\n        (current.return = returnFiber),\\n        current\\n      );\\n    current = useFiber(current, fragment);\\n    current.return = returnFiber;\\n    return current;\\n  }\\n  function createChild(returnFiber, newChild, lanes) {\\n    if (\\n      (\"string\" === typeof newChild && \"\" !== newChild) ||\\n      \"number\" === typeof newChild ||\\n      \"bigint\" === typeof newChild\\n    )\\n      return (\\n        (newChild = createFiberFromText(\\n          \"\" + newChild,\\n          returnFiber.mode,\\n          lanes\\n        )),\\n        (newChild.return = returnFiber),\\n        newChild\\n      );\\n    if (\"object\" === typeof newChild && null !== newChild) {\\n      switch (newChild.$$typeof) {\\n        case REACT_ELEMENT_TYPE:\\n          return (\\n            (lanes = createFiberFromTypeAndProps(\\n              newChild.type,\\n              newChild.key,\\n              newChild.props,\\n              null,\\n              returnFiber.mode,\\n              lanes\\n            )),\\n            coerceRef(lanes, newChild),\\n            (lanes.return = returnFiber),\\n            lanes\\n          );\\n        case REACT_PORTAL_TYPE:\\n          return (\\n            (newChild = createFiberFromPortal(\\n              newChild,\\n              returnFiber.mode,\\n              lanes\\n            )),\\n            (newChild.return = returnFiber),\\n            newChild\\n          );\\n        case REACT_LAZY_TYPE:\\n          var init = newChild._init;\\n          newChild = init(newChild._payload);\\n          return createChild(returnFiber, newChild, lanes);\\n      }\\n      if (isArrayImpl(newChild) || getIteratorFn(newChild))\\n        return (\\n          (newChild = createFiberFromFragment(\\n            newChild,\\n            returnFiber.mode,\\n            lanes,\\n            null\\n          )),\\n          (newChild.return = returnFiber),\\n          newChild\\n        );\\n      if (\"function\" === typeof newChild.then)\\n        return createChild(returnFiber, unwrapThenable(newChild), lanes);\\n      if (newChild.$$typeof === REACT_CONTEXT_TYPE)\\n        return createChild(\\n          returnFiber,\\n          readContextDuringReconciliation(returnFiber, newChild),\\n          lanes\\n        );\\n      throwOnInvalidObjectType(returnFiber, newChild);\\n    }\\n    return null;\\n  }\\n  function updateSlot(returnFiber, oldFiber, newChild, lanes) {\\n    var key = null !== oldFiber ? oldFiber.key : null;\\n    if (\\n      (\"string\" === typeof newChild && \"\" !== newChild) ||\\n      \"number\" === typeof newChild ||\\n      \"bigint\" === typeof newChild\\n    )\\n      return null !== key\\n        ? null\\n        : updateTextNode(returnFiber, oldFiber, \"\" + newChild, lanes);\\n    if (\"object\" === typeof newChild && null !== newChild) {\\n      switch (newChild.$$typeof) {\\n        case REACT_ELEMENT_TYPE:\\n          return newChild.key === key\\n            ? updateElement(returnFiber, oldFiber, newChild, lanes)\\n            : null;\\n        case REACT_PORTAL_TYPE:\\n          return newChild.key === key\\n            ? updatePortal(returnFiber, oldFiber, newChild, lanes)\\n            : null;\\n        case REACT_LAZY_TYPE:\\n          return (\\n            (key = newChild._init),\\n            (newChild = key(newChild._payload)),\\n            updateSlot(returnFiber, oldFiber, newChild, lanes)\\n          );\\n      }\\n      if (isArrayImpl(newChild) || getIteratorFn(newChild))\\n        return null !== key\\n          ? null\\n          : updateFragment(returnFiber, oldFiber, newChild, lanes, null);\\n      if (\"function\" === typeof newChild.then)\\n        return updateSlot(\\n          returnFiber,\\n          oldFiber,\\n          unwrapThenable(newChild),\\n          lanes\\n        );\\n      if (newChild.$$typeof === REACT_CONTEXT_TYPE)\\n        return updateSlot(\\n          returnFiber,\\n          oldFiber,\\n          readContextDuringReconciliation(returnFiber, newChild),\\n          lanes\\n        );\\n      throwOnInvalidObjectType(returnFiber, newChild);\\n    }\\n    return null;\\n  }\\n  function updateFromMap(\\n    existingChildren,\\n    returnFiber,\\n    newIdx,\\n    newChild,\\n    lanes\\n  ) {\\n    if (\\n      (\"string\" === typeof newChild && \"\" !== newChild) ||\\n      \"number\" === typeof newChild ||\\n      \"bigint\" === typeof newChild\\n    )\\n      return (\\n        (existingChildren = existingChildren.get(newIdx) || null),\\n        updateTextNode(returnFiber, existingChildren, \"\" + newChild, lanes)\\n      );\\n    if (\"object\" === typeof newChild && null !== newChild) {\\n      switch (newChild.$$typeof) {\\n        case REACT_ELEMENT_TYPE:\\n          return (\\n            (existingChildren =\\n              existingChildren.get(\\n                null === newChild.key ? newIdx : newChild.key\\n              ) || null),\\n            updateElement(returnFiber, existingChildren, newChild, lanes)\\n          );\\n        case REACT_PORTAL_TYPE:\\n          return (\\n            (existingChildren =\\n              existingChildren.get(\\n                null === newChild.key ? newIdx : newChild.key\\n              ) || null),\\n            updatePortal(returnFiber, existingChildren, newChild, lanes)\\n          );\\n        case REACT_LAZY_TYPE:\\n          var init = newChild._init;\\n          newChild = init(newChild._payload);\\n          return updateFromMap(\\n            existingChildren,\\n            returnFiber,\\n            newIdx,\\n            newChild,\\n            lanes\\n          );\\n      }\\n      if (isArrayImpl(newChild) || getIteratorFn(newChild))\\n        return (\\n          (existingChildren = existingChildren.get(newIdx) || null),\\n          updateFragment(returnFiber, existingChildren, newChild, lanes, null)\\n        );\\n      if (\"function\" === typeof newChild.then)\\n        return updateFromMap(\\n          existingChildren,\\n          returnFiber,\\n          newIdx,\\n          unwrapThenable(newChild),\\n          lanes\\n        );\\n      if (newChild.$$typeof === REACT_CONTEXT_TYPE)\\n        return updateFromMap(\\n          existingChildren,\\n          returnFiber,\\n          newIdx,\\n          readContextDuringReconciliation(returnFiber, newChild),\\n          lanes\\n        );\\n      throwOnInvalidObjectType(returnFiber, newChild);\\n    }\\n    return null;\\n  }\\n  function reconcileChildrenArray(\\n    returnFiber,\\n    currentFirstChild,\\n    newChildren,\\n    lanes\\n  ) {\\n    for (\\n      var resultingFirstChild = null,\\n        previousNewFiber = null,\\n        oldFiber = currentFirstChild,\\n        newIdx = (currentFirstChild = 0),\\n        nextOldFiber = null;\\n      null !== oldFiber && newIdx < newChildren.length;\\n      newIdx++\\n    ) {\\n      oldFiber.index > newIdx\\n        ? ((nextOldFiber = oldFiber), (oldFiber = null))\\n        : (nextOldFiber = oldFiber.sibling);\\n      var newFiber = updateSlot(\\n        returnFiber,\\n        oldFiber,\\n        newChildren[newIdx],\\n        lanes\\n      );\\n      if (null === newFiber) {\\n        null === oldFiber && (oldFiber = nextOldFiber);\\n        break;\\n      }\\n      shouldTrackSideEffects &&\\n        oldFiber &&\\n        null === newFiber.alternate &&\\n        deleteChild(returnFiber, oldFiber);\\n      currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);\\n      null === previousNewFiber\\n        ? (resultingFirstChild = newFiber)\\n        : (previousNewFiber.sibling = newFiber);\\n      previousNewFiber = newFiber;\\n      oldFiber = nextOldFiber;\\n    }\\n    if (newIdx === newChildren.length)\\n      return (\\n        deleteRemainingChildren(returnFiber, oldFiber),\\n        isHydrating && pushTreeFork(returnFiber, newIdx),\\n        resultingFirstChild\\n      );\\n    if (null === oldFiber) {\\n      for (; newIdx < newChildren.length; newIdx++)\\n        (oldFiber = createChild(returnFiber, newChildren[newIdx], lanes)),\\n          null !== oldFiber &&\\n            ((currentFirstChild = placeChild(\\n              oldFiber,\\n              currentFirstChild,\\n              newIdx\\n            )),\\n            null === previousNewFiber\\n              ? (resultingFirstChild = oldFiber)\\n              : (previousNewFiber.sibling = oldFiber),\\n            (previousNewFiber = oldFiber));\\n      isHydrating && pushTreeFork(returnFiber, newIdx);\\n      return resultingFirstChild;\\n    }\\n    for (\\n      oldFiber = mapRemainingChildren(oldFiber);\\n      newIdx < newChildren.length;\\n      newIdx++\\n    )\\n      (nextOldFiber = updateFromMap(\\n        oldFiber,\\n        returnFiber,\\n        newIdx,\\n        newChildren[newIdx],\\n        lanes\\n      )),\\n        null !== nextOldFiber &&\\n          (shouldTrackSideEffects &&\\n            null !== nextOldFiber.alternate &&\\n            oldFiber.delete(\\n              null === nextOldFiber.key ? newIdx : nextOldFiber.key\\n            ),\\n          (currentFirstChild = placeChild(\\n            nextOldFiber,\\n            currentFirstChild,\\n            newIdx\\n          )),\\n          null === previousNewFiber\\n            ? (resultingFirstChild = nextOldFiber)\\n            : (previousNewFiber.sibling = nextOldFiber),\\n          (previousNewFiber = nextOldFiber));\\n    shouldTrackSideEffects &&\\n      oldFiber.forEach(function (child) {\\n        return deleteChild(returnFiber, child);\\n      });\\n    isHydrating && pushTreeFork(returnFiber, newIdx);\\n    return resultingFirstChild;\\n  }\\n  function reconcileChildrenIterator(\\n    returnFiber,\\n    currentFirstChild,\\n    newChildren,\\n    lanes\\n  ) {\\n    if (null == newChildren) throw Error(formatProdErrorMessage(151));\\n    for (\\n      var resultingFirstChild = null,\\n        previousNewFiber = null,\\n        oldFiber = currentFirstChild,\\n        newIdx = (currentFirstChild = 0),\\n        nextOldFiber = null,\\n        step = newChildren.next();\\n      null !== oldFiber && !step.done;\\n      newIdx++, step = newChildren.next()\\n    ) {\\n      oldFiber.index > newIdx\\n        ? ((nextOldFiber = oldFiber), (oldFiber = null))\\n        : (nextOldFiber = oldFiber.sibling);\\n      var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);\\n      if (null === newFiber) {\\n        null === oldFiber && (oldFiber = nextOldFiber);\\n        break;\\n      }\\n      shouldTrackSideEffects &&\\n        oldFiber &&\\n        null === newFiber.alternate &&\\n        deleteChild(returnFiber, oldFiber);\\n      currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);\\n      null === previousNewFiber\\n        ? (resultingFirstChild = newFiber)\\n        : (previousNewFiber.sibling = newFiber);\\n      previousNewFiber = newFiber;\\n      oldFiber = nextOldFiber;\\n    }\\n    if (step.done)\\n      return (\\n        deleteRemainingChildren(returnFiber, oldFiber),\\n        isHydrating && pushTreeFork(returnFiber, newIdx),\\n        resultingFirstChild\\n      );\\n    if (null === oldFiber) {\\n      for (; !step.done; newIdx++, step = newChildren.next())\\n        (step = createChild(returnFiber, step.value, lanes)),\\n          null !== step &&\\n            ((currentFirstChild = placeChild(step, currentFirstChild, newIdx)),\\n            null === previousNewFiber\\n              ? (resultingFirstChild = step)\\n              : (previousNewFiber.sibling = step),\\n            (previousNewFiber = step));\\n      isHydrating && pushTreeFork(returnFiber, newIdx);\\n      return resultingFirstChild;\\n    }\\n    for (\\n      oldFiber = mapRemainingChildren(oldFiber);\\n      !step.done;\\n      newIdx++, step = newChildren.next()\\n    )\\n      (step = updateFromMap(oldFiber, returnFiber, newIdx, step.value, lanes)),\\n        null !== step &&\\n          (shouldTrackSideEffects &&\\n            null !== step.alternate &&\\n            oldFiber.delete(null === step.key ? newIdx : step.key),\\n          (currentFirstChild = placeChild(step, currentFirstChild, newIdx)),\\n          null === previousNewFiber\\n            ? (resultingFirstChild = step)\\n            : (previousNewFiber.sibling = step),\\n          (previousNewFiber = step));\\n    shouldTrackSideEffects &&\\n      oldFiber.forEach(function (child) {\\n        return deleteChild(returnFiber, child);\\n      });\\n    isHydrating && pushTreeFork(returnFiber, newIdx);\\n    return resultingFirstChild;\\n  }\\n  function reconcileChildFibersImpl(\\n    returnFiber,\\n    currentFirstChild,\\n    newChild,\\n    lanes\\n  ) {\\n    \"object\" === typeof newChild &&\\n      null !== newChild &&\\n      newChild.type === REACT_FRAGMENT_TYPE &&\\n      null === newChild.key &&\\n      (newChild = newChild.props.children);\\n    if (\"object\" === typeof newChild && null !== newChild) {\\n      switch (newChild.$$typeof) {\\n        case REACT_ELEMENT_TYPE:\\n          a: {\\n            for (var key = newChild.key; null !== currentFirstChild; ) {\\n              if (currentFirstChild.key === key) {\\n                key = newChild.type;\\n                if (key === REACT_FRAGMENT_TYPE) {\\n                  if (7 === currentFirstChild.tag) {\\n                    deleteRemainingChildren(\\n                      returnFiber,\\n                      currentFirstChild.sibling\\n                    );\\n                    lanes = useFiber(\\n                      currentFirstChild,\\n                      newChild.props.children\\n                    );\\n                    lanes.return = returnFiber;\\n                    returnFiber = lanes;\\n                    break a;\\n                  }\\n                } else if (\\n                  currentFirstChild.elementType === key ||\\n                  (\"object\" === typeof key &&\\n                    null !== key &&\\n                    key.$$typeof === REACT_LAZY_TYPE &&\\n                    resolveLazy(key) === currentFirstChild.type)\\n                ) {\\n                  deleteRemainingChildren(\\n                    returnFiber,\\n                    currentFirstChild.sibling\\n                  );\\n                  lanes = useFiber(currentFirstChild, newChild.props);\\n                  coerceRef(lanes, newChild);\\n                  lanes.return = returnFiber;\\n                  returnFiber = lanes;\\n                  break a;\\n                }\\n                deleteRemainingChildren(returnFiber, currentFirstChild);\\n                break;\\n              } else deleteChild(returnFiber, currentFirstChild);\\n              currentFirstChild = currentFirstChild.sibling;\\n            }\\n            newChild.type === REACT_FRAGMENT_TYPE\\n              ? ((lanes = createFiberFromFragment(\\n                  newChild.props.children,\\n                  returnFiber.mode,\\n                  lanes,\\n                  newChild.key\\n                )),\\n                (lanes.return = returnFiber),\\n                (returnFiber = lanes))\\n              : ((lanes = createFiberFromTypeAndProps(\\n                  newChild.type,\\n                  newChild.key,\\n                  newChild.props,\\n                  null,\\n                  returnFiber.mode,\\n                  lanes\\n                )),\\n                coerceRef(lanes, newChild),\\n                (lanes.return = returnFiber),\\n                (returnFiber = lanes));\\n          }\\n          return placeSingleChild(returnFiber);\\n        case REACT_PORTAL_TYPE:\\n          a: {\\n            for (key = newChild.key; null !== currentFirstChild; ) {\\n              if (currentFirstChild.key === key)\\n                if (\\n                  4 === currentFirstChild.tag &&\\n                  currentFirstChild.stateNode.containerInfo ===\\n                    newChild.containerInfo &&\\n                  currentFirstChild.stateNode.implementation ===\\n                    newChild.implementation\\n                ) {\\n                  deleteRemainingChildren(\\n                    returnFiber,\\n                    currentFirstChild.sibling\\n                  );\\n                  lanes = useFiber(currentFirstChild, newChild.children || []);\\n                  lanes.return = returnFiber;\\n                  returnFiber = lanes;\\n                  break a;\\n                } else {\\n                  deleteRemainingChildren(returnFiber, currentFirstChild);\\n                  break;\\n                }\\n              else deleteChild(returnFiber, currentFirstChild);\\n              currentFirstChild = currentFirstChild.sibling;\\n            }\\n            lanes = createFiberFromPortal(newChild, returnFiber.mode, lanes);\\n            lanes.return = returnFiber;\\n            returnFiber = lanes;\\n          }\\n          return placeSingleChild(returnFiber);\\n        case REACT_LAZY_TYPE:\\n          return (\\n            (key = newChild._init),\\n            (newChild = key(newChild._payload)),\\n            reconcileChildFibersImpl(\\n              returnFiber,\\n              currentFirstChild,\\n              newChild,\\n              lanes\\n            )\\n          );\\n      }\\n      if (isArrayImpl(newChild))\\n        return reconcileChildrenArray(\\n          returnFiber,\\n          currentFirstChild,\\n          newChild,\\n          lanes\\n        );\\n      if (getIteratorFn(newChild)) {\\n        key = getIteratorFn(newChild);\\n        if (\"function\" !== typeof key) throw Error(formatProdErrorMessage(150));\\n        newChild = key.call(newChild);\\n        return reconcileChildrenIterator(\\n          returnFiber,\\n          currentFirstChild,\\n          newChild,\\n          lanes\\n        );\\n      }\\n      if (\"function\" === typeof newChild.then)\\n        return reconcileChildFibersImpl(\\n          returnFiber,\\n          currentFirstChild,\\n          unwrapThenable(newChild),\\n          lanes\\n        );\\n      if (newChild.$$typeof === REACT_CONTEXT_TYPE)\\n        return reconcileChildFibersImpl(\\n          returnFiber,\\n          currentFirstChild,\\n          readContextDuringReconciliation(returnFiber, newChild),\\n          lanes\\n        );\\n      throwOnInvalidObjectType(returnFiber, newChild);\\n    }\\n    return (\"string\" === typeof newChild && \"\" !== newChild) ||\\n      \"number\" === typeof newChild ||\\n      \"bigint\" === typeof newChild\\n      ? ((newChild = \"\" + newChild),\\n        null !== currentFirstChild && 6 === currentFirstChild.tag\\n          ? (deleteRemainingChildren(returnFiber, currentFirstChild.sibling),\\n            (lanes = useFiber(currentFirstChild, newChild)),\\n            (lanes.return = returnFiber),\\n            (returnFiber = lanes))\\n          : (deleteRemainingChildren(returnFiber, currentFirstChild),\\n            (lanes = createFiberFromText(newChild, returnFiber.mode, lanes)),\\n            (lanes.return = returnFiber),\\n            (returnFiber = lanes)),\\n        placeSingleChild(returnFiber))\\n      : deleteRemainingChildren(returnFiber, currentFirstChild);\\n  }\\n  return function (returnFiber, currentFirstChild, newChild, lanes) {\\n    try {\\n      thenableIndexCounter = 0;\\n      var firstChildFiber = reconcileChildFibersImpl(\\n        returnFiber,\\n        currentFirstChild,\\n        newChild,\\n        lanes\\n      );\\n      thenableState = null;\\n      return firstChildFiber;\\n    } catch (x) {\\n      if (x === SuspenseException || x === SuspenseActionException) throw x;\\n      var fiber = createFiberImplClass(29, x, null, returnFiber.mode);\\n      fiber.lanes = lanes;\\n      fiber.return = returnFiber;\\n      return fiber;\\n    } finally {\\n    }\\n  };\\n}\\nvar reconcileChildFibers = createChildReconciler(!0),\\n  mountChildFibers = createChildReconciler(!1),\\n  suspenseHandlerStackCursor = createCursor(null),\\n  shellBoundary = null;\\nfunction pushPrimaryTreeSuspenseHandler(handler) {\\n  var current = handler.alternate;\\n  push(suspenseStackCursor, suspenseStackCursor.current & 1);\\n  push(suspenseHandlerStackCursor, handler);\\n  null === shellBoundary &&\\n    (null === current || null !== currentTreeHiddenStackCursor.current\\n      ? (shellBoundary = handler)\\n      : null !== current.memoizedState && (shellBoundary = handler));\\n}\\nfunction pushOffscreenSuspenseHandler(fiber) {\\n  if (22 === fiber.tag) {\\n    if (\\n      (push(suspenseStackCursor, suspenseStackCursor.current),\\n      push(suspenseHandlerStackCursor, fiber),\\n      null === shellBoundary)\\n    ) {\\n      var current = fiber.alternate;\\n      null !== current &&\\n        null !== current.memoizedState &&\\n        (shellBoundary = fiber);\\n    }\\n  } else reuseSuspenseHandlerOnStack(fiber);\\n}\\nfunction reuseSuspenseHandlerOnStack() {\\n  push(suspenseStackCursor, suspenseStackCursor.current);\\n  push(suspenseHandlerStackCursor, suspenseHandlerStackCursor.current);\\n}\\nfunction popSuspenseHandler(fiber) {\\n  pop(suspenseHandlerStackCursor);\\n  shellBoundary === fiber && (shellBoundary = null);\\n  pop(suspenseStackCursor);\\n}\\nvar suspenseStackCursor = createCursor(0);\\nfunction findFirstSuspended(row) {\\n  for (var node = row; null !== node; ) {\\n    if (13 === node.tag) {\\n      var state = node.memoizedState;\\n      if (\\n        null !== state &&\\n        ((state = state.dehydrated),\\n        null === state ||\\n          \"$?\" === state.data ||\\n          isSuspenseInstanceFallback(state))\\n      )\\n        return node;\\n    } else if (19 === node.tag && void 0 !== node.memoizedProps.revealOrder) {\\n      if (0 !== (node.flags & 128)) return node;\\n    } else if (null !== node.child) {\\n      node.child.return = node;\\n      node = node.child;\\n      continue;\\n    }\\n    if (node === row) break;\\n    for (; null === node.sibling; ) {\\n      if (null === node.return || node.return === row) return null;\\n      node = node.return;\\n    }\\n    node.sibling.return = node.return;\\n    node = node.sibling;\\n  }\\n  return null;\\n}\\nfunction applyDerivedStateFromProps(\\n  workInProgress,\\n  ctor,\\n  getDerivedStateFromProps,\\n  nextProps\\n) {\\n  ctor = workInProgress.memoizedState;\\n  getDerivedStateFromProps = getDerivedStateFromProps(nextProps, ctor);\\n  getDerivedStateFromProps =\\n    null === getDerivedStateFromProps || void 0 === getDerivedStateFromProps\\n      ? ctor\\n      : assign({}, ctor, getDerivedStateFromProps);\\n  workInProgress.memoizedState = getDerivedStateFromProps;\\n  0 === workInProgress.lanes &&\\n    (workInProgress.updateQueue.baseState = getDerivedStateFromProps);\\n}\\nvar classComponentUpdater = {\\n  enqueueSetState: function (inst, payload, callback) {\\n    inst = inst._reactInternals;\\n    var lane = requestUpdateLane(),\\n      update = createUpdate(lane);\\n    update.payload = payload;\\n    void 0 !== callback && null !== callback && (update.callback = callback);\\n    payload = enqueueUpdate(inst, update, lane);\\n    null !== payload &&\\n      (scheduleUpdateOnFiber(payload, inst, lane),\\n      entangleTransitions(payload, inst, lane));\\n  },\\n  enqueueReplaceState: function (inst, payload, callback) {\\n    inst = inst._reactInternals;\\n    var lane = requestUpdateLane(),\\n      update = createUpdate(lane);\\n    update.tag = 1;\\n    update.payload = payload;\\n    void 0 !== callback && null !== callback && (update.callback = callback);\\n    payload = enqueueUpdate(inst, update, lane);\\n    null !== payload &&\\n      (scheduleUpdateOnFiber(payload, inst, lane),\\n      entangleTransitions(payload, inst, lane));\\n  },\\n  enqueueForceUpdate: function (inst, callback) {\\n    inst = inst._reactInternals;\\n    var lane = requestUpdateLane(),\\n      update = createUpdate(lane);\\n    update.tag = 2;\\n    void 0 !== callback && null !== callback && (update.callback = callback);\\n    callback = enqueueUpdate(inst, update, lane);\\n    null !== callback &&\\n      (scheduleUpdateOnFiber(callback, inst, lane),\\n      entangleTransitions(callback, inst, lane));\\n  }\\n};\\nfunction checkShouldComponentUpdate(\\n  workInProgress,\\n  ctor,\\n  oldProps,\\n  newProps,\\n  oldState,\\n  newState,\\n  nextContext\\n) {\\n  workInProgress = workInProgress.stateNode;\\n  return \"function\" === typeof workInProgress.shouldComponentUpdate\\n    ? workInProgress.shouldComponentUpdate(newProps, newState, nextContext)\\n    : ctor.prototype && ctor.prototype.isPureReactComponent\\n      ? !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState)\\n      : !0;\\n}\\nfunction callComponentWillReceiveProps(\\n  workInProgress,\\n  instance,\\n  newProps,\\n  nextContext\\n) {\\n  workInProgress = instance.state;\\n  \"function\" === typeof instance.componentWillReceiveProps &&\\n    instance.componentWillReceiveProps(newProps, nextContext);\\n  \"function\" === typeof instance.UNSAFE_componentWillReceiveProps &&\\n    instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);\\n  instance.state !== workInProgress &&\\n    classComponentUpdater.enqueueReplaceState(instance, instance.state, null);\\n}\\nfunction resolveClassComponentProps(Component, baseProps) {\\n  var newProps = baseProps;\\n  if (\"ref\" in baseProps) {\\n    newProps = {};\\n    for (var propName in baseProps)\\n      \"ref\" !== propName && (newProps[propName] = baseProps[propName]);\\n  }\\n  if ((Component = Component.defaultProps)) {\\n    newProps === baseProps && (newProps = assign({}, newProps));\\n    for (var propName$73 in Component)\\n      void 0 === newProps[propName$73] &&\\n        (newProps[propName$73] = Component[propName$73]);\\n  }\\n  return newProps;\\n}\\nvar reportGlobalError =\\n  \"function\" === typeof reportError\\n    ? reportError\\n    : function (error) {\\n        if (\\n          \"object\" === typeof window &&\\n          \"function\" === typeof window.ErrorEvent\\n        ) {\\n          var event = new window.ErrorEvent(\"error\", {\\n            bubbles: !0,\\n            cancelable: !0,\\n            message:\\n              \"object\" === typeof error &&\\n              null !== error &&\\n              \"string\" === typeof error.message\\n                ? String(error.message)\\n                : String(error),\\n            error: error\\n          });\\n          if (!window.dispatchEvent(event)) return;\\n        } else if (\\n          \"object\" === typeof process &&\\n          \"function\" === typeof process.emit\\n        ) {\\n          process.emit(\"uncaughtException\", error);\\n          return;\\n        }\\n        console.error(error);\\n      };\\nfunction defaultOnUncaughtError(error) {\\n  reportGlobalError(error);\\n}\\nfunction defaultOnCaughtError(error) {\\n  console.error(error);\\n}\\nfunction defaultOnRecoverableError(error) {\\n  reportGlobalError(error);\\n}\\nfunction logUncaughtError(root, errorInfo) {\\n  try {\\n    var onUncaughtError = root.onUncaughtError;\\n    onUncaughtError(errorInfo.value, { componentStack: errorInfo.stack });\\n  } catch (e$74) {\\n    setTimeout(function () {\\n      throw e$74;\\n    });\\n  }\\n}\\nfunction logCaughtError(root, boundary, errorInfo) {\\n  try {\\n    var onCaughtError = root.onCaughtError;\\n    onCaughtError(errorInfo.value, {\\n      componentStack: errorInfo.stack,\\n      errorBoundary: 1 === boundary.tag ? boundary.stateNode : null\\n    });\\n  } catch (e$75) {\\n    setTimeout(function () {\\n      throw e$75;\\n    });\\n  }\\n}\\nfunction createRootErrorUpdate(root, errorInfo, lane) {\\n  lane = createUpdate(lane);\\n  lane.tag = 3;\\n  lane.payload = { element: null };\\n  lane.callback = function () {\\n    logUncaughtError(root, errorInfo);\\n  };\\n  return lane;\\n}\\nfunction createClassErrorUpdate(lane) {\\n  lane = createUpdate(lane);\\n  lane.tag = 3;\\n  return lane;\\n}\\nfunction initializeClassErrorUpdate(update, root, fiber, errorInfo) {\\n  var getDerivedStateFromError = fiber.type.getDerivedStateFromError;\\n  if (\"function\" === typeof getDerivedStateFromError) {\\n    var error = errorInfo.value;\\n    update.payload = function () {\\n      return getDerivedStateFromError(error);\\n    };\\n    update.callback = function () {\\n      logCaughtError(root, fiber, errorInfo);\\n    };\\n  }\\n  var inst = fiber.stateNode;\\n  null !== inst &&\\n    \"function\" === typeof inst.componentDidCatch &&\\n    (update.callback = function () {\\n      logCaughtError(root, fiber, errorInfo);\\n      \"function\" !== typeof getDerivedStateFromError &&\\n        (null === legacyErrorBoundariesThatAlreadyFailed\\n          ? (legacyErrorBoundariesThatAlreadyFailed = new Set([this]))\\n          : legacyErrorBoundariesThatAlreadyFailed.add(this));\\n      var stack = errorInfo.stack;\\n      this.componentDidCatch(errorInfo.value, {\\n        componentStack: null !== stack ? stack : \"\"\\n      });\\n    });\\n}\\nfunction throwException(\\n  root,\\n  returnFiber,\\n  sourceFiber,\\n  value,\\n  rootRenderLanes\\n) {\\n  sourceFiber.flags |= 32768;\\n  if (\\n    null !== value &&\\n    \"object\" === typeof value &&\\n    \"function\" === typeof value.then\\n  ) {\\n    returnFiber = sourceFiber.alternate;\\n    null !== returnFiber &&\\n      propagateParentContextChanges(\\n        returnFiber,\\n        sourceFiber,\\n        rootRenderLanes,\\n        !0\\n      );\\n    sourceFiber = suspenseHandlerStackCursor.current;\\n    if (null !== sourceFiber) {\\n      switch (sourceFiber.tag) {\\n        case 13:\\n          return (\\n            null === shellBoundary\\n              ? renderDidSuspendDelayIfPossible()\\n              : null === sourceFiber.alternate &&\\n                0 === workInProgressRootExitStatus &&\\n                (workInProgressRootExitStatus = 3),\\n            (sourceFiber.flags &= -257),\\n            (sourceFiber.flags |= 65536),\\n            (sourceFiber.lanes = rootRenderLanes),\\n            value === noopSuspenseyCommitThenable\\n              ? (sourceFiber.flags |= 16384)\\n              : ((returnFiber = sourceFiber.updateQueue),\\n                null === returnFiber\\n                  ? (sourceFiber.updateQueue = new Set([value]))\\n                  : returnFiber.add(value),\\n                attachPingListener(root, value, rootRenderLanes)),\\n            !1\\n          );\\n        case 22:\\n          return (\\n            (sourceFiber.flags |= 65536),\\n            value === noopSuspenseyCommitThenable\\n              ? (sourceFiber.flags |= 16384)\\n              : ((returnFiber = sourceFiber.updateQueue),\\n                null === returnFiber\\n                  ? ((returnFiber = {\\n                      transitions: null,\\n                      markerInstances: null,\\n                      retryQueue: new Set([value])\\n                    }),\\n                    (sourceFiber.updateQueue = returnFiber))\\n                  : ((sourceFiber = returnFiber.retryQueue),\\n                    null === sourceFiber\\n                      ? (returnFiber.retryQueue = new Set([value]))\\n                      : sourceFiber.add(value)),\\n                attachPingListener(root, value, rootRenderLanes)),\\n            !1\\n          );\\n      }\\n      throw Error(formatProdErrorMessage(435, sourceFiber.tag));\\n    }\\n    attachPingListener(root, value, rootRenderLanes);\\n    renderDidSuspendDelayIfPossible();\\n    return !1;\\n  }\\n  if (isHydrating)\\n    return (\\n      (returnFiber = suspenseHandlerStackCursor.current),\\n      null !== returnFiber\\n        ? (0 === (returnFiber.flags & 65536) && (returnFiber.flags |= 256),\\n          (returnFiber.flags |= 65536),\\n          (returnFiber.lanes = rootRenderLanes),\\n          value !== HydrationMismatchException &&\\n            ((root = Error(formatProdErrorMessage(422), { cause: value })),\\n            queueHydrationError(createCapturedValueAtFiber(root, sourceFiber))))\\n        : (value !== HydrationMismatchException &&\\n            ((returnFiber = Error(formatProdErrorMessage(423), {\\n              cause: value\\n            })),\\n            queueHydrationError(\\n              createCapturedValueAtFiber(returnFiber, sourceFiber)\\n            )),\\n          (root = root.current.alternate),\\n          (root.flags |= 65536),\\n          (rootRenderLanes &= -rootRenderLanes),\\n          (root.lanes |= rootRenderLanes),\\n          (value = createCapturedValueAtFiber(value, sourceFiber)),\\n          (rootRenderLanes = createRootErrorUpdate(\\n            root.stateNode,\\n            value,\\n            rootRenderLanes\\n          )),\\n          enqueueCapturedUpdate(root, rootRenderLanes),\\n          4 !== workInProgressRootExitStatus &&\\n            (workInProgressRootExitStatus = 2)),\\n      !1\\n    );\\n  var wrapperError = Error(formatProdErrorMessage(520), { cause: value });\\n  wrapperError = createCapturedValueAtFiber(wrapperError, sourceFiber);\\n  null === workInProgressRootConcurrentErrors\\n    ? (workInProgressRootConcurrentErrors = [wrapperError])\\n    : workInProgressRootConcurrentErrors.push(wrapperError);\\n  4 !== workInProgressRootExitStatus && (workInProgressRootExitStatus = 2);\\n  if (null === returnFiber) return !0;\\n  value = createCapturedValueAtFiber(value, sourceFiber);\\n  sourceFiber = returnFiber;\\n  do {\\n    switch (sourceFiber.tag) {\\n      case 3:\\n        return (\\n          (sourceFiber.flags |= 65536),\\n          (root = rootRenderLanes & -rootRenderLanes),\\n          (sourceFiber.lanes |= root),\\n          (root = createRootErrorUpdate(sourceFiber.stateNode, value, root)),\\n          enqueueCapturedUpdate(sourceFiber, root),\\n          !1\\n        );\\n      case 1:\\n        if (\\n          ((returnFiber = sourceFiber.type),\\n          (wrapperError = sourceFiber.stateNode),\\n          0 === (sourceFiber.flags & 128) &&\\n            (\"function\" === typeof returnFiber.getDerivedStateFromError ||\\n              (null !== wrapperError &&\\n                \"function\" === typeof wrapperError.componentDidCatch &&\\n                (null === legacyErrorBoundariesThatAlreadyFailed ||\\n                  !legacyErrorBoundariesThatAlreadyFailed.has(wrapperError)))))\\n        )\\n          return (\\n            (sourceFiber.flags |= 65536),\\n            (rootRenderLanes &= -rootRenderLanes),\\n            (sourceFiber.lanes |= rootRenderLanes),\\n            (rootRenderLanes = createClassErrorUpdate(rootRenderLanes)),\\n            initializeClassErrorUpdate(\\n              rootRenderLanes,\\n              root,\\n              sourceFiber,\\n              value\\n            ),\\n            enqueueCapturedUpdate(sourceFiber, rootRenderLanes),\\n            !1\\n          );\\n    }\\n    sourceFiber = sourceFiber.return;\\n  } while (null !== sourceFiber);\\n  return !1;\\n}\\nvar SelectiveHydrationException = Error(formatProdErrorMessage(461)),\\n  didReceiveUpdate = !1;\\nfunction reconcileChildren(current, workInProgress, nextChildren, renderLanes) {\\n  workInProgress.child =\\n    null === current\\n      ? mountChildFibers(workInProgress, null, nextChildren, renderLanes)\\n      : reconcileChildFibers(\\n          workInProgress,\\n          current.child,\\n          nextChildren,\\n          renderLanes\\n        );\\n}\\nfunction updateForwardRef(\\n  current,\\n  workInProgress,\\n  Component,\\n  nextProps,\\n  renderLanes\\n) {\\n  Component = Component.render;\\n  var ref = workInProgress.ref;\\n  if (\"ref\" in nextProps) {\\n    var propsWithoutRef = {};\\n    for (var key in nextProps)\\n      \"ref\" !== key && (propsWithoutRef[key] = nextProps[key]);\\n  } else propsWithoutRef = nextProps;\\n  prepareToReadContext(workInProgress);\\n  nextProps = renderWithHooks(\\n    current,\\n    workInProgress,\\n    Component,\\n    propsWithoutRef,\\n    ref,\\n    renderLanes\\n  );\\n  key = checkDidRenderIdHook();\\n  if (null !== current && !didReceiveUpdate)\\n    return (\\n      bailoutHooks(current, workInProgress, renderLanes),\\n      bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)\\n    );\\n  isHydrating && key && pushMaterializedTreeId(workInProgress);\\n  workInProgress.flags |= 1;\\n  reconcileChildren(current, workInProgress, nextProps, renderLanes);\\n  return workInProgress.child;\\n}\\nfunction updateMemoComponent(\\n  current,\\n  workInProgress,\\n  Component,\\n  nextProps,\\n  renderLanes\\n) {\\n  if (null === current) {\\n    var type = Component.type;\\n    if (\\n      \"function\" === typeof type &&\\n      !shouldConstruct(type) &&\\n      void 0 === type.defaultProps &&\\n      null === Component.compare\\n    )\\n      return (\\n        (workInProgress.tag = 15),\\n        (workInProgress.type = type),\\n        updateSimpleMemoComponent(\\n          current,\\n          workInProgress,\\n          type,\\n          nextProps,\\n          renderLanes\\n        )\\n      );\\n    current = createFiberFromTypeAndProps(\\n      Component.type,\\n      null,\\n      nextProps,\\n      workInProgress,\\n      workInProgress.mode,\\n      renderLanes\\n    );\\n    current.ref = workInProgress.ref;\\n    current.return = workInProgress;\\n    return (workInProgress.child = current);\\n  }\\n  type = current.child;\\n  if (!checkScheduledUpdateOrContext(current, renderLanes)) {\\n    var prevProps = type.memoizedProps;\\n    Component = Component.compare;\\n    Component = null !== Component ? Component : shallowEqual;\\n    if (Component(prevProps, nextProps) && current.ref === workInProgress.ref)\\n      return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\\n  }\\n  workInProgress.flags |= 1;\\n  current = createWorkInProgress(type, nextProps);\\n  current.ref = workInProgress.ref;\\n  current.return = workInProgress;\\n  return (workInProgress.child = current);\\n}\\nfunction updateSimpleMemoComponent(\\n  current,\\n  workInProgress,\\n  Component,\\n  nextProps,\\n  renderLanes\\n) {\\n  if (null !== current) {\\n    var prevProps = current.memoizedProps;\\n    if (\\n      shallowEqual(prevProps, nextProps) &&\\n      current.ref === workInProgress.ref\\n    )\\n      if (\\n        ((didReceiveUpdate = !1),\\n        (workInProgress.pendingProps = nextProps = prevProps),\\n        checkScheduledUpdateOrContext(current, renderLanes))\\n      )\\n        0 !== (current.flags & 131072) && (didReceiveUpdate = !0);\\n      else\\n        return (\\n          (workInProgress.lanes = current.lanes),\\n          bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)\\n        );\\n  }\\n  return updateFunctionComponent(\\n    current,\\n    workInProgress,\\n    Component,\\n    nextProps,\\n    renderLanes\\n  );\\n}\\nfunction updateOffscreenComponent(current, workInProgress, renderLanes) {\\n  var nextProps = workInProgress.pendingProps,\\n    nextChildren = nextProps.children,\\n    prevState = null !== current ? current.memoizedState : null;\\n  if (\"hidden\" === nextProps.mode) {\\n    if (0 !== (workInProgress.flags & 128)) {\\n      nextProps =\\n        null !== prevState ? prevState.baseLanes | renderLanes : renderLanes;\\n      if (null !== current) {\\n        nextChildren = workInProgress.child = current.child;\\n        for (prevState = 0; null !== nextChildren; )\\n          (prevState =\\n            prevState | nextChildren.lanes | nextChildren.childLanes),\\n            (nextChildren = nextChildren.sibling);\\n        workInProgress.childLanes = prevState & ~nextProps;\\n      } else (workInProgress.childLanes = 0), (workInProgress.child = null);\\n      return deferHiddenOffscreenComponent(\\n        current,\\n        workInProgress,\\n        nextProps,\\n        renderLanes\\n      );\\n    }\\n    if (0 !== (renderLanes & 536870912))\\n      (workInProgress.memoizedState = { baseLanes: 0, cachePool: null }),\\n        null !== current &&\\n          pushTransition(\\n            workInProgress,\\n            null !== prevState ? prevState.cachePool : null\\n          ),\\n        null !== prevState\\n          ? pushHiddenContext(workInProgress, prevState)\\n          : reuseHiddenContextOnStack(),\\n        pushOffscreenSuspenseHandler(workInProgress);\\n    else\\n      return (\\n        (workInProgress.lanes = workInProgress.childLanes = 536870912),\\n        deferHiddenOffscreenComponent(\\n          current,\\n          workInProgress,\\n          null !== prevState ? prevState.baseLanes | renderLanes : renderLanes,\\n          renderLanes\\n        )\\n      );\\n  } else\\n    null !== prevState\\n      ? (pushTransition(workInProgress, prevState.cachePool),\\n        pushHiddenContext(workInProgress, prevState),\\n        reuseSuspenseHandlerOnStack(workInProgress),\\n        (workInProgress.memoizedState = null))\\n      : (null !== current && pushTransition(workInProgress, null),\\n        reuseHiddenContextOnStack(),\\n        reuseSuspenseHandlerOnStack(workInProgress));\\n  reconcileChildren(current, workInProgress, nextChildren, renderLanes);\\n  return workInProgress.child;\\n}\\nfunction deferHiddenOffscreenComponent(\\n  current,\\n  workInProgress,\\n  nextBaseLanes,\\n  renderLanes\\n) {\\n  var JSCompiler_inline_result = peekCacheFromPool();\\n  JSCompiler_inline_result =\\n    null === JSCompiler_inline_result\\n      ? null\\n      : { parent: CacheContext._currentValue, pool: JSCompiler_inline_result };\\n  workInProgress.memoizedState = {\\n    baseLanes: nextBaseLanes,\\n    cachePool: JSCompiler_inline_result\\n  };\\n  null !== current && pushTransition(workInProgress, null);\\n  reuseHiddenContextOnStack();\\n  pushOffscreenSuspenseHandler(workInProgress);\\n  null !== current &&\\n    propagateParentContextChanges(current, workInProgress, renderLanes, !0);\\n  return null;\\n}\\nfunction markRef(current, workInProgress) {\\n  var ref = workInProgress.ref;\\n  if (null === ref)\\n    null !== current &&\\n      null !== current.ref &&\\n      (workInProgress.flags |= 4194816);\\n  else {\\n    if (\"function\" !== typeof ref && \"object\" !== typeof ref)\\n      throw Error(formatProdErrorMessage(284));\\n    if (null === current || current.ref !== ref)\\n      workInProgress.flags |= 4194816;\\n  }\\n}\\nfunction updateFunctionComponent(\\n  current,\\n  workInProgress,\\n  Component,\\n  nextProps,\\n  renderLanes\\n) {\\n  prepareToReadContext(workInProgress);\\n  Component = renderWithHooks(\\n    current,\\n    workInProgress,\\n    Component,\\n    nextProps,\\n    void 0,\\n    renderLanes\\n  );\\n  nextProps = checkDidRenderIdHook();\\n  if (null !== current && !didReceiveUpdate)\\n    return (\\n      bailoutHooks(current, workInProgress, renderLanes),\\n      bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)\\n    );\\n  isHydrating && nextProps && pushMaterializedTreeId(workInProgress);\\n  workInProgress.flags |= 1;\\n  reconcileChildren(current, workInProgress, Component, renderLanes);\\n  return workInProgress.child;\\n}\\nfunction replayFunctionComponent(\\n  current,\\n  workInProgress,\\n  nextProps,\\n  Component,\\n  secondArg,\\n  renderLanes\\n) {\\n  prepareToReadContext(workInProgress);\\n  workInProgress.updateQueue = null;\\n  nextProps = renderWithHooksAgain(\\n    workInProgress,\\n    Component,\\n    nextProps,\\n    secondArg\\n  );\\n  finishRenderingHooks(current);\\n  Component = checkDidRenderIdHook();\\n  if (null !== current && !didReceiveUpdate)\\n    return (\\n      bailoutHooks(current, workInProgress, renderLanes),\\n      bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)\\n    );\\n  isHydrating && Component && pushMaterializedTreeId(workInProgress);\\n  workInProgress.flags |= 1;\\n  reconcileChildren(current, workInProgress, nextProps, renderLanes);\\n  return workInProgress.child;\\n}\\nfunction updateClassComponent(\\n  current,\\n  workInProgress,\\n  Component,\\n  nextProps,\\n  renderLanes\\n) {\\n  prepareToReadContext(workInProgress);\\n  if (null === workInProgress.stateNode) {\\n    var context = emptyContextObject,\\n      contextType = Component.contextType;\\n    \"object\" === typeof contextType &&\\n      null !== contextType &&\\n      (context = readContext(contextType));\\n    context = new Component(nextProps, context);\\n    workInProgress.memoizedState =\\n      null !== context.state && void 0 !== context.state ? context.state : null;\\n    context.updater = classComponentUpdater;\\n    workInProgress.stateNode = context;\\n    context._reactInternals = workInProgress;\\n    context = workInProgress.stateNode;\\n    context.props = nextProps;\\n    context.state = workInProgress.memoizedState;\\n    context.refs = {};\\n    initializeUpdateQueue(workInProgress);\\n    contextType = Component.contextType;\\n    context.context =\\n      \"object\" === typeof contextType && null !== contextType\\n        ? readContext(contextType)\\n        : emptyContextObject;\\n    context.state = workInProgress.memoizedState;\\n    contextType = Component.getDerivedStateFromProps;\\n    \"function\" === typeof contextType &&\\n      (applyDerivedStateFromProps(\\n        workInProgress,\\n        Component,\\n        contextType,\\n        nextProps\\n      ),\\n      (context.state = workInProgress.memoizedState));\\n    \"function\" === typeof Component.getDerivedStateFromProps ||\\n      \"function\" === typeof context.getSnapshotBeforeUpdate ||\\n      (\"function\" !== typeof context.UNSAFE_componentWillMount &&\\n        \"function\" !== typeof context.componentWillMount) ||\\n      ((contextType = context.state),\\n      \"function\" === typeof context.componentWillMount &&\\n        context.componentWillMount(),\\n      \"function\" === typeof context.UNSAFE_componentWillMount &&\\n        context.UNSAFE_componentWillMount(),\\n      contextType !== context.state &&\\n        classComponentUpdater.enqueueReplaceState(context, context.state, null),\\n      processUpdateQueue(workInProgress, nextProps, context, renderLanes),\\n      suspendIfUpdateReadFromEntangledAsyncAction(),\\n      (context.state = workInProgress.memoizedState));\\n    \"function\" === typeof context.componentDidMount &&\\n      (workInProgress.flags |= 4194308);\\n    nextProps = !0;\\n  } else if (null === current) {\\n    context = workInProgress.stateNode;\\n    var unresolvedOldProps = workInProgress.memoizedProps,\\n      oldProps = resolveClassComponentProps(Component, unresolvedOldProps);\\n    context.props = oldProps;\\n    var oldContext = context.context,\\n      contextType$jscomp$0 = Component.contextType;\\n    contextType = emptyContextObject;\\n    \"object\" === typeof contextType$jscomp$0 &&\\n      null !== contextType$jscomp$0 &&\\n      (contextType = readContext(contextType$jscomp$0));\\n    var getDerivedStateFromProps = Component.getDerivedStateFromProps;\\n    contextType$jscomp$0 =\\n      \"function\" === typeof getDerivedStateFromProps ||\\n      \"function\" === typeof context.getSnapshotBeforeUpdate;\\n    unresolvedOldProps = workInProgress.pendingProps !== unresolvedOldProps;\\n    contextType$jscomp$0 ||\\n      (\"function\" !== typeof context.UNSAFE_componentWillReceiveProps &&\\n        \"function\" !== typeof context.componentWillReceiveProps) ||\\n      ((unresolvedOldProps || oldContext !== contextType) &&\\n        callComponentWillReceiveProps(\\n          workInProgress,\\n          context,\\n          nextProps,\\n          contextType\\n        ));\\n    hasForceUpdate = !1;\\n    var oldState = workInProgress.memoizedState;\\n    context.state = oldState;\\n    processUpdateQueue(workInProgress, nextProps, context, renderLanes);\\n    suspendIfUpdateReadFromEntangledAsyncAction();\\n    oldContext = workInProgress.memoizedState;\\n    unresolvedOldProps || oldState !== oldContext || hasForceUpdate\\n      ? (\"function\" === typeof getDerivedStateFromProps &&\\n          (applyDerivedStateFromProps(\\n            workInProgress,\\n            Component,\\n            getDerivedStateFromProps,\\n            nextProps\\n          ),\\n          (oldContext = workInProgress.memoizedState)),\\n        (oldProps =\\n          hasForceUpdate ||\\n          checkShouldComponentUpdate(\\n            workInProgress,\\n            Component,\\n            oldProps,\\n            nextProps,\\n            oldState,\\n            oldContext,\\n            contextType\\n          ))\\n          ? (contextType$jscomp$0 ||\\n              (\"function\" !== typeof context.UNSAFE_componentWillMount &&\\n                \"function\" !== typeof context.componentWillMount) ||\\n              (\"function\" === typeof context.componentWillMount &&\\n                context.componentWillMount(),\\n              \"function\" === typeof context.UNSAFE_componentWillMount &&\\n                context.UNSAFE_componentWillMount()),\\n            \"function\" === typeof context.componentDidMount &&\\n              (workInProgress.flags |= 4194308))\\n          : (\"function\" === typeof context.componentDidMount &&\\n              (workInProgress.flags |= 4194308),\\n            (workInProgress.memoizedProps = nextProps),\\n            (workInProgress.memoizedState = oldContext)),\\n        (context.props = nextProps),\\n        (context.state = oldContext),\\n        (context.context = contextType),\\n        (nextProps = oldProps))\\n      : (\"function\" === typeof context.componentDidMount &&\\n          (workInProgress.flags |= 4194308),\\n        (nextProps = !1));\\n  } else {\\n    context = workInProgress.stateNode;\\n    cloneUpdateQueue(current, workInProgress);\\n    contextType = workInProgress.memoizedProps;\\n    contextType$jscomp$0 = resolveClassComponentProps(Component, contextType);\\n    context.props = contextType$jscomp$0;\\n    getDerivedStateFromProps = workInProgress.pendingProps;\\n    oldState = context.context;\\n    oldContext = Component.contextType;\\n    oldProps = emptyContextObject;\\n    \"object\" === typeof oldContext &&\\n      null !== oldContext &&\\n      (oldProps = readContext(oldContext));\\n    unresolvedOldProps = Component.getDerivedStateFromProps;\\n    (oldContext =\\n      \"function\" === typeof unresolvedOldProps ||\\n      \"function\" === typeof context.getSnapshotBeforeUpdate) ||\\n      (\"function\" !== typeof context.UNSAFE_componentWillReceiveProps &&\\n        \"function\" !== typeof context.componentWillReceiveProps) ||\\n      ((contextType !== getDerivedStateFromProps || oldState !== oldProps) &&\\n        callComponentWillReceiveProps(\\n          workInProgress,\\n          context,\\n          nextProps,\\n          oldProps\\n        ));\\n    hasForceUpdate = !1;\\n    oldState = workInProgress.memoizedState;\\n    context.state = oldState;\\n    processUpdateQueue(workInProgress, nextProps, context, renderLanes);\\n    suspendIfUpdateReadFromEntangledAsyncAction();\\n    var newState = workInProgress.memoizedState;\\n    contextType !== getDerivedStateFromProps ||\\n    oldState !== newState ||\\n    hasForceUpdate ||\\n    (null !== current &&\\n      null !== current.dependencies &&\\n      checkIfContextChanged(current.dependencies))\\n      ? (\"function\" === typeof unresolvedOldProps &&\\n          (applyDerivedStateFromProps(\\n            workInProgress,\\n            Component,\\n            unresolvedOldProps,\\n            nextProps\\n          ),\\n          (newState = workInProgress.memoizedState)),\\n        (contextType$jscomp$0 =\\n          hasForceUpdate ||\\n          checkShouldComponentUpdate(\\n            workInProgress,\\n            Component,\\n            contextType$jscomp$0,\\n            nextProps,\\n            oldState,\\n            newState,\\n            oldProps\\n          ) ||\\n          (null !== current &&\\n            null !== current.dependencies &&\\n            checkIfContextChanged(current.dependencies)))\\n          ? (oldContext ||\\n              (\"function\" !== typeof context.UNSAFE_componentWillUpdate &&\\n                \"function\" !== typeof context.componentWillUpdate) ||\\n              (\"function\" === typeof context.componentWillUpdate &&\\n                context.componentWillUpdate(nextProps, newState, oldProps),\\n              \"function\" === typeof context.UNSAFE_componentWillUpdate &&\\n                context.UNSAFE_componentWillUpdate(\\n                  nextProps,\\n                  newState,\\n                  oldProps\\n                )),\\n            \"function\" === typeof context.componentDidUpdate &&\\n              (workInProgress.flags |= 4),\\n            \"function\" === typeof context.getSnapshotBeforeUpdate &&\\n              (workInProgress.flags |= 1024))\\n          : (\"function\" !== typeof context.componentDidUpdate ||\\n              (contextType === current.memoizedProps &&\\n                oldState === current.memoizedState) ||\\n              (workInProgress.flags |= 4),\\n            \"function\" !== typeof context.getSnapshotBeforeUpdate ||\\n              (contextType === current.memoizedProps &&\\n                oldState === current.memoizedState) ||\\n              (workInProgress.flags |= 1024),\\n            (workInProgress.memoizedProps = nextProps),\\n            (workInProgress.memoizedState = newState)),\\n        (context.props = nextProps),\\n        (context.state = newState),\\n        (context.context = oldProps),\\n        (nextProps = contextType$jscomp$0))\\n      : (\"function\" !== typeof context.componentDidUpdate ||\\n          (contextType === current.memoizedProps &&\\n            oldState === current.memoizedState) ||\\n          (workInProgress.flags |= 4),\\n        \"function\" !== typeof context.getSnapshotBeforeUpdate ||\\n          (contextType === current.memoizedProps &&\\n            oldState === current.memoizedState) ||\\n          (workInProgress.flags |= 1024),\\n        (nextProps = !1));\\n  }\\n  context = nextProps;\\n  markRef(current, workInProgress);\\n  nextProps = 0 !== (workInProgress.flags & 128);\\n  context || nextProps\\n    ? ((context = workInProgress.stateNode),\\n      (Component =\\n        nextProps && \"function\" !== typeof Component.getDerivedStateFromError\\n          ? null\\n          : context.render()),\\n      (workInProgress.flags |= 1),\\n      null !== current && nextProps\\n        ? ((workInProgress.child = reconcileChildFibers(\\n            workInProgress,\\n            current.child,\\n            null,\\n            renderLanes\\n          )),\\n          (workInProgress.child = reconcileChildFibers(\\n            workInProgress,\\n            null,\\n            Component,\\n            renderLanes\\n          )))\\n        : reconcileChildren(current, workInProgress, Component, renderLanes),\\n      (workInProgress.memoizedState = context.state),\\n      (current = workInProgress.child))\\n    : (current = bailoutOnAlreadyFinishedWork(\\n        current,\\n        workInProgress,\\n        renderLanes\\n      ));\\n  return current;\\n}\\nfunction mountHostRootWithoutHydrating(\\n  current,\\n  workInProgress,\\n  nextChildren,\\n  renderLanes\\n) {\\n  resetHydrationState();\\n  workInProgress.flags |= 256;\\n  reconcileChildren(current, workInProgress, nextChildren, renderLanes);\\n  return workInProgress.child;\\n}\\nvar SUSPENDED_MARKER = {\\n  dehydrated: null,\\n  treeContext: null,\\n  retryLane: 0,\\n  hydrationErrors: null\\n};\\nfunction mountSuspenseOffscreenState(renderLanes) {\\n  return { baseLanes: renderLanes, cachePool: getSuspendedCache() };\\n}\\nfunction getRemainingWorkInPrimaryTree(\\n  current,\\n  primaryTreeDidDefer,\\n  renderLanes\\n) {\\n  current = null !== current ? current.childLanes & ~renderLanes : 0;\\n  primaryTreeDidDefer && (current |= workInProgressDeferredLane);\\n  return current;\\n}\\nfunction updateSuspenseComponent(current, workInProgress, renderLanes) {\\n  var nextProps = workInProgress.pendingProps,\\n    showFallback = !1,\\n    didSuspend = 0 !== (workInProgress.flags & 128),\\n    JSCompiler_temp;\\n  (JSCompiler_temp = didSuspend) ||\\n    (JSCompiler_temp =\\n      null !== current && null === current.memoizedState\\n        ? !1\\n        : 0 !== (suspenseStackCursor.current & 2));\\n  JSCompiler_temp && ((showFallback = !0), (workInProgress.flags &= -129));\\n  JSCompiler_temp = 0 !== (workInProgress.flags & 32);\\n  workInProgress.flags &= -33;\\n  if (null === current) {\\n    if (isHydrating) {\\n      showFallback\\n        ? pushPrimaryTreeSuspenseHandler(workInProgress)\\n        : reuseSuspenseHandlerOnStack(workInProgress);\\n      if (isHydrating) {\\n        var nextInstance = nextHydratableInstance,\\n          JSCompiler_temp$jscomp$0;\\n        if ((JSCompiler_temp$jscomp$0 = nextInstance)) {\\n          c: {\\n            JSCompiler_temp$jscomp$0 = nextInstance;\\n            for (\\n              nextInstance = rootOrSingletonContext;\\n              8 !== JSCompiler_temp$jscomp$0.nodeType;\\n\\n            ) {\\n              if (!nextInstance) {\\n                nextInstance = null;\\n                break c;\\n              }\\n              JSCompiler_temp$jscomp$0 = getNextHydratable(\\n                JSCompiler_temp$jscomp$0.nextSibling\\n              );\\n              if (null === JSCompiler_temp$jscomp$0) {\\n                nextInstance = null;\\n                break c;\\n              }\\n            }\\n            nextInstance = JSCompiler_temp$jscomp$0;\\n          }\\n          null !== nextInstance\\n            ? ((workInProgress.memoizedState = {\\n                dehydrated: nextInstance,\\n                treeContext:\\n                  null !== treeContextProvider\\n                    ? { id: treeContextId, overflow: treeContextOverflow }\\n                    : null,\\n                retryLane: 536870912,\\n                hydrationErrors: null\\n              }),\\n              (JSCompiler_temp$jscomp$0 = createFiberImplClass(\\n                18,\\n                null,\\n                null,\\n                0\\n              )),\\n              (JSCompiler_temp$jscomp$0.stateNode = nextInstance),\\n              (JSCompiler_temp$jscomp$0.return = workInProgress),\\n              (workInProgress.child = JSCompiler_temp$jscomp$0),\\n              (hydrationParentFiber = workInProgress),\\n              (nextHydratableInstance = null),\\n              (JSCompiler_temp$jscomp$0 = !0))\\n            : (JSCompiler_temp$jscomp$0 = !1);\\n        }\\n        JSCompiler_temp$jscomp$0 || throwOnHydrationMismatch(workInProgress);\\n      }\\n      nextInstance = workInProgress.memoizedState;\\n      if (\\n        null !== nextInstance &&\\n        ((nextInstance = nextInstance.dehydrated), null !== nextInstance)\\n      )\\n        return (\\n          isSuspenseInstanceFallback(nextInstance)\\n            ? (workInProgress.lanes = 32)\\n            : (workInProgress.lanes = 536870912),\\n          null\\n        );\\n      popSuspenseHandler(workInProgress);\\n    }\\n    nextInstance = nextProps.children;\\n    nextProps = nextProps.fallback;\\n    if (showFallback)\\n      return (\\n        reuseSuspenseHandlerOnStack(workInProgress),\\n        (showFallback = workInProgress.mode),\\n        (nextInstance = mountWorkInProgressOffscreenFiber(\\n          { mode: \"hidden\", children: nextInstance },\\n          showFallback\\n        )),\\n        (nextProps = createFiberFromFragment(\\n          nextProps,\\n          showFallback,\\n          renderLanes,\\n          null\\n        )),\\n        (nextInstance.return = workInProgress),\\n        (nextProps.return = workInProgress),\\n        (nextInstance.sibling = nextProps),\\n        (workInProgress.child = nextInstance),\\n        (showFallback = workInProgress.child),\\n        (showFallback.memoizedState = mountSuspenseOffscreenState(renderLanes)),\\n        (showFallback.childLanes = getRemainingWorkInPrimaryTree(\\n          current,\\n          JSCompiler_temp,\\n          renderLanes\\n        )),\\n        (workInProgress.memoizedState = SUSPENDED_MARKER),\\n        nextProps\\n      );\\n    pushPrimaryTreeSuspenseHandler(workInProgress);\\n    return mountSuspensePrimaryChildren(workInProgress, nextInstance);\\n  }\\n  JSCompiler_temp$jscomp$0 = current.memoizedState;\\n  if (\\n    null !== JSCompiler_temp$jscomp$0 &&\\n    ((nextInstance = JSCompiler_temp$jscomp$0.dehydrated),\\n    null !== nextInstance)\\n  ) {\\n    if (didSuspend)\\n      workInProgress.flags & 256\\n        ? (pushPrimaryTreeSuspenseHandler(workInProgress),\\n          (workInProgress.flags &= -257),\\n          (workInProgress = retrySuspenseComponentWithoutHydrating(\\n            current,\\n            workInProgress,\\n            renderLanes\\n          )))\\n        : null !== workInProgress.memoizedState\\n          ? (reuseSuspenseHandlerOnStack(workInProgress),\\n            (workInProgress.child = current.child),\\n            (workInProgress.flags |= 128),\\n            (workInProgress = null))\\n          : (reuseSuspenseHandlerOnStack(workInProgress),\\n            (showFallback = nextProps.fallback),\\n            (nextInstance = workInProgress.mode),\\n            (nextProps = mountWorkInProgressOffscreenFiber(\\n              { mode: \"visible\", children: nextProps.children },\\n              nextInstance\\n            )),\\n            (showFallback = createFiberFromFragment(\\n              showFallback,\\n              nextInstance,\\n              renderLanes,\\n              null\\n            )),\\n            (showFallback.flags |= 2),\\n            (nextProps.return = workInProgress),\\n            (showFallback.return = workInProgress),\\n            (nextProps.sibling = showFallback),\\n            (workInProgress.child = nextProps),\\n            reconcileChildFibers(\\n              workInProgress,\\n              current.child,\\n              null,\\n              renderLanes\\n            ),\\n            (nextProps = workInProgress.child),\\n            (nextProps.memoizedState =\\n              mountSuspenseOffscreenState(renderLanes)),\\n            (nextProps.childLanes = getRemainingWorkInPrimaryTree(\\n              current,\\n              JSCompiler_temp,\\n              renderLanes\\n            )),\\n            (workInProgress.memoizedState = SUSPENDED_MARKER),\\n            (workInProgress = showFallback));\\n    else if (\\n      (pushPrimaryTreeSuspenseHandler(workInProgress),\\n      isSuspenseInstanceFallback(nextInstance))\\n    ) {\\n      JSCompiler_temp =\\n        nextInstance.nextSibling && nextInstance.nextSibling.dataset;\\n      if (JSCompiler_temp) var digest = JSCompiler_temp.dgst;\\n      JSCompiler_temp = digest;\\n      nextProps = Error(formatProdErrorMessage(419));\\n      nextProps.stack = \"\";\\n      nextProps.digest = JSCompiler_temp;\\n      queueHydrationError({ value: nextProps, source: null, stack: null });\\n      workInProgress = retrySuspenseComponentWithoutHydrating(\\n        current,\\n        workInProgress,\\n        renderLanes\\n      );\\n    } else if (\\n      (didReceiveUpdate ||\\n        propagateParentContextChanges(current, workInProgress, renderLanes, !1),\\n      (JSCompiler_temp = 0 !== (renderLanes & current.childLanes)),\\n      didReceiveUpdate || JSCompiler_temp)\\n    ) {\\n      JSCompiler_temp = workInProgressRoot;\\n      if (\\n        null !== JSCompiler_temp &&\\n        ((nextProps = renderLanes & -renderLanes),\\n        (nextProps =\\n          0 !== (nextProps & 42)\\n            ? 1\\n            : getBumpedLaneForHydrationByLane(nextProps)),\\n        (nextProps =\\n          0 !== (nextProps & (JSCompiler_temp.suspendedLanes | renderLanes))\\n            ? 0\\n            : nextProps),\\n        0 !== nextProps && nextProps !== JSCompiler_temp$jscomp$0.retryLane)\\n      )\\n        throw (\\n          ((JSCompiler_temp$jscomp$0.retryLane = nextProps),\\n          enqueueConcurrentRenderForLane(current, nextProps),\\n          scheduleUpdateOnFiber(JSCompiler_temp, current, nextProps),\\n          SelectiveHydrationException)\\n        );\\n      \"$?\" === nextInstance.data || renderDidSuspendDelayIfPossible();\\n      workInProgress = retrySuspenseComponentWithoutHydrating(\\n        current,\\n        workInProgress,\\n        renderLanes\\n      );\\n    } else\\n      \"$?\" === nextInstance.data\\n        ? ((workInProgress.flags |= 192),\\n          (workInProgress.child = current.child),\\n          (workInProgress = null))\\n        : ((current = JSCompiler_temp$jscomp$0.treeContext),\\n          (nextHydratableInstance = getNextHydratable(\\n            nextInstance.nextSibling\\n          )),\\n          (hydrationParentFiber = workInProgress),\\n          (isHydrating = !0),\\n          (hydrationErrors = null),\\n          (rootOrSingletonContext = !1),\\n          null !== current &&\\n            ((idStack[idStackIndex++] = treeContextId),\\n            (idStack[idStackIndex++] = treeContextOverflow),\\n            (idStack[idStackIndex++] = treeContextProvider),\\n            (treeContextId = current.id),\\n            (treeContextOverflow = current.overflow),\\n            (treeContextProvider = workInProgress)),\\n          (workInProgress = mountSuspensePrimaryChildren(\\n            workInProgress,\\n            nextProps.children\\n          )),\\n          (workInProgress.flags |= 4096));\\n    return workInProgress;\\n  }\\n  if (showFallback)\\n    return (\\n      reuseSuspenseHandlerOnStack(workInProgress),\\n      (showFallback = nextProps.fallback),\\n      (nextInstance = workInProgress.mode),\\n      (JSCompiler_temp$jscomp$0 = current.child),\\n      (digest = JSCompiler_temp$jscomp$0.sibling),\\n      (nextProps = createWorkInProgress(JSCompiler_temp$jscomp$0, {\\n        mode: \"hidden\",\\n        children: nextProps.children\\n      })),\\n      (nextProps.subtreeFlags =\\n        JSCompiler_temp$jscomp$0.subtreeFlags & 65011712),\\n      null !== digest\\n        ? (showFallback = createWorkInProgress(digest, showFallback))\\n        : ((showFallback = createFiberFromFragment(\\n            showFallback,\\n            nextInstance,\\n            renderLanes,\\n            null\\n          )),\\n          (showFallback.flags |= 2)),\\n      (showFallback.return = workInProgress),\\n      (nextProps.return = workInProgress),\\n      (nextProps.sibling = showFallback),\\n      (workInProgress.child = nextProps),\\n      (nextProps = showFallback),\\n      (showFallback = workInProgress.child),\\n      (nextInstance = current.child.memoizedState),\\n      null === nextInstance\\n        ? (nextInstance = mountSuspenseOffscreenState(renderLanes))\\n        : ((JSCompiler_temp$jscomp$0 = nextInstance.cachePool),\\n          null !== JSCompiler_temp$jscomp$0\\n            ? ((digest = CacheContext._currentValue),\\n              (JSCompiler_temp$jscomp$0 =\\n                JSCompiler_temp$jscomp$0.parent !== digest\\n                  ? { parent: digest, pool: digest }\\n                  : JSCompiler_temp$jscomp$0))\\n            : (JSCompiler_temp$jscomp$0 = getSuspendedCache()),\\n          (nextInstance = {\\n            baseLanes: nextInstance.baseLanes | renderLanes,\\n            cachePool: JSCompiler_temp$jscomp$0\\n          })),\\n      (showFallback.memoizedState = nextInstance),\\n      (showFallback.childLanes = getRemainingWorkInPrimaryTree(\\n        current,\\n        JSCompiler_temp,\\n        renderLanes\\n      )),\\n      (workInProgress.memoizedState = SUSPENDED_MARKER),\\n      nextProps\\n    );\\n  pushPrimaryTreeSuspenseHandler(workInProgress);\\n  renderLanes = current.child;\\n  current = renderLanes.sibling;\\n  renderLanes = createWorkInProgress(renderLanes, {\\n    mode: \"visible\",\\n    children: nextProps.children\\n  });\\n  renderLanes.return = workInProgress;\\n  renderLanes.sibling = null;\\n  null !== current &&\\n    ((JSCompiler_temp = workInProgress.deletions),\\n    null === JSCompiler_temp\\n      ? ((workInProgress.deletions = [current]), (workInProgress.flags |= 16))\\n      : JSCompiler_temp.push(current));\\n  workInProgress.child = renderLanes;\\n  workInProgress.memoizedState = null;\\n  return renderLanes;\\n}\\nfunction mountSuspensePrimaryChildren(workInProgress, primaryChildren) {\\n  primaryChildren = mountWorkInProgressOffscreenFiber(\\n    { mode: \"visible\", children: primaryChildren },\\n    workInProgress.mode\\n  );\\n  primaryChildren.return = workInProgress;\\n  return (workInProgress.child = primaryChildren);\\n}\\nfunction mountWorkInProgressOffscreenFiber(offscreenProps, mode) {\\n  offscreenProps = createFiberImplClass(22, offscreenProps, null, mode);\\n  offscreenProps.lanes = 0;\\n  offscreenProps.stateNode = {\\n    _visibility: 1,\\n    _pendingMarkers: null,\\n    _retryCache: null,\\n    _transitions: null\\n  };\\n  return offscreenProps;\\n}\\nfunction retrySuspenseComponentWithoutHydrating(\\n  current,\\n  workInProgress,\\n  renderLanes\\n) {\\n  reconcileChildFibers(workInProgress, current.child, null, renderLanes);\\n  current = mountSuspensePrimaryChildren(\\n    workInProgress,\\n    workInProgress.pendingProps.children\\n  );\\n  current.flags |= 2;\\n  workInProgress.memoizedState = null;\\n  return current;\\n}\\nfunction scheduleSuspenseWorkOnFiber(fiber, renderLanes, propagationRoot) {\\n  fiber.lanes |= renderLanes;\\n  var alternate = fiber.alternate;\\n  null !== alternate && (alternate.lanes |= renderLanes);\\n  scheduleContextWorkOnParentPath(fiber.return, renderLanes, propagationRoot);\\n}\\nfunction initSuspenseListRenderState(\\n  workInProgress,\\n  isBackwards,\\n  tail,\\n  lastContentRow,\\n  tailMode\\n) {\\n  var renderState = workInProgress.memoizedState;\\n  null === renderState\\n    ? (workInProgress.memoizedState = {\\n        isBackwards: isBackwards,\\n        rendering: null,\\n        renderingStartTime: 0,\\n        last: lastContentRow,\\n        tail: tail,\\n        tailMode: tailMode\\n      })\\n    : ((renderState.isBackwards = isBackwards),\\n      (renderState.rendering = null),\\n      (renderState.renderingStartTime = 0),\\n      (renderState.last = lastContentRow),\\n      (renderState.tail = tail),\\n      (renderState.tailMode = tailMode));\\n}\\nfunction updateSuspenseListComponent(current, workInProgress, renderLanes) {\\n  var nextProps = workInProgress.pendingProps,\\n    revealOrder = nextProps.revealOrder,\\n    tailMode = nextProps.tail;\\n  reconcileChildren(current, workInProgress, nextProps.children, renderLanes);\\n  nextProps = suspenseStackCursor.current;\\n  if (0 !== (nextProps & 2))\\n    (nextProps = (nextProps & 1) | 2), (workInProgress.flags |= 128);\\n  else {\\n    if (null !== current && 0 !== (current.flags & 128))\\n      a: for (current = workInProgress.child; null !== current; ) {\\n        if (13 === current.tag)\\n          null !== current.memoizedState &&\\n            scheduleSuspenseWorkOnFiber(current, renderLanes, workInProgress);\\n        else if (19 === current.tag)\\n          scheduleSuspenseWorkOnFiber(current, renderLanes, workInProgress);\\n        else if (null !== current.child) {\\n          current.child.return = current;\\n          current = current.child;\\n          continue;\\n        }\\n        if (current === workInProgress) break a;\\n        for (; null === current.sibling; ) {\\n          if (null === current.return || current.return === workInProgress)\\n            break a;\\n          current = current.return;\\n        }\\n        current.sibling.return = current.return;\\n        current = current.sibling;\\n      }\\n    nextProps &= 1;\\n  }\\n  push(suspenseStackCursor, nextProps);\\n  switch (revealOrder) {\\n    case \"forwards\":\\n      renderLanes = workInProgress.child;\\n      for (revealOrder = null; null !== renderLanes; )\\n        (current = renderLanes.alternate),\\n          null !== current &&\\n            null === findFirstSuspended(current) &&\\n            (revealOrder = renderLanes),\\n          (renderLanes = renderLanes.sibling);\\n      renderLanes = revealOrder;\\n      null === renderLanes\\n        ? ((revealOrder = workInProgress.child), (workInProgress.child = null))\\n        : ((revealOrder = renderLanes.sibling), (renderLanes.sibling = null));\\n      initSuspenseListRenderState(\\n        workInProgress,\\n        !1,\\n        revealOrder,\\n        renderLanes,\\n        tailMode\\n      );\\n      break;\\n    case \"backwards\":\\n      renderLanes = null;\\n      revealOrder = workInProgress.child;\\n      for (workInProgress.child = null; null !== revealOrder; ) {\\n        current = revealOrder.alternate;\\n        if (null !== current && null === findFirstSuspended(current)) {\\n          workInProgress.child = revealOrder;\\n          break;\\n        }\\n        current = revealOrder.sibling;\\n        revealOrder.sibling = renderLanes;\\n        renderLanes = revealOrder;\\n        revealOrder = current;\\n      }\\n      initSuspenseListRenderState(\\n        workInProgress,\\n        !0,\\n        renderLanes,\\n        null,\\n        tailMode\\n      );\\n      break;\\n    case \"together\":\\n      initSuspenseListRenderState(workInProgress, !1, null, null, void 0);\\n      break;\\n    default:\\n      workInProgress.memoizedState = null;\\n  }\\n  return workInProgress.child;\\n}\\nfunction bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes) {\\n  null !== current && (workInProgress.dependencies = current.dependencies);\\n  workInProgressRootSkippedLanes |= workInProgress.lanes;\\n  if (0 === (renderLanes & workInProgress.childLanes))\\n    if (null !== current) {\\n      if (\\n        (propagateParentContextChanges(\\n          current,\\n          workInProgress,\\n          renderLanes,\\n          !1\\n        ),\\n        0 === (renderLanes & workInProgress.childLanes))\\n      )\\n        return null;\\n    } else return null;\\n  if (null !== current && workInProgress.child !== current.child)\\n    throw Error(formatProdErrorMessage(153));\\n  if (null !== workInProgress.child) {\\n    current = workInProgress.child;\\n    renderLanes = createWorkInProgress(current, current.pendingProps);\\n    workInProgress.child = renderLanes;\\n    for (renderLanes.return = workInProgress; null !== current.sibling; )\\n      (current = current.sibling),\\n        (renderLanes = renderLanes.sibling =\\n          createWorkInProgress(current, current.pendingProps)),\\n        (renderLanes.return = workInProgress);\\n    renderLanes.sibling = null;\\n  }\\n  return workInProgress.child;\\n}\\nfunction checkScheduledUpdateOrContext(current, renderLanes) {\\n  if (0 !== (current.lanes & renderLanes)) return !0;\\n  current = current.dependencies;\\n  return null !== current && checkIfContextChanged(current) ? !0 : !1;\\n}\\nfunction attemptEarlyBailoutIfNoScheduledUpdate(\\n  current,\\n  workInProgress,\\n  renderLanes\\n) {\\n  switch (workInProgress.tag) {\\n    case 3:\\n      pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);\\n      pushProvider(workInProgress, CacheContext, current.memoizedState.cache);\\n      resetHydrationState();\\n      break;\\n    case 27:\\n    case 5:\\n      pushHostContext(workInProgress);\\n      break;\\n    case 4:\\n      pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);\\n      break;\\n    case 10:\\n      pushProvider(\\n        workInProgress,\\n        workInProgress.type,\\n        workInProgress.memoizedProps.value\\n      );\\n      break;\\n    case 13:\\n      var state = workInProgress.memoizedState;\\n      if (null !== state) {\\n        if (null !== state.dehydrated)\\n          return (\\n            pushPrimaryTreeSuspenseHandler(workInProgress),\\n            (workInProgress.flags |= 128),\\n            null\\n          );\\n        if (0 !== (renderLanes & workInProgress.child.childLanes))\\n          return updateSuspenseComponent(current, workInProgress, renderLanes);\\n        pushPrimaryTreeSuspenseHandler(workInProgress);\\n        current = bailoutOnAlreadyFinishedWork(\\n          current,\\n          workInProgress,\\n          renderLanes\\n        );\\n        return null !== current ? current.sibling : null;\\n      }\\n      pushPrimaryTreeSuspenseHandler(workInProgress);\\n      break;\\n    case 19:\\n      var didSuspendBefore = 0 !== (current.flags & 128);\\n      state = 0 !== (renderLanes & workInProgress.childLanes);\\n      state ||\\n        (propagateParentContextChanges(\\n          current,\\n          workInProgress,\\n          renderLanes,\\n          !1\\n        ),\\n        (state = 0 !== (renderLanes & workInProgress.childLanes)));\\n      if (didSuspendBefore) {\\n        if (state)\\n          return updateSuspenseListComponent(\\n            current,\\n            workInProgress,\\n            renderLanes\\n          );\\n        workInProgress.flags |= 128;\\n      }\\n      didSuspendBefore = workInProgress.memoizedState;\\n      null !== didSuspendBefore &&\\n        ((didSuspendBefore.rendering = null),\\n        (didSuspendBefore.tail = null),\\n        (didSuspendBefore.lastEffect = null));\\n      push(suspenseStackCursor, suspenseStackCursor.current);\\n      if (state) break;\\n      else return null;\\n    case 22:\\n    case 23:\\n      return (\\n        (workInProgress.lanes = 0),\\n        updateOffscreenComponent(current, workInProgress, renderLanes)\\n      );\\n    case 24:\\n      pushProvider(workInProgress, CacheContext, current.memoizedState.cache);\\n  }\\n  return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\\n}\\nfunction beginWork(current, workInProgress, renderLanes) {\\n  if (null !== current)\\n    if (current.memoizedProps !== workInProgress.pendingProps)\\n      didReceiveUpdate = !0;\\n    else {\\n      if (\\n        !checkScheduledUpdateOrContext(current, renderLanes) &&\\n        0 === (workInProgress.flags & 128)\\n      )\\n        return (\\n          (didReceiveUpdate = !1),\\n          attemptEarlyBailoutIfNoScheduledUpdate(\\n            current,\\n            workInProgress,\\n            renderLanes\\n          )\\n        );\\n      didReceiveUpdate = 0 !== (current.flags & 131072) ? !0 : !1;\\n    }\\n  else\\n    (didReceiveUpdate = !1),\\n      isHydrating &&\\n        0 !== (workInProgress.flags & 1048576) &&\\n        pushTreeId(workInProgress, treeForkCount, workInProgress.index);\\n  workInProgress.lanes = 0;\\n  switch (workInProgress.tag) {\\n    case 16:\\n      a: {\\n        current = workInProgress.pendingProps;\\n        var lazyComponent = workInProgress.elementType,\\n          init = lazyComponent._init;\\n        lazyComponent = init(lazyComponent._payload);\\n        workInProgress.type = lazyComponent;\\n        if (\"function\" === typeof lazyComponent)\\n          shouldConstruct(lazyComponent)\\n            ? ((current = resolveClassComponentProps(lazyComponent, current)),\\n              (workInProgress.tag = 1),\\n              (workInProgress = updateClassComponent(\\n                null,\\n                workInProgress,\\n                lazyComponent,\\n                current,\\n                renderLanes\\n              )))\\n            : ((workInProgress.tag = 0),\\n              (workInProgress = updateFunctionComponent(\\n                null,\\n                workInProgress,\\n                lazyComponent,\\n                current,\\n                renderLanes\\n              )));\\n        else {\\n          if (void 0 !== lazyComponent && null !== lazyComponent)\\n            if (\\n              ((init = lazyComponent.$$typeof), init === REACT_FORWARD_REF_TYPE)\\n            ) {\\n              workInProgress.tag = 11;\\n              workInProgress = updateForwardRef(\\n                null,\\n                workInProgress,\\n                lazyComponent,\\n                current,\\n                renderLanes\\n              );\\n              break a;\\n            } else if (init === REACT_MEMO_TYPE) {\\n              workInProgress.tag = 14;\\n              workInProgress = updateMemoComponent(\\n                null,\\n                workInProgress,\\n                lazyComponent,\\n                current,\\n                renderLanes\\n              );\\n              break a;\\n            }\\n          workInProgress =\\n            getComponentNameFromType(lazyComponent) || lazyComponent;\\n          throw Error(formatProdErrorMessage(306, workInProgress, \"\"));\\n        }\\n      }\\n      return workInProgress;\\n    case 0:\\n      return updateFunctionComponent(\\n        current,\\n        workInProgress,\\n        workInProgress.type,\\n        workInProgress.pendingProps,\\n        renderLanes\\n      );\\n    case 1:\\n      return (\\n        (lazyComponent = workInProgress.type),\\n        (init = resolveClassComponentProps(\\n          lazyComponent,\\n          workInProgress.pendingProps\\n        )),\\n        updateClassComponent(\\n          current,\\n          workInProgress,\\n          lazyComponent,\\n          init,\\n          renderLanes\\n        )\\n      );\\n    case 3:\\n      a: {\\n        pushHostContainer(\\n          workInProgress,\\n          workInProgress.stateNode.containerInfo\\n        );\\n        if (null === current) throw Error(formatProdErrorMessage(387));\\n        lazyComponent = workInProgress.pendingProps;\\n        var prevState = workInProgress.memoizedState;\\n        init = prevState.element;\\n        cloneUpdateQueue(current, workInProgress);\\n        processUpdateQueue(workInProgress, lazyComponent, null, renderLanes);\\n        var nextState = workInProgress.memoizedState;\\n        lazyComponent = nextState.cache;\\n        pushProvider(workInProgress, CacheContext, lazyComponent);\\n        lazyComponent !== prevState.cache &&\\n          propagateContextChanges(\\n            workInProgress,\\n            [CacheContext],\\n            renderLanes,\\n            !0\\n          );\\n        suspendIfUpdateReadFromEntangledAsyncAction();\\n        lazyComponent = nextState.element;\\n        if (prevState.isDehydrated)\\n          if (\\n            ((prevState = {\\n              element: lazyComponent,\\n              isDehydrated: !1,\\n              cache: nextState.cache\\n            }),\\n            (workInProgress.updateQueue.baseState = prevState),\\n            (workInProgress.memoizedState = prevState),\\n            workInProgress.flags & 256)\\n          ) {\\n            workInProgress = mountHostRootWithoutHydrating(\\n              current,\\n              workInProgress,\\n              lazyComponent,\\n              renderLanes\\n            );\\n            break a;\\n          } else if (lazyComponent !== init) {\\n            init = createCapturedValueAtFiber(\\n              Error(formatProdErrorMessage(424)),\\n              workInProgress\\n            );\\n            queueHydrationError(init);\\n            workInProgress = mountHostRootWithoutHydrating(\\n              current,\\n              workInProgress,\\n              lazyComponent,\\n              renderLanes\\n            );\\n            break a;\\n          } else {\\n            current = workInProgress.stateNode.containerInfo;\\n            switch (current.nodeType) {\\n              case 9:\\n                current = current.body;\\n                break;\\n              default:\\n                current =\\n                  \"HTML\" === current.nodeName\\n                    ? current.ownerDocument.body\\n                    : current;\\n            }\\n            nextHydratableInstance = getNextHydratable(current.firstChild);\\n            hydrationParentFiber = workInProgress;\\n            isHydrating = !0;\\n            hydrationErrors = null;\\n            rootOrSingletonContext = !0;\\n            renderLanes = mountChildFibers(\\n              workInProgress,\\n              null,\\n              lazyComponent,\\n              renderLanes\\n            );\\n            for (workInProgress.child = renderLanes; renderLanes; )\\n              (renderLanes.flags = (renderLanes.flags & -3) | 4096),\\n                (renderLanes = renderLanes.sibling);\\n          }\\n        else {\\n          resetHydrationState();\\n          if (lazyComponent === init) {\\n            workInProgress = bailoutOnAlreadyFinishedWork(\\n              current,\\n              workInProgress,\\n              renderLanes\\n            );\\n            break a;\\n          }\\n          reconcileChildren(\\n            current,\\n            workInProgress,\\n            lazyComponent,\\n            renderLanes\\n          );\\n        }\\n        workInProgress = workInProgress.child;\\n      }\\n      return workInProgress;\\n    case 26:\\n      return (\\n        markRef(current, workInProgress),\\n        null === current\\n          ? (renderLanes = getResource(\\n              workInProgress.type,\\n              null,\\n              workInProgress.pendingProps,\\n              null\\n            ))\\n            ? (workInProgress.memoizedState = renderLanes)\\n            : isHydrating ||\\n              ((renderLanes = workInProgress.type),\\n              (current = workInProgress.pendingProps),\\n              (lazyComponent = getOwnerDocumentFromRootContainer(\\n                rootInstanceStackCursor.current\\n              ).createElement(renderLanes)),\\n              (lazyComponent[internalInstanceKey] = workInProgress),\\n              (lazyComponent[internalPropsKey] = current),\\n              setInitialProperties(lazyComponent, renderLanes, current),\\n              markNodeAsHoistable(lazyComponent),\\n              (workInProgress.stateNode = lazyComponent))\\n          : (workInProgress.memoizedState = getResource(\\n              workInProgress.type,\\n              current.memoizedProps,\\n              workInProgress.pendingProps,\\n              current.memoizedState\\n            )),\\n        null\\n      );\\n    case 27:\\n      return (\\n        pushHostContext(workInProgress),\\n        null === current &&\\n          isHydrating &&\\n          ((lazyComponent = workInProgress.stateNode =\\n            resolveSingletonInstance(\\n              workInProgress.type,\\n              workInProgress.pendingProps,\\n              rootInstanceStackCursor.current\\n            )),\\n          (hydrationParentFiber = workInProgress),\\n          (rootOrSingletonContext = !0),\\n          (init = nextHydratableInstance),\\n          isSingletonScope(workInProgress.type)\\n            ? ((previousHydratableOnEnteringScopedSingleton = init),\\n              (nextHydratableInstance = getNextHydratable(\\n                lazyComponent.firstChild\\n              )))\\n            : (nextHydratableInstance = init)),\\n        reconcileChildren(\\n          current,\\n          workInProgress,\\n          workInProgress.pendingProps.children,\\n          renderLanes\\n        ),\\n        markRef(current, workInProgress),\\n        null === current && (workInProgress.flags |= 4194304),\\n        workInProgress.child\\n      );\\n    case 5:\\n      if (null === current && isHydrating) {\\n        if ((init = lazyComponent = nextHydratableInstance))\\n          (lazyComponent = canHydrateInstance(\\n            lazyComponent,\\n            workInProgress.type,\\n            workInProgress.pendingProps,\\n            rootOrSingletonContext\\n          )),\\n            null !== lazyComponent\\n              ? ((workInProgress.stateNode = lazyComponent),\\n                (hydrationParentFiber = workInProgress),\\n                (nextHydratableInstance = getNextHydratable(\\n                  lazyComponent.firstChild\\n                )),\\n                (rootOrSingletonContext = !1),\\n                (init = !0))\\n              : (init = !1);\\n        init || throwOnHydrationMismatch(workInProgress);\\n      }\\n      pushHostContext(workInProgress);\\n      init = workInProgress.type;\\n      prevState = workInProgress.pendingProps;\\n      nextState = null !== current ? current.memoizedProps : null;\\n      lazyComponent = prevState.children;\\n      shouldSetTextContent(init, prevState)\\n        ? (lazyComponent = null)\\n        : null !== nextState &&\\n          shouldSetTextContent(init, nextState) &&\\n          (workInProgress.flags |= 32);\\n      null !== workInProgress.memoizedState &&\\n        ((init = renderWithHooks(\\n          current,\\n          workInProgress,\\n          TransitionAwareHostComponent,\\n          null,\\n          null,\\n          renderLanes\\n        )),\\n        (HostTransitionContext._currentValue = init));\\n      markRef(current, workInProgress);\\n      reconcileChildren(current, workInProgress, lazyComponent, renderLanes);\\n      return workInProgress.child;\\n    case 6:\\n      if (null === current && isHydrating) {\\n        if ((current = renderLanes = nextHydratableInstance))\\n          (renderLanes = canHydrateTextInstance(\\n            renderLanes,\\n            workInProgress.pendingProps,\\n            rootOrSingletonContext\\n          )),\\n            null !== renderLanes\\n              ? ((workInProgress.stateNode = renderLanes),\\n                (hydrationParentFiber = workInProgress),\\n                (nextHydratableInstance = null),\\n                (current = !0))\\n              : (current = !1);\\n        current || throwOnHydrationMismatch(workInProgress);\\n      }\\n      return null;\\n    case 13:\\n      return updateSuspenseComponent(current, workInProgress, renderLanes);\\n    case 4:\\n      return (\\n        pushHostContainer(\\n          workInProgress,\\n          workInProgress.stateNode.containerInfo\\n        ),\\n        (lazyComponent = workInProgress.pendingProps),\\n        null === current\\n          ? (workInProgress.child = reconcileChildFibers(\\n              workInProgress,\\n              null,\\n              lazyComponent,\\n              renderLanes\\n            ))\\n          : reconcileChildren(\\n              current,\\n              workInProgress,\\n              lazyComponent,\\n              renderLanes\\n            ),\\n        workInProgress.child\\n      );\\n    case 11:\\n      return updateForwardRef(\\n        current,\\n        workInProgress,\\n        workInProgress.type,\\n        workInProgress.pendingProps,\\n        renderLanes\\n      );\\n    case 7:\\n      return (\\n        reconcileChildren(\\n          current,\\n          workInProgress,\\n          workInProgress.pendingProps,\\n          renderLanes\\n        ),\\n        workInProgress.child\\n      );\\n    case 8:\\n      return (\\n        reconcileChildren(\\n          current,\\n          workInProgress,\\n          workInProgress.pendingProps.children,\\n          renderLanes\\n        ),\\n        workInProgress.child\\n      );\\n    case 12:\\n      return (\\n        reconcileChildren(\\n          current,\\n          workInProgress,\\n          workInProgress.pendingProps.children,\\n          renderLanes\\n        ),\\n        workInProgress.child\\n      );\\n    case 10:\\n      return (\\n        (lazyComponent = workInProgress.pendingProps),\\n        pushProvider(workInProgress, workInProgress.type, lazyComponent.value),\\n        reconcileChildren(\\n          current,\\n          workInProgress,\\n          lazyComponent.children,\\n          renderLanes\\n        ),\\n        workInProgress.child\\n      );\\n    case 9:\\n      return (\\n        (init = workInProgress.type._context),\\n        (lazyComponent = workInProgress.pendingProps.children),\\n        prepareToReadContext(workInProgress),\\n        (init = readContext(init)),\\n        (lazyComponent = lazyComponent(init)),\\n        (workInProgress.flags |= 1),\\n        reconcileChildren(current, workInProgress, lazyComponent, renderLanes),\\n        workInProgress.child\\n      );\\n    case 14:\\n      return updateMemoComponent(\\n        current,\\n        workInProgress,\\n        workInProgress.type,\\n        workInProgress.pendingProps,\\n        renderLanes\\n      );\\n    case 15:\\n      return updateSimpleMemoComponent(\\n        current,\\n        workInProgress,\\n        workInProgress.type,\\n        workInProgress.pendingProps,\\n        renderLanes\\n      );\\n    case 19:\\n      return updateSuspenseListComponent(current, workInProgress, renderLanes);\\n    case 31:\\n      return (\\n        (lazyComponent = workInProgress.pendingProps),\\n        (renderLanes = workInProgress.mode),\\n        (lazyComponent = {\\n          mode: lazyComponent.mode,\\n          children: lazyComponent.children\\n        }),\\n        null === current\\n          ? ((renderLanes = mountWorkInProgressOffscreenFiber(\\n              lazyComponent,\\n              renderLanes\\n            )),\\n            (renderLanes.ref = workInProgress.ref),\\n            (workInProgress.child = renderLanes),\\n            (renderLanes.return = workInProgress),\\n            (workInProgress = renderLanes))\\n          : ((renderLanes = createWorkInProgress(current.child, lazyComponent)),\\n            (renderLanes.ref = workInProgress.ref),\\n            (workInProgress.child = renderLanes),\\n            (renderLanes.return = workInProgress),\\n            (workInProgress = renderLanes)),\\n        workInProgress\\n      );\\n    case 22:\\n      return updateOffscreenComponent(current, workInProgress, renderLanes);\\n    case 24:\\n      return (\\n        prepareToReadContext(workInProgress),\\n        (lazyComponent = readContext(CacheContext)),\\n        null === current\\n          ? ((init = peekCacheFromPool()),\\n            null === init &&\\n              ((init = workInProgressRoot),\\n              (prevState = createCache()),\\n              (init.pooledCache = prevState),\\n              prevState.refCount++,\\n              null !== prevState && (init.pooledCacheLanes |= renderLanes),\\n              (init = prevState)),\\n            (workInProgress.memoizedState = {\\n              parent: lazyComponent,\\n              cache: init\\n            }),\\n            initializeUpdateQueue(workInProgress),\\n            pushProvider(workInProgress, CacheContext, init))\\n          : (0 !== (current.lanes & renderLanes) &&\\n              (cloneUpdateQueue(current, workInProgress),\\n              processUpdateQueue(workInProgress, null, null, renderLanes),\\n              suspendIfUpdateReadFromEntangledAsyncAction()),\\n            (init = current.memoizedState),\\n            (prevState = workInProgress.memoizedState),\\n            init.parent !== lazyComponent\\n              ? ((init = { parent: lazyComponent, cache: lazyComponent }),\\n                (workInProgress.memoizedState = init),\\n                0 === workInProgress.lanes &&\\n                  (workInProgress.memoizedState =\\n                    workInProgress.updateQueue.baseState =\\n                      init),\\n                pushProvider(workInProgress, CacheContext, lazyComponent))\\n              : ((lazyComponent = prevState.cache),\\n                pushProvider(workInProgress, CacheContext, lazyComponent),\\n                lazyComponent !== init.cache &&\\n                  propagateContextChanges(\\n                    workInProgress,\\n                    [CacheContext],\\n                    renderLanes,\\n                    !0\\n                  ))),\\n        reconcileChildren(\\n          current,\\n          workInProgress,\\n          workInProgress.pendingProps.children,\\n          renderLanes\\n        ),\\n        workInProgress.child\\n      );\\n    case 29:\\n      throw workInProgress.pendingProps;\\n  }\\n  throw Error(formatProdErrorMessage(156, workInProgress.tag));\\n}\\nfunction markUpdate(workInProgress) {\\n  workInProgress.flags |= 4;\\n}\\nfunction preloadResourceAndSuspendIfNeeded(workInProgress, resource) {\\n  if (\"stylesheet\" !== resource.type || 0 !== (resource.state.loading & 4))\\n    workInProgress.flags &= -16777217;\\n  else if (((workInProgress.flags |= 16777216), !preloadResource(resource))) {\\n    resource = suspenseHandlerStackCursor.current;\\n    if (\\n      null !== resource &&\\n      ((workInProgressRootRenderLanes & 4194048) ===\\n      workInProgressRootRenderLanes\\n        ? null !== shellBoundary\\n        : ((workInProgressRootRenderLanes & 62914560) !==\\n            workInProgressRootRenderLanes &&\\n            0 === (workInProgressRootRenderLanes & 536870912)) ||\\n          resource !== shellBoundary)\\n    )\\n      throw (\\n        ((suspendedThenable = noopSuspenseyCommitThenable),\\n        SuspenseyCommitException)\\n      );\\n    workInProgress.flags |= 8192;\\n  }\\n}\\nfunction scheduleRetryEffect(workInProgress, retryQueue) {\\n  null !== retryQueue && (workInProgress.flags |= 4);\\n  workInProgress.flags & 16384 &&\\n    ((retryQueue =\\n      22 !== workInProgress.tag ? claimNextRetryLane() : 536870912),\\n    (workInProgress.lanes |= retryQueue),\\n    (workInProgressSuspendedRetryLanes |= retryQueue));\\n}\\nfunction cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {\\n  if (!isHydrating)\\n    switch (renderState.tailMode) {\\n      case \"hidden\":\\n        hasRenderedATailFallback = renderState.tail;\\n        for (var lastTailNode = null; null !== hasRenderedATailFallback; )\\n          null !== hasRenderedATailFallback.alternate &&\\n            (lastTailNode = hasRenderedATailFallback),\\n            (hasRenderedATailFallback = hasRenderedATailFallback.sibling);\\n        null === lastTailNode\\n          ? (renderState.tail = null)\\n          : (lastTailNode.sibling = null);\\n        break;\\n      case \"collapsed\":\\n        lastTailNode = renderState.tail;\\n        for (var lastTailNode$113 = null; null !== lastTailNode; )\\n          null !== lastTailNode.alternate && (lastTailNode$113 = lastTailNode),\\n            (lastTailNode = lastTailNode.sibling);\\n        null === lastTailNode$113\\n          ? hasRenderedATailFallback || null === renderState.tail\\n            ? (renderState.tail = null)\\n            : (renderState.tail.sibling = null)\\n          : (lastTailNode$113.sibling = null);\\n    }\\n}\\nfunction bubbleProperties(completedWork) {\\n  var didBailout =\\n      null !== completedWork.alternate &&\\n      completedWork.alternate.child === completedWork.child,\\n    newChildLanes = 0,\\n    subtreeFlags = 0;\\n  if (didBailout)\\n    for (var child$114 = completedWork.child; null !== child$114; )\\n      (newChildLanes |= child$114.lanes | child$114.childLanes),\\n        (subtreeFlags |= child$114.subtreeFlags & 65011712),\\n        (subtreeFlags |= child$114.flags & 65011712),\\n        (child$114.return = completedWork),\\n        (child$114 = child$114.sibling);\\n  else\\n    for (child$114 = completedWork.child; null !== child$114; )\\n      (newChildLanes |= child$114.lanes | child$114.childLanes),\\n        (subtreeFlags |= child$114.subtreeFlags),\\n        (subtreeFlags |= child$114.flags),\\n        (child$114.return = completedWork),\\n        (child$114 = child$114.sibling);\\n  completedWork.subtreeFlags |= subtreeFlags;\\n  completedWork.childLanes = newChildLanes;\\n  return didBailout;\\n}\\nfunction completeWork(current, workInProgress, renderLanes) {\\n  var newProps = workInProgress.pendingProps;\\n  popTreeContext(workInProgress);\\n  switch (workInProgress.tag) {\\n    case 31:\\n    case 16:\\n    case 15:\\n    case 0:\\n    case 11:\\n    case 7:\\n    case 8:\\n    case 12:\\n    case 9:\\n    case 14:\\n      return bubbleProperties(workInProgress), null;\\n    case 1:\\n      return bubbleProperties(workInProgress), null;\\n    case 3:\\n      renderLanes = workInProgress.stateNode;\\n      newProps = null;\\n      null !== current && (newProps = current.memoizedState.cache);\\n      workInProgress.memoizedState.cache !== newProps &&\\n        (workInProgress.flags |= 2048);\\n      popProvider(CacheContext);\\n      popHostContainer();\\n      renderLanes.pendingContext &&\\n        ((renderLanes.context = renderLanes.pendingContext),\\n        (renderLanes.pendingContext = null));\\n      if (null === current || null === current.child)\\n        popHydrationState(workInProgress)\\n          ? markUpdate(workInProgress)\\n          : null === current ||\\n            (current.memoizedState.isDehydrated &&\\n              0 === (workInProgress.flags & 256)) ||\\n            ((workInProgress.flags |= 1024),\\n            upgradeHydrationErrorsToRecoverable());\\n      bubbleProperties(workInProgress);\\n      return null;\\n    case 26:\\n      return (\\n        (renderLanes = workInProgress.memoizedState),\\n        null === current\\n          ? (markUpdate(workInProgress),\\n            null !== renderLanes\\n              ? (bubbleProperties(workInProgress),\\n                preloadResourceAndSuspendIfNeeded(workInProgress, renderLanes))\\n              : (bubbleProperties(workInProgress),\\n                (workInProgress.flags &= -16777217)))\\n          : renderLanes\\n            ? renderLanes !== current.memoizedState\\n              ? (markUpdate(workInProgress),\\n                bubbleProperties(workInProgress),\\n                preloadResourceAndSuspendIfNeeded(workInProgress, renderLanes))\\n              : (bubbleProperties(workInProgress),\\n                (workInProgress.flags &= -16777217))\\n            : (current.memoizedProps !== newProps && markUpdate(workInProgress),\\n              bubbleProperties(workInProgress),\\n              (workInProgress.flags &= -16777217)),\\n        null\\n      );\\n    case 27:\\n      popHostContext(workInProgress);\\n      renderLanes = rootInstanceStackCursor.current;\\n      var type = workInProgress.type;\\n      if (null !== current && null != workInProgress.stateNode)\\n        current.memoizedProps !== newProps && markUpdate(workInProgress);\\n      else {\\n        if (!newProps) {\\n          if (null === workInProgress.stateNode)\\n            throw Error(formatProdErrorMessage(166));\\n          bubbleProperties(workInProgress);\\n          return null;\\n        }\\n        current = contextStackCursor.current;\\n        popHydrationState(workInProgress)\\n          ? prepareToHydrateHostInstance(workInProgress, current)\\n          : ((current = resolveSingletonInstance(type, newProps, renderLanes)),\\n            (workInProgress.stateNode = current),\\n            markUpdate(workInProgress));\\n      }\\n      bubbleProperties(workInProgress);\\n      return null;\\n    case 5:\\n      popHostContext(workInProgress);\\n      renderLanes = workInProgress.type;\\n      if (null !== current && null != workInProgress.stateNode)\\n        current.memoizedProps !== newProps && markUpdate(workInProgress);\\n      else {\\n        if (!newProps) {\\n          if (null === workInProgress.stateNode)\\n            throw Error(formatProdErrorMessage(166));\\n          bubbleProperties(workInProgress);\\n          return null;\\n        }\\n        current = contextStackCursor.current;\\n        if (popHydrationState(workInProgress))\\n          prepareToHydrateHostInstance(workInProgress, current);\\n        else {\\n          type = getOwnerDocumentFromRootContainer(\\n            rootInstanceStackCursor.current\\n          );\\n          switch (current) {\\n            case 1:\\n              current = type.createElementNS(\\n                \"http://www.w3.org/2000/svg\",\\n                renderLanes\\n              );\\n              break;\\n            case 2:\\n              current = type.createElementNS(\\n                \"http://www.w3.org/1998/Math/MathML\",\\n                renderLanes\\n              );\\n              break;\\n            default:\\n              switch (renderLanes) {\\n                case \"svg\":\\n                  current = type.createElementNS(\\n                    \"http://www.w3.org/2000/svg\",\\n                    renderLanes\\n                  );\\n                  break;\\n                case \"math\":\\n                  current = type.createElementNS(\\n                    \"http://www.w3.org/1998/Math/MathML\",\\n                    renderLanes\\n                  );\\n                  break;\\n                case \"script\":\\n                  current = type.createElement(\"div\");\\n                  current.innerHTML = \"<script>\\\\x3c/script>\";\\n                  current = current.removeChild(current.firstChild);\\n                  break;\\n                case \"select\":\\n                  current =\\n                    \"string\" === typeof newProps.is\\n                      ? type.createElement(\"select\", { is: newProps.is })\\n                      : type.createElement(\"select\");\\n                  newProps.multiple\\n                    ? (current.multiple = !0)\\n                    : newProps.size && (current.size = newProps.size);\\n                  break;\\n                default:\\n                  current =\\n                    \"string\" === typeof newProps.is\\n                      ? type.createElement(renderLanes, { is: newProps.is })\\n                      : type.createElement(renderLanes);\\n              }\\n          }\\n          current[internalInstanceKey] = workInProgress;\\n          current[internalPropsKey] = newProps;\\n          a: for (type = workInProgress.child; null !== type; ) {\\n            if (5 === type.tag || 6 === type.tag)\\n              current.appendChild(type.stateNode);\\n            else if (4 !== type.tag && 27 !== type.tag && null !== type.child) {\\n              type.child.return = type;\\n              type = type.child;\\n              continue;\\n            }\\n            if (type === workInProgress) break a;\\n            for (; null === type.sibling; ) {\\n              if (null === type.return || type.return === workInProgress)\\n                break a;\\n              type = type.return;\\n            }\\n            type.sibling.return = type.return;\\n            type = type.sibling;\\n          }\\n          workInProgress.stateNode = current;\\n          a: switch (\\n            (setInitialProperties(current, renderLanes, newProps), renderLanes)\\n          ) {\\n            case \"button\":\\n            case \"input\":\\n            case \"select\":\\n            case \"textarea\":\\n              current = !!newProps.autoFocus;\\n              break a;\\n            case \"img\":\\n              current = !0;\\n              break a;\\n            default:\\n              current = !1;\\n          }\\n          current && markUpdate(workInProgress);\\n        }\\n      }\\n      bubbleProperties(workInProgress);\\n      workInProgress.flags &= -16777217;\\n      return null;\\n    case 6:\\n      if (current && null != workInProgress.stateNode)\\n        current.memoizedProps !== newProps && markUpdate(workInProgress);\\n      else {\\n        if (\"string\" !== typeof newProps && null === workInProgress.stateNode)\\n          throw Error(formatProdErrorMessage(166));\\n        current = rootInstanceStackCursor.current;\\n        if (popHydrationState(workInProgress)) {\\n          current = workInProgress.stateNode;\\n          renderLanes = workInProgress.memoizedProps;\\n          newProps = null;\\n          type = hydrationParentFiber;\\n          if (null !== type)\\n            switch (type.tag) {\\n              case 27:\\n              case 5:\\n                newProps = type.memoizedProps;\\n            }\\n          current[internalInstanceKey] = workInProgress;\\n          current =\\n            current.nodeValue === renderLanes ||\\n            (null !== newProps && !0 === newProps.suppressHydrationWarning) ||\\n            checkForUnmatchedText(current.nodeValue, renderLanes)\\n              ? !0\\n              : !1;\\n          current || throwOnHydrationMismatch(workInProgress);\\n        } else\\n          (current =\\n            getOwnerDocumentFromRootContainer(current).createTextNode(\\n              newProps\\n            )),\\n            (current[internalInstanceKey] = workInProgress),\\n            (workInProgress.stateNode = current);\\n      }\\n      bubbleProperties(workInProgress);\\n      return null;\\n    case 13:\\n      newProps = workInProgress.memoizedState;\\n      if (\\n        null === current ||\\n        (null !== current.memoizedState &&\\n          null !== current.memoizedState.dehydrated)\\n      ) {\\n        type = popHydrationState(workInProgress);\\n        if (null !== newProps && null !== newProps.dehydrated) {\\n          if (null === current) {\\n            if (!type) throw Error(formatProdErrorMessage(318));\\n            type = workInProgress.memoizedState;\\n            type = null !== type ? type.dehydrated : null;\\n            if (!type) throw Error(formatProdErrorMessage(317));\\n            type[internalInstanceKey] = workInProgress;\\n          } else\\n            resetHydrationState(),\\n              0 === (workInProgress.flags & 128) &&\\n                (workInProgress.memoizedState = null),\\n              (workInProgress.flags |= 4);\\n          bubbleProperties(workInProgress);\\n          type = !1;\\n        } else\\n          (type = upgradeHydrationErrorsToRecoverable()),\\n            null !== current &&\\n              null !== current.memoizedState &&\\n              (current.memoizedState.hydrationErrors = type),\\n            (type = !0);\\n        if (!type) {\\n          if (workInProgress.flags & 256)\\n            return popSuspenseHandler(workInProgress), workInProgress;\\n          popSuspenseHandler(workInProgress);\\n          return null;\\n        }\\n      }\\n      popSuspenseHandler(workInProgress);\\n      if (0 !== (workInProgress.flags & 128))\\n        return (workInProgress.lanes = renderLanes), workInProgress;\\n      renderLanes = null !== newProps;\\n      current = null !== current && null !== current.memoizedState;\\n      if (renderLanes) {\\n        newProps = workInProgress.child;\\n        type = null;\\n        null !== newProps.alternate &&\\n          null !== newProps.alternate.memoizedState &&\\n          null !== newProps.alternate.memoizedState.cachePool &&\\n          (type = newProps.alternate.memoizedState.cachePool.pool);\\n        var cache$127 = null;\\n        null !== newProps.memoizedState &&\\n          null !== newProps.memoizedState.cachePool &&\\n          (cache$127 = newProps.memoizedState.cachePool.pool);\\n        cache$127 !== type && (newProps.flags |= 2048);\\n      }\\n      renderLanes !== current &&\\n        renderLanes &&\\n        (workInProgress.child.flags |= 8192);\\n      scheduleRetryEffect(workInProgress, workInProgress.updateQueue);\\n      bubbleProperties(workInProgress);\\n      return null;\\n    case 4:\\n      return (\\n        popHostContainer(),\\n        null === current &&\\n          listenToAllSupportedEvents(workInProgress.stateNode.containerInfo),\\n        bubbleProperties(workInProgress),\\n        null\\n      );\\n    case 10:\\n      return (\\n        popProvider(workInProgress.type), bubbleProperties(workInProgress), null\\n      );\\n    case 19:\\n      pop(suspenseStackCursor);\\n      type = workInProgress.memoizedState;\\n      if (null === type) return bubbleProperties(workInProgress), null;\\n      newProps = 0 !== (workInProgress.flags & 128);\\n      cache$127 = type.rendering;\\n      if (null === cache$127)\\n        if (newProps) cutOffTailIfNeeded(type, !1);\\n        else {\\n          if (\\n            0 !== workInProgressRootExitStatus ||\\n            (null !== current && 0 !== (current.flags & 128))\\n          )\\n            for (current = workInProgress.child; null !== current; ) {\\n              cache$127 = findFirstSuspended(current);\\n              if (null !== cache$127) {\\n                workInProgress.flags |= 128;\\n                cutOffTailIfNeeded(type, !1);\\n                current = cache$127.updateQueue;\\n                workInProgress.updateQueue = current;\\n                scheduleRetryEffect(workInProgress, current);\\n                workInProgress.subtreeFlags = 0;\\n                current = renderLanes;\\n                for (renderLanes = workInProgress.child; null !== renderLanes; )\\n                  resetWorkInProgress(renderLanes, current),\\n                    (renderLanes = renderLanes.sibling);\\n                push(\\n                  suspenseStackCursor,\\n                  (suspenseStackCursor.current & 1) | 2\\n                );\\n                return workInProgress.child;\\n              }\\n              current = current.sibling;\\n            }\\n          null !== type.tail &&\\n            now() > workInProgressRootRenderTargetTime &&\\n            ((workInProgress.flags |= 128),\\n            (newProps = !0),\\n            cutOffTailIfNeeded(type, !1),\\n            (workInProgress.lanes = 4194304));\\n        }\\n      else {\\n        if (!newProps)\\n          if (((current = findFirstSuspended(cache$127)), null !== current)) {\\n            if (\\n              ((workInProgress.flags |= 128),\\n              (newProps = !0),\\n              (current = current.updateQueue),\\n              (workInProgress.updateQueue = current),\\n              scheduleRetryEffect(workInProgress, current),\\n              cutOffTailIfNeeded(type, !0),\\n              null === type.tail &&\\n                \"hidden\" === type.tailMode &&\\n                !cache$127.alternate &&\\n                !isHydrating)\\n            )\\n              return bubbleProperties(workInProgress), null;\\n          } else\\n            2 * now() - type.renderingStartTime >\\n              workInProgressRootRenderTargetTime &&\\n              536870912 !== renderLanes &&\\n              ((workInProgress.flags |= 128),\\n              (newProps = !0),\\n              cutOffTailIfNeeded(type, !1),\\n              (workInProgress.lanes = 4194304));\\n        type.isBackwards\\n          ? ((cache$127.sibling = workInProgress.child),\\n            (workInProgress.child = cache$127))\\n          : ((current = type.last),\\n            null !== current\\n              ? (current.sibling = cache$127)\\n              : (workInProgress.child = cache$127),\\n            (type.last = cache$127));\\n      }\\n      if (null !== type.tail)\\n        return (\\n          (workInProgress = type.tail),\\n          (type.rendering = workInProgress),\\n          (type.tail = workInProgress.sibling),\\n          (type.renderingStartTime = now()),\\n          (workInProgress.sibling = null),\\n          (current = suspenseStackCursor.current),\\n          push(suspenseStackCursor, newProps ? (current & 1) | 2 : current & 1),\\n          workInProgress\\n        );\\n      bubbleProperties(workInProgress);\\n      return null;\\n    case 22:\\n    case 23:\\n      return (\\n        popSuspenseHandler(workInProgress),\\n        popHiddenContext(),\\n        (newProps = null !== workInProgress.memoizedState),\\n        null !== current\\n          ? (null !== current.memoizedState) !== newProps &&\\n            (workInProgress.flags |= 8192)\\n          : newProps && (workInProgress.flags |= 8192),\\n        newProps\\n          ? 0 !== (renderLanes & 536870912) &&\\n            0 === (workInProgress.flags & 128) &&\\n            (bubbleProperties(workInProgress),\\n            workInProgress.subtreeFlags & 6 && (workInProgress.flags |= 8192))\\n          : bubbleProperties(workInProgress),\\n        (renderLanes = workInProgress.updateQueue),\\n        null !== renderLanes &&\\n          scheduleRetryEffect(workInProgress, renderLanes.retryQueue),\\n        (renderLanes = null),\\n        null !== current &&\\n          null !== current.memoizedState &&\\n          null !== current.memoizedState.cachePool &&\\n          (renderLanes = current.memoizedState.cachePool.pool),\\n        (newProps = null),\\n        null !== workInProgress.memoizedState &&\\n          null !== workInProgress.memoizedState.cachePool &&\\n          (newProps = workInProgress.memoizedState.cachePool.pool),\\n        newProps !== renderLanes && (workInProgress.flags |= 2048),\\n        null !== current && pop(resumedCache),\\n        null\\n      );\\n    case 24:\\n      return (\\n        (renderLanes = null),\\n        null !== current && (renderLanes = current.memoizedState.cache),\\n        workInProgress.memoizedState.cache !== renderLanes &&\\n          (workInProgress.flags |= 2048),\\n        popProvider(CacheContext),\\n        bubbleProperties(workInProgress),\\n        null\\n      );\\n    case 25:\\n      return null;\\n    case 30:\\n      return null;\\n  }\\n  throw Error(formatProdErrorMessage(156, workInProgress.tag));\\n}\\nfunction unwindWork(current, workInProgress) {\\n  popTreeContext(workInProgress);\\n  switch (workInProgress.tag) {\\n    case 1:\\n      return (\\n        (current = workInProgress.flags),\\n        current & 65536\\n          ? ((workInProgress.flags = (current & -65537) | 128), workInProgress)\\n          : null\\n      );\\n    case 3:\\n      return (\\n        popProvider(CacheContext),\\n        popHostContainer(),\\n        (current = workInProgress.flags),\\n        0 !== (current & 65536) && 0 === (current & 128)\\n          ? ((workInProgress.flags = (current & -65537) | 128), workInProgress)\\n          : null\\n      );\\n    case 26:\\n    case 27:\\n    case 5:\\n      return popHostContext(workInProgress), null;\\n    case 13:\\n      popSuspenseHandler(workInProgress);\\n      current = workInProgress.memoizedState;\\n      if (null !== current && null !== current.dehydrated) {\\n        if (null === workInProgress.alternate)\\n          throw Error(formatProdErrorMessage(340));\\n        resetHydrationState();\\n      }\\n      current = workInProgress.flags;\\n      return current & 65536\\n        ? ((workInProgress.flags = (current & -65537) | 128), workInProgress)\\n        : null;\\n    case 19:\\n      return pop(suspenseStackCursor), null;\\n    case 4:\\n      return popHostContainer(), null;\\n    case 10:\\n      return popProvider(workInProgress.type), null;\\n    case 22:\\n    case 23:\\n      return (\\n        popSuspenseHandler(workInProgress),\\n        popHiddenContext(),\\n        null !== current && pop(resumedCache),\\n        (current = workInProgress.flags),\\n        current & 65536\\n          ? ((workInProgress.flags = (current & -65537) | 128), workInProgress)\\n          : null\\n      );\\n    case 24:\\n      return popProvider(CacheContext), null;\\n    case 25:\\n      return null;\\n    default:\\n      return null;\\n  }\\n}\\nfunction unwindInterruptedWork(current, interruptedWork) {\\n  popTreeContext(interruptedWork);\\n  switch (interruptedWork.tag) {\\n    case 3:\\n      popProvider(CacheContext);\\n      popHostContainer();\\n      break;\\n    case 26:\\n    case 27:\\n    case 5:\\n      popHostContext(interruptedWork);\\n      break;\\n    case 4:\\n      popHostContainer();\\n      break;\\n    case 13:\\n      popSuspenseHandler(interruptedWork);\\n      break;\\n    case 19:\\n      pop(suspenseStackCursor);\\n      break;\\n    case 10:\\n      popProvider(interruptedWork.type);\\n      break;\\n    case 22:\\n    case 23:\\n      popSuspenseHandler(interruptedWork);\\n      popHiddenContext();\\n      null !== current && pop(resumedCache);\\n      break;\\n    case 24:\\n      popProvider(CacheContext);\\n  }\\n}\\nfunction commitHookEffectListMount(flags, finishedWork) {\\n  try {\\n    var updateQueue = finishedWork.updateQueue,\\n      lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;\\n    if (null !== lastEffect) {\\n      var firstEffect = lastEffect.next;\\n      updateQueue = firstEffect;\\n      do {\\n        if ((updateQueue.tag & flags) === flags) {\\n          lastEffect = void 0;\\n          var create = updateQueue.create,\\n            inst = updateQueue.inst;\\n          lastEffect = create();\\n          inst.destroy = lastEffect;\\n        }\\n        updateQueue = updateQueue.next;\\n      } while (updateQueue !== firstEffect);\\n    }\\n  } catch (error) {\\n    captureCommitPhaseError(finishedWork, finishedWork.return, error);\\n  }\\n}\\nfunction commitHookEffectListUnmount(\\n  flags,\\n  finishedWork,\\n  nearestMountedAncestor$jscomp$0\\n) {\\n  try {\\n    var updateQueue = finishedWork.updateQueue,\\n      lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;\\n    if (null !== lastEffect) {\\n      var firstEffect = lastEffect.next;\\n      updateQueue = firstEffect;\\n      do {\\n        if ((updateQueue.tag & flags) === flags) {\\n          var inst = updateQueue.inst,\\n            destroy = inst.destroy;\\n          if (void 0 !== destroy) {\\n            inst.destroy = void 0;\\n            lastEffect = finishedWork;\\n            var nearestMountedAncestor = nearestMountedAncestor$jscomp$0,\\n              destroy_ = destroy;\\n            try {\\n              destroy_();\\n            } catch (error) {\\n              captureCommitPhaseError(\\n                lastEffect,\\n                nearestMountedAncestor,\\n                error\\n              );\\n            }\\n          }\\n        }\\n        updateQueue = updateQueue.next;\\n      } while (updateQueue !== firstEffect);\\n    }\\n  } catch (error) {\\n    captureCommitPhaseError(finishedWork, finishedWork.return, error);\\n  }\\n}\\nfunction commitClassCallbacks(finishedWork) {\\n  var updateQueue = finishedWork.updateQueue;\\n  if (null !== updateQueue) {\\n    var instance = finishedWork.stateNode;\\n    try {\\n      commitCallbacks(updateQueue, instance);\\n    } catch (error) {\\n      captureCommitPhaseError(finishedWork, finishedWork.return, error);\\n    }\\n  }\\n}\\nfunction safelyCallComponentWillUnmount(\\n  current,\\n  nearestMountedAncestor,\\n  instance\\n) {\\n  instance.props = resolveClassComponentProps(\\n    current.type,\\n    current.memoizedProps\\n  );\\n  instance.state = current.memoizedState;\\n  try {\\n    instance.componentWillUnmount();\\n  } catch (error) {\\n    captureCommitPhaseError(current, nearestMountedAncestor, error);\\n  }\\n}\\nfunction safelyAttachRef(current, nearestMountedAncestor) {\\n  try {\\n    var ref = current.ref;\\n    if (null !== ref) {\\n      switch (current.tag) {\\n        case 26:\\n        case 27:\\n        case 5:\\n          var instanceToUse = current.stateNode;\\n          break;\\n        case 30:\\n          instanceToUse = current.stateNode;\\n          break;\\n        default:\\n          instanceToUse = current.stateNode;\\n      }\\n      \"function\" === typeof ref\\n        ? (current.refCleanup = ref(instanceToUse))\\n        : (ref.current = instanceToUse);\\n    }\\n  } catch (error) {\\n    captureCommitPhaseError(current, nearestMountedAncestor, error);\\n  }\\n}\\nfunction safelyDetachRef(current, nearestMountedAncestor) {\\n  var ref = current.ref,\\n    refCleanup = current.refCleanup;\\n  if (null !== ref)\\n    if (\"function\" === typeof refCleanup)\\n      try {\\n        refCleanup();\\n      } catch (error) {\\n        captureCommitPhaseError(current, nearestMountedAncestor, error);\\n      } finally {\\n        (current.refCleanup = null),\\n          (current = current.alternate),\\n          null != current && (current.refCleanup = null);\\n      }\\n    else if (\"function\" === typeof ref)\\n      try {\\n        ref(null);\\n      } catch (error$143) {\\n        captureCommitPhaseError(current, nearestMountedAncestor, error$143);\\n      }\\n    else ref.current = null;\\n}\\nfunction commitHostMount(finishedWork) {\\n  var type = finishedWork.type,\\n    props = finishedWork.memoizedProps,\\n    instance = finishedWork.stateNode;\\n  try {\\n    a: switch (type) {\\n      case \"button\":\\n      case \"input\":\\n      case \"select\":\\n      case \"textarea\":\\n        props.autoFocus && instance.focus();\\n        break a;\\n      case \"img\":\\n        props.src\\n          ? (instance.src = props.src)\\n          : props.srcSet && (instance.srcset = props.srcSet);\\n    }\\n  } catch (error) {\\n    captureCommitPhaseError(finishedWork, finishedWork.return, error);\\n  }\\n}\\nfunction commitHostUpdate(finishedWork, newProps, oldProps) {\\n  try {\\n    var domElement = finishedWork.stateNode;\\n    updateProperties(domElement, finishedWork.type, oldProps, newProps);\\n    domElement[internalPropsKey] = newProps;\\n  } catch (error) {\\n    captureCommitPhaseError(finishedWork, finishedWork.return, error);\\n  }\\n}\\nfunction isHostParent(fiber) {\\n  return (\\n    5 === fiber.tag ||\\n    3 === fiber.tag ||\\n    26 === fiber.tag ||\\n    (27 === fiber.tag && isSingletonScope(fiber.type)) ||\\n    4 === fiber.tag\\n  );\\n}\\nfunction getHostSibling(fiber) {\\n  a: for (;;) {\\n    for (; null === fiber.sibling; ) {\\n      if (null === fiber.return || isHostParent(fiber.return)) return null;\\n      fiber = fiber.return;\\n    }\\n    fiber.sibling.return = fiber.return;\\n    for (\\n      fiber = fiber.sibling;\\n      5 !== fiber.tag && 6 !== fiber.tag && 18 !== fiber.tag;\\n\\n    ) {\\n      if (27 === fiber.tag && isSingletonScope(fiber.type)) continue a;\\n      if (fiber.flags & 2) continue a;\\n      if (null === fiber.child || 4 === fiber.tag) continue a;\\n      else (fiber.child.return = fiber), (fiber = fiber.child);\\n    }\\n    if (!(fiber.flags & 2)) return fiber.stateNode;\\n  }\\n}\\nfunction insertOrAppendPlacementNodeIntoContainer(node, before, parent) {\\n  var tag = node.tag;\\n  if (5 === tag || 6 === tag)\\n    (node = node.stateNode),\\n      before\\n        ? (9 === parent.nodeType\\n            ? parent.body\\n            : \"HTML\" === parent.nodeName\\n              ? parent.ownerDocument.body\\n              : parent\\n          ).insertBefore(node, before)\\n        : ((before =\\n            9 === parent.nodeType\\n              ? parent.body\\n              : \"HTML\" === parent.nodeName\\n                ? parent.ownerDocument.body\\n                : parent),\\n          before.appendChild(node),\\n          (parent = parent._reactRootContainer),\\n          (null !== parent && void 0 !== parent) ||\\n            null !== before.onclick ||\\n            (before.onclick = noop$1));\\n  else if (\\n    4 !== tag &&\\n    (27 === tag &&\\n      isSingletonScope(node.type) &&\\n      ((parent = node.stateNode), (before = null)),\\n    (node = node.child),\\n    null !== node)\\n  )\\n    for (\\n      insertOrAppendPlacementNodeIntoContainer(node, before, parent),\\n        node = node.sibling;\\n      null !== node;\\n\\n    )\\n      insertOrAppendPlacementNodeIntoContainer(node, before, parent),\\n        (node = node.sibling);\\n}\\nfunction insertOrAppendPlacementNode(node, before, parent) {\\n  var tag = node.tag;\\n  if (5 === tag || 6 === tag)\\n    (node = node.stateNode),\\n      before ? parent.insertBefore(node, before) : parent.appendChild(node);\\n  else if (\\n    4 !== tag &&\\n    (27 === tag && isSingletonScope(node.type) && (parent = node.stateNode),\\n    (node = node.child),\\n    null !== node)\\n  )\\n    for (\\n      insertOrAppendPlacementNode(node, before, parent), node = node.sibling;\\n      null !== node;\\n\\n    )\\n      insertOrAppendPlacementNode(node, before, parent), (node = node.sibling);\\n}\\nfunction commitHostSingletonAcquisition(finishedWork) {\\n  var singleton = finishedWork.stateNode,\\n    props = finishedWork.memoizedProps;\\n  try {\\n    for (\\n      var type = finishedWork.type, attributes = singleton.attributes;\\n      attributes.length;\\n\\n    )\\n      singleton.removeAttributeNode(attributes[0]);\\n    setInitialProperties(singleton, type, props);\\n    singleton[internalInstanceKey] = finishedWork;\\n    singleton[internalPropsKey] = props;\\n  } catch (error) {\\n    captureCommitPhaseError(finishedWork, finishedWork.return, error);\\n  }\\n}\\nvar offscreenSubtreeIsHidden = !1,\\n  offscreenSubtreeWasHidden = !1,\\n  needsFormReset = !1,\\n  PossiblyWeakSet = \"function\" === typeof WeakSet ? WeakSet : Set,\\n  nextEffect = null;\\nfunction commitBeforeMutationEffects(root, firstChild) {\\n  root = root.containerInfo;\\n  eventsEnabled = _enabled;\\n  root = getActiveElementDeep(root);\\n  if (hasSelectionCapabilities(root)) {\\n    if (\"selectionStart\" in root)\\n      var JSCompiler_temp = {\\n        start: root.selectionStart,\\n        end: root.selectionEnd\\n      };\\n    else\\n      a: {\\n        JSCompiler_temp =\\n          ((JSCompiler_temp = root.ownerDocument) &&\\n            JSCompiler_temp.defaultView) ||\\n          window;\\n        var selection =\\n          JSCompiler_temp.getSelection && JSCompiler_temp.getSelection();\\n        if (selection && 0 !== selection.rangeCount) {\\n          JSCompiler_temp = selection.anchorNode;\\n          var anchorOffset = selection.anchorOffset,\\n            focusNode = selection.focusNode;\\n          selection = selection.focusOffset;\\n          try {\\n            JSCompiler_temp.nodeType, focusNode.nodeType;\\n          } catch (e$20) {\\n            JSCompiler_temp = null;\\n            break a;\\n          }\\n          var length = 0,\\n            start = -1,\\n            end = -1,\\n            indexWithinAnchor = 0,\\n            indexWithinFocus = 0,\\n            node = root,\\n            parentNode = null;\\n          b: for (;;) {\\n            for (var next; ; ) {\\n              node !== JSCompiler_temp ||\\n                (0 !== anchorOffset && 3 !== node.nodeType) ||\\n                (start = length + anchorOffset);\\n              node !== focusNode ||\\n                (0 !== selection && 3 !== node.nodeType) ||\\n                (end = length + selection);\\n              3 === node.nodeType && (length += node.nodeValue.length);\\n              if (null === (next = node.firstChild)) break;\\n              parentNode = node;\\n              node = next;\\n            }\\n            for (;;) {\\n              if (node === root) break b;\\n              parentNode === JSCompiler_temp &&\\n                ++indexWithinAnchor === anchorOffset &&\\n                (start = length);\\n              parentNode === focusNode &&\\n                ++indexWithinFocus === selection &&\\n                (end = length);\\n              if (null !== (next = node.nextSibling)) break;\\n              node = parentNode;\\n              parentNode = node.parentNode;\\n            }\\n            node = next;\\n          }\\n          JSCompiler_temp =\\n            -1 === start || -1 === end ? null : { start: start, end: end };\\n        } else JSCompiler_temp = null;\\n      }\\n    JSCompiler_temp = JSCompiler_temp || { start: 0, end: 0 };\\n  } else JSCompiler_temp = null;\\n  selectionInformation = { focusedElem: root, selectionRange: JSCompiler_temp };\\n  _enabled = !1;\\n  for (nextEffect = firstChild; null !== nextEffect; )\\n    if (\\n      ((firstChild = nextEffect),\\n      (root = firstChild.child),\\n      0 !== (firstChild.subtreeFlags & 1024) && null !== root)\\n    )\\n      (root.return = firstChild), (nextEffect = root);\\n    else\\n      for (; null !== nextEffect; ) {\\n        firstChild = nextEffect;\\n        focusNode = firstChild.alternate;\\n        root = firstChild.flags;\\n        switch (firstChild.tag) {\\n          case 0:\\n            break;\\n          case 11:\\n          case 15:\\n            break;\\n          case 1:\\n            if (0 !== (root & 1024) && null !== focusNode) {\\n              root = void 0;\\n              JSCompiler_temp = firstChild;\\n              anchorOffset = focusNode.memoizedProps;\\n              focusNode = focusNode.memoizedState;\\n              selection = JSCompiler_temp.stateNode;\\n              try {\\n                var resolvedPrevProps = resolveClassComponentProps(\\n                  JSCompiler_temp.type,\\n                  anchorOffset,\\n                  JSCompiler_temp.elementType === JSCompiler_temp.type\\n                );\\n                root = selection.getSnapshotBeforeUpdate(\\n                  resolvedPrevProps,\\n                  focusNode\\n                );\\n                selection.__reactInternalSnapshotBeforeUpdate = root;\\n              } catch (error) {\\n                captureCommitPhaseError(\\n                  JSCompiler_temp,\\n                  JSCompiler_temp.return,\\n                  error\\n                );\\n              }\\n            }\\n            break;\\n          case 3:\\n            if (0 !== (root & 1024))\\n              if (\\n                ((root = firstChild.stateNode.containerInfo),\\n                (JSCompiler_temp = root.nodeType),\\n                9 === JSCompiler_temp)\\n              )\\n                clearContainerSparingly(root);\\n              else if (1 === JSCompiler_temp)\\n                switch (root.nodeName) {\\n                  case \"HEAD\":\\n                  case \"HTML\":\\n                  case \"BODY\":\\n                    clearContainerSparingly(root);\\n                    break;\\n                  default:\\n                    root.textContent = \"\";\\n                }\\n            break;\\n          case 5:\\n          case 26:\\n          case 27:\\n          case 6:\\n          case 4:\\n          case 17:\\n            break;\\n          default:\\n            if (0 !== (root & 1024)) throw Error(formatProdErrorMessage(163));\\n        }\\n        root = firstChild.sibling;\\n        if (null !== root) {\\n          root.return = firstChild.return;\\n          nextEffect = root;\\n          break;\\n        }\\n        nextEffect = firstChild.return;\\n      }\\n}\\nfunction commitLayoutEffectOnFiber(finishedRoot, current, finishedWork) {\\n  var flags = finishedWork.flags;\\n  switch (finishedWork.tag) {\\n    case 0:\\n    case 11:\\n    case 15:\\n      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\\n      flags & 4 && commitHookEffectListMount(5, finishedWork);\\n      break;\\n    case 1:\\n      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\\n      if (flags & 4)\\n        if (((finishedRoot = finishedWork.stateNode), null === current))\\n          try {\\n            finishedRoot.componentDidMount();\\n          } catch (error) {\\n            captureCommitPhaseError(finishedWork, finishedWork.return, error);\\n          }\\n        else {\\n          var prevProps = resolveClassComponentProps(\\n            finishedWork.type,\\n            current.memoizedProps\\n          );\\n          current = current.memoizedState;\\n          try {\\n            finishedRoot.componentDidUpdate(\\n              prevProps,\\n              current,\\n              finishedRoot.__reactInternalSnapshotBeforeUpdate\\n            );\\n          } catch (error$142) {\\n            captureCommitPhaseError(\\n              finishedWork,\\n              finishedWork.return,\\n              error$142\\n            );\\n          }\\n        }\\n      flags & 64 && commitClassCallbacks(finishedWork);\\n      flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);\\n      break;\\n    case 3:\\n      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\\n      if (\\n        flags & 64 &&\\n        ((finishedRoot = finishedWork.updateQueue), null !== finishedRoot)\\n      ) {\\n        current = null;\\n        if (null !== finishedWork.child)\\n          switch (finishedWork.child.tag) {\\n            case 27:\\n            case 5:\\n              current = finishedWork.child.stateNode;\\n              break;\\n            case 1:\\n              current = finishedWork.child.stateNode;\\n          }\\n        try {\\n          commitCallbacks(finishedRoot, current);\\n        } catch (error) {\\n          captureCommitPhaseError(finishedWork, finishedWork.return, error);\\n        }\\n      }\\n      break;\\n    case 27:\\n      null === current &&\\n        flags & 4 &&\\n        commitHostSingletonAcquisition(finishedWork);\\n    case 26:\\n    case 5:\\n      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\\n      null === current && flags & 4 && commitHostMount(finishedWork);\\n      flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);\\n      break;\\n    case 12:\\n      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\\n      break;\\n    case 13:\\n      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\\n      flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);\\n      flags & 64 &&\\n        ((finishedRoot = finishedWork.memoizedState),\\n        null !== finishedRoot &&\\n          ((finishedRoot = finishedRoot.dehydrated),\\n          null !== finishedRoot &&\\n            ((finishedWork = retryDehydratedSuspenseBoundary.bind(\\n              null,\\n              finishedWork\\n            )),\\n            registerSuspenseInstanceRetry(finishedRoot, finishedWork))));\\n      break;\\n    case 22:\\n      flags = null !== finishedWork.memoizedState || offscreenSubtreeIsHidden;\\n      if (!flags) {\\n        current =\\n          (null !== current && null !== current.memoizedState) ||\\n          offscreenSubtreeWasHidden;\\n        prevProps = offscreenSubtreeIsHidden;\\n        var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;\\n        offscreenSubtreeIsHidden = flags;\\n        (offscreenSubtreeWasHidden = current) && !prevOffscreenSubtreeWasHidden\\n          ? recursivelyTraverseReappearLayoutEffects(\\n              finishedRoot,\\n              finishedWork,\\n              0 !== (finishedWork.subtreeFlags & 8772)\\n            )\\n          : recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\\n        offscreenSubtreeIsHidden = prevProps;\\n        offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;\\n      }\\n      break;\\n    case 30:\\n      break;\\n    default:\\n      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\\n  }\\n}\\nfunction detachFiberAfterEffects(fiber) {\\n  var alternate = fiber.alternate;\\n  null !== alternate &&\\n    ((fiber.alternate = null), detachFiberAfterEffects(alternate));\\n  fiber.child = null;\\n  fiber.deletions = null;\\n  fiber.sibling = null;\\n  5 === fiber.tag &&\\n    ((alternate = fiber.stateNode),\\n    null !== alternate && detachDeletedInstance(alternate));\\n  fiber.stateNode = null;\\n  fiber.return = null;\\n  fiber.dependencies = null;\\n  fiber.memoizedProps = null;\\n  fiber.memoizedState = null;\\n  fiber.pendingProps = null;\\n  fiber.stateNode = null;\\n  fiber.updateQueue = null;\\n}\\nvar hostParent = null,\\n  hostParentIsContainer = !1;\\nfunction recursivelyTraverseDeletionEffects(\\n  finishedRoot,\\n  nearestMountedAncestor,\\n  parent\\n) {\\n  for (parent = parent.child; null !== parent; )\\n    commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, parent),\\n      (parent = parent.sibling);\\n}\\nfunction commitDeletionEffectsOnFiber(\\n  finishedRoot,\\n  nearestMountedAncestor,\\n  deletedFiber\\n) {\\n  if (injectedHook && \"function\" === typeof injectedHook.onCommitFiberUnmount)\\n    try {\\n      injectedHook.onCommitFiberUnmount(rendererID, deletedFiber);\\n    } catch (err) {}\\n  switch (deletedFiber.tag) {\\n    case 26:\\n      offscreenSubtreeWasHidden ||\\n        safelyDetachRef(deletedFiber, nearestMountedAncestor);\\n      recursivelyTraverseDeletionEffects(\\n        finishedRoot,\\n        nearestMountedAncestor,\\n        deletedFiber\\n      );\\n      deletedFiber.memoizedState\\n        ? deletedFiber.memoizedState.count--\\n        : deletedFiber.stateNode &&\\n          ((deletedFiber = deletedFiber.stateNode),\\n          deletedFiber.parentNode.removeChild(deletedFiber));\\n      break;\\n    case 27:\\n      offscreenSubtreeWasHidden ||\\n        safelyDetachRef(deletedFiber, nearestMountedAncestor);\\n      var prevHostParent = hostParent,\\n        prevHostParentIsContainer = hostParentIsContainer;\\n      isSingletonScope(deletedFiber.type) &&\\n        ((hostParent = deletedFiber.stateNode), (hostParentIsContainer = !1));\\n      recursivelyTraverseDeletionEffects(\\n        finishedRoot,\\n        nearestMountedAncestor,\\n        deletedFiber\\n      );\\n      releaseSingletonInstance(deletedFiber.stateNode);\\n      hostParent = prevHostParent;\\n      hostParentIsContainer = prevHostParentIsContainer;\\n      break;\\n    case 5:\\n      offscreenSubtreeWasHidden ||\\n        safelyDetachRef(deletedFiber, nearestMountedAncestor);\\n    case 6:\\n      prevHostParent = hostParent;\\n      prevHostParentIsContainer = hostParentIsContainer;\\n      hostParent = null;\\n      recursivelyTraverseDeletionEffects(\\n        finishedRoot,\\n        nearestMountedAncestor,\\n        deletedFiber\\n      );\\n      hostParent = prevHostParent;\\n      hostParentIsContainer = prevHostParentIsContainer;\\n      if (null !== hostParent)\\n        if (hostParentIsContainer)\\n          try {\\n            (9 === hostParent.nodeType\\n              ? hostParent.body\\n              : \"HTML\" === hostParent.nodeName\\n                ? hostParent.ownerDocument.body\\n                : hostParent\\n            ).removeChild(deletedFiber.stateNode);\\n          } catch (error) {\\n            captureCommitPhaseError(\\n              deletedFiber,\\n              nearestMountedAncestor,\\n              error\\n            );\\n          }\\n        else\\n          try {\\n            hostParent.removeChild(deletedFiber.stateNode);\\n          } catch (error) {\\n            captureCommitPhaseError(\\n              deletedFiber,\\n              nearestMountedAncestor,\\n              error\\n            );\\n          }\\n      break;\\n    case 18:\\n      null !== hostParent &&\\n        (hostParentIsContainer\\n          ? ((finishedRoot = hostParent),\\n            clearSuspenseBoundary(\\n              9 === finishedRoot.nodeType\\n                ? finishedRoot.body\\n                : \"HTML\" === finishedRoot.nodeName\\n                  ? finishedRoot.ownerDocument.body\\n                  : finishedRoot,\\n              deletedFiber.stateNode\\n            ),\\n            retryIfBlockedOn(finishedRoot))\\n          : clearSuspenseBoundary(hostParent, deletedFiber.stateNode));\\n      break;\\n    case 4:\\n      prevHostParent = hostParent;\\n      prevHostParentIsContainer = hostParentIsContainer;\\n      hostParent = deletedFiber.stateNode.containerInfo;\\n      hostParentIsContainer = !0;\\n      recursivelyTraverseDeletionEffects(\\n        finishedRoot,\\n        nearestMountedAncestor,\\n        deletedFiber\\n      );\\n      hostParent = prevHostParent;\\n      hostParentIsContainer = prevHostParentIsContainer;\\n      break;\\n    case 0:\\n    case 11:\\n    case 14:\\n    case 15:\\n      offscreenSubtreeWasHidden ||\\n        commitHookEffectListUnmount(2, deletedFiber, nearestMountedAncestor);\\n      offscreenSubtreeWasHidden ||\\n        commitHookEffectListUnmount(4, deletedFiber, nearestMountedAncestor);\\n      recursivelyTraverseDeletionEffects(\\n        finishedRoot,\\n        nearestMountedAncestor,\\n        deletedFiber\\n      );\\n      break;\\n    case 1:\\n      offscreenSubtreeWasHidden ||\\n        (safelyDetachRef(deletedFiber, nearestMountedAncestor),\\n        (prevHostParent = deletedFiber.stateNode),\\n        \"function\" === typeof prevHostParent.componentWillUnmount &&\\n          safelyCallComponentWillUnmount(\\n            deletedFiber,\\n            nearestMountedAncestor,\\n            prevHostParent\\n          ));\\n      recursivelyTraverseDeletionEffects(\\n        finishedRoot,\\n        nearestMountedAncestor,\\n        deletedFiber\\n      );\\n      break;\\n    case 21:\\n      recursivelyTraverseDeletionEffects(\\n        finishedRoot,\\n        nearestMountedAncestor,\\n        deletedFiber\\n      );\\n      break;\\n    case 22:\\n      offscreenSubtreeWasHidden =\\n        (prevHostParent = offscreenSubtreeWasHidden) ||\\n        null !== deletedFiber.memoizedState;\\n      recursivelyTraverseDeletionEffects(\\n        finishedRoot,\\n        nearestMountedAncestor,\\n        deletedFiber\\n      );\\n      offscreenSubtreeWasHidden = prevHostParent;\\n      break;\\n    default:\\n      recursivelyTraverseDeletionEffects(\\n        finishedRoot,\\n        nearestMountedAncestor,\\n        deletedFiber\\n      );\\n  }\\n}\\nfunction commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {\\n  if (\\n    null === finishedWork.memoizedState &&\\n    ((finishedRoot = finishedWork.alternate),\\n    null !== finishedRoot &&\\n      ((finishedRoot = finishedRoot.memoizedState),\\n      null !== finishedRoot &&\\n        ((finishedRoot = finishedRoot.dehydrated), null !== finishedRoot)))\\n  )\\n    try {\\n      retryIfBlockedOn(finishedRoot);\\n    } catch (error) {\\n      captureCommitPhaseError(finishedWork, finishedWork.return, error);\\n    }\\n}\\nfunction getRetryCache(finishedWork) {\\n  switch (finishedWork.tag) {\\n    case 13:\\n    case 19:\\n      var retryCache = finishedWork.stateNode;\\n      null === retryCache &&\\n        (retryCache = finishedWork.stateNode = new PossiblyWeakSet());\\n      return retryCache;\\n    case 22:\\n      return (\\n        (finishedWork = finishedWork.stateNode),\\n        (retryCache = finishedWork._retryCache),\\n        null === retryCache &&\\n          (retryCache = finishedWork._retryCache = new PossiblyWeakSet()),\\n        retryCache\\n      );\\n    default:\\n      throw Error(formatProdErrorMessage(435, finishedWork.tag));\\n  }\\n}\\nfunction attachSuspenseRetryListeners(finishedWork, wakeables) {\\n  var retryCache = getRetryCache(finishedWork);\\n  wakeables.forEach(function (wakeable) {\\n    var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);\\n    retryCache.has(wakeable) ||\\n      (retryCache.add(wakeable), wakeable.then(retry, retry));\\n  });\\n}\\nfunction recursivelyTraverseMutationEffects(root$jscomp$0, parentFiber) {\\n  var deletions = parentFiber.deletions;\\n  if (null !== deletions)\\n    for (var i = 0; i < deletions.length; i++) {\\n      var childToDelete = deletions[i],\\n        root = root$jscomp$0,\\n        returnFiber = parentFiber,\\n        parent = returnFiber;\\n      a: for (; null !== parent; ) {\\n        switch (parent.tag) {\\n          case 27:\\n            if (isSingletonScope(parent.type)) {\\n              hostParent = parent.stateNode;\\n              hostParentIsContainer = !1;\\n              break a;\\n            }\\n            break;\\n          case 5:\\n            hostParent = parent.stateNode;\\n            hostParentIsContainer = !1;\\n            break a;\\n          case 3:\\n          case 4:\\n            hostParent = parent.stateNode.containerInfo;\\n            hostParentIsContainer = !0;\\n            break a;\\n        }\\n        parent = parent.return;\\n      }\\n      if (null === hostParent) throw Error(formatProdErrorMessage(160));\\n      commitDeletionEffectsOnFiber(root, returnFiber, childToDelete);\\n      hostParent = null;\\n      hostParentIsContainer = !1;\\n      root = childToDelete.alternate;\\n      null !== root && (root.return = null);\\n      childToDelete.return = null;\\n    }\\n  if (parentFiber.subtreeFlags & 13878)\\n    for (parentFiber = parentFiber.child; null !== parentFiber; )\\n      commitMutationEffectsOnFiber(parentFiber, root$jscomp$0),\\n        (parentFiber = parentFiber.sibling);\\n}\\nvar currentHoistableRoot = null;\\nfunction commitMutationEffectsOnFiber(finishedWork, root) {\\n  var current = finishedWork.alternate,\\n    flags = finishedWork.flags;\\n  switch (finishedWork.tag) {\\n    case 0:\\n    case 11:\\n    case 14:\\n    case 15:\\n      recursivelyTraverseMutationEffects(root, finishedWork);\\n      commitReconciliationEffects(finishedWork);\\n      flags & 4 &&\\n        (commitHookEffectListUnmount(3, finishedWork, finishedWork.return),\\n        commitHookEffectListMount(3, finishedWork),\\n        commitHookEffectListUnmount(5, finishedWork, finishedWork.return));\\n      break;\\n    case 1:\\n      recursivelyTraverseMutationEffects(root, finishedWork);\\n      commitReconciliationEffects(finishedWork);\\n      flags & 512 &&\\n        (offscreenSubtreeWasHidden ||\\n          null === current ||\\n          safelyDetachRef(current, current.return));\\n      flags & 64 &&\\n        offscreenSubtreeIsHidden &&\\n        ((finishedWork = finishedWork.updateQueue),\\n        null !== finishedWork &&\\n          ((flags = finishedWork.callbacks),\\n          null !== flags &&\\n            ((current = finishedWork.shared.hiddenCallbacks),\\n            (finishedWork.shared.hiddenCallbacks =\\n              null === current ? flags : current.concat(flags)))));\\n      break;\\n    case 26:\\n      var hoistableRoot = currentHoistableRoot;\\n      recursivelyTraverseMutationEffects(root, finishedWork);\\n      commitReconciliationEffects(finishedWork);\\n      flags & 512 &&\\n        (offscreenSubtreeWasHidden ||\\n          null === current ||\\n          safelyDetachRef(current, current.return));\\n      if (flags & 4) {\\n        var currentResource = null !== current ? current.memoizedState : null;\\n        flags = finishedWork.memoizedState;\\n        if (null === current)\\n          if (null === flags)\\n            if (null === finishedWork.stateNode) {\\n              a: {\\n                flags = finishedWork.type;\\n                current = finishedWork.memoizedProps;\\n                hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;\\n                b: switch (flags) {\\n                  case \"title\":\\n                    currentResource =\\n                      hoistableRoot.getElementsByTagName(\"title\")[0];\\n                    if (\\n                      !currentResource ||\\n                      currentResource[internalHoistableMarker] ||\\n                      currentResource[internalInstanceKey] ||\\n                      \"http://www.w3.org/2000/svg\" ===\\n                        currentResource.namespaceURI ||\\n                      currentResource.hasAttribute(\"itemprop\")\\n                    )\\n                      (currentResource = hoistableRoot.createElement(flags)),\\n                        hoistableRoot.head.insertBefore(\\n                          currentResource,\\n                          hoistableRoot.querySelector(\"head > title\")\\n                        );\\n                    setInitialProperties(currentResource, flags, current);\\n                    currentResource[internalInstanceKey] = finishedWork;\\n                    markNodeAsHoistable(currentResource);\\n                    flags = currentResource;\\n                    break a;\\n                  case \"link\":\\n                    var maybeNodes = getHydratableHoistableCache(\\n                      \"link\",\\n                      \"href\",\\n                      hoistableRoot\\n                    ).get(flags + (current.href || \"\"));\\n                    if (maybeNodes)\\n                      for (var i = 0; i < maybeNodes.length; i++)\\n                        if (\\n                          ((currentResource = maybeNodes[i]),\\n                          currentResource.getAttribute(\"href\") ===\\n                            (null == current.href || \"\" === current.href\\n                              ? null\\n                              : current.href) &&\\n                            currentResource.getAttribute(\"rel\") ===\\n                              (null == current.rel ? null : current.rel) &&\\n                            currentResource.getAttribute(\"title\") ===\\n                              (null == current.title ? null : current.title) &&\\n                            currentResource.getAttribute(\"crossorigin\") ===\\n                              (null == current.crossOrigin\\n                                ? null\\n                                : current.crossOrigin))\\n                        ) {\\n                          maybeNodes.splice(i, 1);\\n                          break b;\\n                        }\\n                    currentResource = hoistableRoot.createElement(flags);\\n                    setInitialProperties(currentResource, flags, current);\\n                    hoistableRoot.head.appendChild(currentResource);\\n                    break;\\n                  case \"meta\":\\n                    if (\\n                      (maybeNodes = getHydratableHoistableCache(\\n                        \"meta\",\\n                        \"content\",\\n                        hoistableRoot\\n                      ).get(flags + (current.content || \"\")))\\n                    )\\n                      for (i = 0; i < maybeNodes.length; i++)\\n                        if (\\n                          ((currentResource = maybeNodes[i]),\\n                          currentResource.getAttribute(\"content\") ===\\n                            (null == current.content\\n                              ? null\\n                              : \"\" + current.content) &&\\n                            currentResource.getAttribute(\"name\") ===\\n                              (null == current.name ? null : current.name) &&\\n                            currentResource.getAttribute(\"property\") ===\\n                              (null == current.property\\n                                ? null\\n                                : current.property) &&\\n                            currentResource.getAttribute(\"http-equiv\") ===\\n                              (null == current.httpEquiv\\n                                ? null\\n                                : current.httpEquiv) &&\\n                            currentResource.getAttribute(\"charset\") ===\\n                              (null == current.charSet\\n                                ? null\\n                                : current.charSet))\\n                        ) {\\n                          maybeNodes.splice(i, 1);\\n                          break b;\\n                        }\\n                    currentResource = hoistableRoot.createElement(flags);\\n                    setInitialProperties(currentResource, flags, current);\\n                    hoistableRoot.head.appendChild(currentResource);\\n                    break;\\n                  default:\\n                    throw Error(formatProdErrorMessage(468, flags));\\n                }\\n                currentResource[internalInstanceKey] = finishedWork;\\n                markNodeAsHoistable(currentResource);\\n                flags = currentResource;\\n              }\\n              finishedWork.stateNode = flags;\\n            } else\\n              mountHoistable(\\n                hoistableRoot,\\n                finishedWork.type,\\n                finishedWork.stateNode\\n              );\\n          else\\n            finishedWork.stateNode = acquireResource(\\n              hoistableRoot,\\n              flags,\\n              finishedWork.memoizedProps\\n            );\\n        else\\n          currentResource !== flags\\n            ? (null === currentResource\\n                ? null !== current.stateNode &&\\n                  ((current = current.stateNode),\\n                  current.parentNode.removeChild(current))\\n                : currentResource.count--,\\n              null === flags\\n                ? mountHoistable(\\n                    hoistableRoot,\\n                    finishedWork.type,\\n                    finishedWork.stateNode\\n                  )\\n                : acquireResource(\\n                    hoistableRoot,\\n                    flags,\\n                    finishedWork.memoizedProps\\n                  ))\\n            : null === flags &&\\n              null !== finishedWork.stateNode &&\\n              commitHostUpdate(\\n                finishedWork,\\n                finishedWork.memoizedProps,\\n                current.memoizedProps\\n              );\\n      }\\n      break;\\n    case 27:\\n      recursivelyTraverseMutationEffects(root, finishedWork);\\n      commitReconciliationEffects(finishedWork);\\n      flags & 512 &&\\n        (offscreenSubtreeWasHidden ||\\n          null === current ||\\n          safelyDetachRef(current, current.return));\\n      null !== current &&\\n        flags & 4 &&\\n        commitHostUpdate(\\n          finishedWork,\\n          finishedWork.memoizedProps,\\n          current.memoizedProps\\n        );\\n      break;\\n    case 5:\\n      recursivelyTraverseMutationEffects(root, finishedWork);\\n      commitReconciliationEffects(finishedWork);\\n      flags & 512 &&\\n        (offscreenSubtreeWasHidden ||\\n          null === current ||\\n          safelyDetachRef(current, current.return));\\n      if (finishedWork.flags & 32) {\\n        hoistableRoot = finishedWork.stateNode;\\n        try {\\n          setTextContent(hoistableRoot, \"\");\\n        } catch (error) {\\n          captureCommitPhaseError(finishedWork, finishedWork.return, error);\\n        }\\n      }\\n      flags & 4 &&\\n        null != finishedWork.stateNode &&\\n        ((hoistableRoot = finishedWork.memoizedProps),\\n        commitHostUpdate(\\n          finishedWork,\\n          hoistableRoot,\\n          null !== current ? current.memoizedProps : hoistableRoot\\n        ));\\n      flags & 1024 && (needsFormReset = !0);\\n      break;\\n    case 6:\\n      recursivelyTraverseMutationEffects(root, finishedWork);\\n      commitReconciliationEffects(finishedWork);\\n      if (flags & 4) {\\n        if (null === finishedWork.stateNode)\\n          throw Error(formatProdErrorMessage(162));\\n        flags = finishedWork.memoizedProps;\\n        current = finishedWork.stateNode;\\n        try {\\n          current.nodeValue = flags;\\n        } catch (error) {\\n          captureCommitPhaseError(finishedWork, finishedWork.return, error);\\n        }\\n      }\\n      break;\\n    case 3:\\n      tagCaches = null;\\n      hoistableRoot = currentHoistableRoot;\\n      currentHoistableRoot = getHoistableRoot(root.containerInfo);\\n      recursivelyTraverseMutationEffects(root, finishedWork);\\n      currentHoistableRoot = hoistableRoot;\\n      commitReconciliationEffects(finishedWork);\\n      if (flags & 4 && null !== current && current.memoizedState.isDehydrated)\\n        try {\\n          retryIfBlockedOn(root.containerInfo);\\n        } catch (error) {\\n          captureCommitPhaseError(finishedWork, finishedWork.return, error);\\n        }\\n      needsFormReset &&\\n        ((needsFormReset = !1), recursivelyResetForms(finishedWork));\\n      break;\\n    case 4:\\n      flags = currentHoistableRoot;\\n      currentHoistableRoot = getHoistableRoot(\\n        finishedWork.stateNode.containerInfo\\n      );\\n      recursivelyTraverseMutationEffects(root, finishedWork);\\n      commitReconciliationEffects(finishedWork);\\n      currentHoistableRoot = flags;\\n      break;\\n    case 12:\\n      recursivelyTraverseMutationEffects(root, finishedWork);\\n      commitReconciliationEffects(finishedWork);\\n      break;\\n    case 13:\\n      recursivelyTraverseMutationEffects(root, finishedWork);\\n      commitReconciliationEffects(finishedWork);\\n      finishedWork.child.flags & 8192 &&\\n        (null !== finishedWork.memoizedState) !==\\n          (null !== current && null !== current.memoizedState) &&\\n        (globalMostRecentFallbackTime = now());\\n      flags & 4 &&\\n        ((flags = finishedWork.updateQueue),\\n        null !== flags &&\\n          ((finishedWork.updateQueue = null),\\n          attachSuspenseRetryListeners(finishedWork, flags)));\\n      break;\\n    case 22:\\n      hoistableRoot = null !== finishedWork.memoizedState;\\n      var wasHidden = null !== current && null !== current.memoizedState,\\n        prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden,\\n        prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;\\n      offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden || hoistableRoot;\\n      offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || wasHidden;\\n      recursivelyTraverseMutationEffects(root, finishedWork);\\n      offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;\\n      offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;\\n      commitReconciliationEffects(finishedWork);\\n      if (flags & 8192)\\n        a: for (\\n          root = finishedWork.stateNode,\\n            root._visibility = hoistableRoot\\n              ? root._visibility & -2\\n              : root._visibility | 1,\\n            hoistableRoot &&\\n              (null === current ||\\n                wasHidden ||\\n                offscreenSubtreeIsHidden ||\\n                offscreenSubtreeWasHidden ||\\n                recursivelyTraverseDisappearLayoutEffects(finishedWork)),\\n            current = null,\\n            root = finishedWork;\\n          ;\\n\\n        ) {\\n          if (5 === root.tag || 26 === root.tag) {\\n            if (null === current) {\\n              wasHidden = current = root;\\n              try {\\n                if (((currentResource = wasHidden.stateNode), hoistableRoot))\\n                  (maybeNodes = currentResource.style),\\n                    \"function\" === typeof maybeNodes.setProperty\\n                      ? maybeNodes.setProperty(\"display\", \"none\", \"important\")\\n                      : (maybeNodes.display = \"none\");\\n                else {\\n                  i = wasHidden.stateNode;\\n                  var styleProp = wasHidden.memoizedProps.style,\\n                    display =\\n                      void 0 !== styleProp &&\\n                      null !== styleProp &&\\n                      styleProp.hasOwnProperty(\"display\")\\n                        ? styleProp.display\\n                        : null;\\n                  i.style.display =\\n                    null == display || \"boolean\" === typeof display\\n                      ? \"\"\\n                      : (\"\" + display).trim();\\n                }\\n              } catch (error) {\\n                captureCommitPhaseError(wasHidden, wasHidden.return, error);\\n              }\\n            }\\n          } else if (6 === root.tag) {\\n            if (null === current) {\\n              wasHidden = root;\\n              try {\\n                wasHidden.stateNode.nodeValue = hoistableRoot\\n                  ? \"\"\\n                  : wasHidden.memoizedProps;\\n              } catch (error) {\\n                captureCommitPhaseError(wasHidden, wasHidden.return, error);\\n              }\\n            }\\n          } else if (\\n            ((22 !== root.tag && 23 !== root.tag) ||\\n              null === root.memoizedState ||\\n              root === finishedWork) &&\\n            null !== root.child\\n          ) {\\n            root.child.return = root;\\n            root = root.child;\\n            continue;\\n          }\\n          if (root === finishedWork) break a;\\n          for (; null === root.sibling; ) {\\n            if (null === root.return || root.return === finishedWork) break a;\\n            current === root && (current = null);\\n            root = root.return;\\n          }\\n          current === root && (current = null);\\n          root.sibling.return = root.return;\\n          root = root.sibling;\\n        }\\n      flags & 4 &&\\n        ((flags = finishedWork.updateQueue),\\n        null !== flags &&\\n          ((current = flags.retryQueue),\\n          null !== current &&\\n            ((flags.retryQueue = null),\\n            attachSuspenseRetryListeners(finishedWork, current))));\\n      break;\\n    case 19:\\n      recursivelyTraverseMutationEffects(root, finishedWork);\\n      commitReconciliationEffects(finishedWork);\\n      flags & 4 &&\\n        ((flags = finishedWork.updateQueue),\\n        null !== flags &&\\n          ((finishedWork.updateQueue = null),\\n          attachSuspenseRetryListeners(finishedWork, flags)));\\n      break;\\n    case 30:\\n      break;\\n    case 21:\\n      break;\\n    default:\\n      recursivelyTraverseMutationEffects(root, finishedWork),\\n        commitReconciliationEffects(finishedWork);\\n  }\\n}\\nfunction commitReconciliationEffects(finishedWork) {\\n  var flags = finishedWork.flags;\\n  if (flags & 2) {\\n    try {\\n      for (\\n        var hostParentFiber, parentFiber = finishedWork.return;\\n        null !== parentFiber;\\n\\n      ) {\\n        if (isHostParent(parentFiber)) {\\n          hostParentFiber = parentFiber;\\n          break;\\n        }\\n        parentFiber = parentFiber.return;\\n      }\\n      if (null == hostParentFiber) throw Error(formatProdErrorMessage(160));\\n      switch (hostParentFiber.tag) {\\n        case 27:\\n          var parent = hostParentFiber.stateNode,\\n            before = getHostSibling(finishedWork);\\n          insertOrAppendPlacementNode(finishedWork, before, parent);\\n          break;\\n        case 5:\\n          var parent$144 = hostParentFiber.stateNode;\\n          hostParentFiber.flags & 32 &&\\n            (setTextContent(parent$144, \"\"), (hostParentFiber.flags &= -33));\\n          var before$145 = getHostSibling(finishedWork);\\n          insertOrAppendPlacementNo","size_bytes":360000},"dist/bundle.4a4298d84a2dac7d3cd7.js":{"content":"(()=>{var __webpack_modules__={56:(module,__unused_webpack_exports,__webpack_require__)=>{\"use strict\";eval('{\\n\\n/* istanbul ignore next  */\\nfunction setAttributesWithoutAttributes(styleElement) {\\n  var nonce =  true ? __webpack_require__.nc : 0;\\n  if (nonce) {\\n    styleElement.setAttribute(\"nonce\", nonce);\\n  }\\n}\\nmodule.exports = setAttributesWithoutAttributes;//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTYuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBLGNBQWMsS0FBd0MsR0FBRyxzQkFBaUIsR0FBRyxDQUFJO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93b3Jrc3BhY2UvLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zZXRBdHRyaWJ1dGVzV2l0aG91dEF0dHJpYnV0ZXMuanM/ZGRjZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5mdW5jdGlvbiBzZXRBdHRyaWJ1dGVzV2l0aG91dEF0dHJpYnV0ZXMoc3R5bGVFbGVtZW50KSB7XG4gIHZhciBub25jZSA9IHR5cGVvZiBfX3dlYnBhY2tfbm9uY2VfXyAhPT0gXCJ1bmRlZmluZWRcIiA/IF9fd2VicGFja19ub25jZV9fIDogbnVsbDtcbiAgaWYgKG5vbmNlKSB7XG4gICAgc3R5bGVFbGVtZW50LnNldEF0dHJpYnV0ZShcIm5vbmNlXCIsIG5vbmNlKTtcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBzZXRBdHRyaWJ1dGVzV2l0aG91dEF0dHJpYnV0ZXM7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\\n//# sourceURL=webpack-internal:///56\\n\\n}')},72:module=>{\"use strict\";eval('{\\n\\nvar stylesInDOM = [];\\nfunction getIndexByIdentifier(identifier) {\\n  var result = -1;\\n  for (var i = 0; i < stylesInDOM.length; i++) {\\n    if (stylesInDOM[i].identifier === identifier) {\\n      result = i;\\n      break;\\n    }\\n  }\\n  return result;\\n}\\nfunction modulesToDom(list, options) {\\n  var idCountMap = {};\\n  var identifiers = [];\\n  for (var i = 0; i < list.length; i++) {\\n    var item = list[i];\\n    var id = options.base ? item[0] + options.base : item[0];\\n    var count = idCountMap[id] || 0;\\n    var identifier = \"\".concat(id, \" \").concat(count);\\n    idCountMap[id] = count + 1;\\n    var indexByIdentifier = getIndexByIdentifier(identifier);\\n    var obj = {\\n      css: item[1],\\n      media: item[2],\\n      sourceMap: item[3],\\n      supports: item[4],\\n      layer: item[5]\\n    };\\n    if (indexByIdentifier !== -1) {\\n      stylesInDOM[indexByIdentifier].references++;\\n      stylesInDOM[indexByIdentifier].updater(obj);\\n    } else {\\n      var updater = addElementStyle(obj, options);\\n      options.byIndex = i;\\n      stylesInDOM.splice(i, 0, {\\n        identifier: identifier,\\n        updater: updater,\\n        references: 1\\n      });\\n    }\\n    identifiers.push(identifier);\\n  }\\n  return identifiers;\\n}\\nfunction addElementStyle(obj, options) {\\n  var api = options.domAPI(options);\\n  api.update(obj);\\n  var updater = function updater(newObj) {\\n    if (newObj) {\\n      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {\\n        return;\\n      }\\n      api.update(obj = newObj);\\n    } else {\\n      api.remove();\\n    }\\n  };\\n  return updater;\\n}\\nmodule.exports = function (list, options) {\\n  options = options || {};\\n  list = list || [];\\n  var lastIdentifiers = modulesToDom(list, options);\\n  return function update(newList) {\\n    newList = newList || [];\\n    for (var i = 0; i < lastIdentifiers.length; i++) {\\n      var identifier = lastIdentifiers[i];\\n      var index = getIndexByIdentifier(identifier);\\n      stylesInDOM[index].references--;\\n    }\\n    var newLastIdentifiers = modulesToDom(newList, options);\\n    for (var _i = 0; _i < lastIdentifiers.length; _i++) {\\n      var _identifier = lastIdentifiers[_i];\\n      var _index = getIndexByIdentifier(_identifier);\\n      if (stylesInDOM[_index].references === 0) {\\n        stylesInDOM[_index].updater();\\n        stylesInDOM.splice(_index, 1);\\n      }\\n    }\\n    lastIdentifiers = newLastIdentifiers;\\n  };\\n};//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzIuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHdCQUF3QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw0QkFBNEI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiw2QkFBNkI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93b3Jrc3BhY2UvLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanM/MmRiYSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxudmFyIHN0eWxlc0luRE9NID0gW107XG5mdW5jdGlvbiBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKSB7XG4gIHZhciByZXN1bHQgPSAtMTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXNJbkRPTS5sZW5ndGg7IGkrKykge1xuICAgIGlmIChzdHlsZXNJbkRPTVtpXS5pZGVudGlmaWVyID09PSBpZGVudGlmaWVyKSB7XG4gICAgICByZXN1bHQgPSBpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBtb2R1bGVzVG9Eb20obGlzdCwgb3B0aW9ucykge1xuICB2YXIgaWRDb3VudE1hcCA9IHt9O1xuICB2YXIgaWRlbnRpZmllcnMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGl0ZW0gPSBsaXN0W2ldO1xuICAgIHZhciBpZCA9IG9wdGlvbnMuYmFzZSA/IGl0ZW1bMF0gKyBvcHRpb25zLmJhc2UgOiBpdGVtWzBdO1xuICAgIHZhciBjb3VudCA9IGlkQ291bnRNYXBbaWRdIHx8IDA7XG4gICAgdmFyIGlkZW50aWZpZXIgPSBcIlwiLmNvbmNhdChpZCwgXCIgXCIpLmNvbmNhdChjb3VudCk7XG4gICAgaWRDb3VudE1hcFtpZF0gPSBjb3VudCArIDE7XG4gICAgdmFyIGluZGV4QnlJZGVudGlmaWVyID0gZ2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcik7XG4gICAgdmFyIG9iaiA9IHtcbiAgICAgIGNzczogaXRlbVsxXSxcbiAgICAgIG1lZGlhOiBpdGVtWzJdLFxuICAgICAgc291cmNlTWFwOiBpdGVtWzNdLFxuICAgICAgc3VwcG9ydHM6IGl0ZW1bNF0sXG4gICAgICBsYXllcjogaXRlbVs1XVxuICAgIH07XG4gICAgaWYgKGluZGV4QnlJZGVudGlmaWVyICE9PSAtMSkge1xuICAgICAgc3R5bGVzSW5ET01baW5kZXhCeUlkZW50aWZpZXJdLnJlZmVyZW5jZXMrKztcbiAgICAgIHN0eWxlc0luRE9NW2luZGV4QnlJZGVudGlmaWVyXS51cGRhdGVyKG9iaik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB1cGRhdGVyID0gYWRkRWxlbWVudFN0eWxlKG9iaiwgb3B0aW9ucyk7XG4gICAgICBvcHRpb25zLmJ5SW5kZXggPSBpO1xuICAgICAgc3R5bGVzSW5ET00uc3BsaWNlKGksIDAsIHtcbiAgICAgICAgaWRlbnRpZmllcjogaWRlbnRpZmllcixcbiAgICAgICAgdXBkYXRlcjogdXBkYXRlcixcbiAgICAgICAgcmVmZXJlbmNlczogMVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlkZW50aWZpZXJzLnB1c2goaWRlbnRpZmllcik7XG4gIH1cbiAgcmV0dXJuIGlkZW50aWZpZXJzO1xufVxuZnVuY3Rpb24gYWRkRWxlbWVudFN0eWxlKG9iaiwgb3B0aW9ucykge1xuICB2YXIgYXBpID0gb3B0aW9ucy5kb21BUEkob3B0aW9ucyk7XG4gIGFwaS51cGRhdGUob2JqKTtcbiAgdmFyIHVwZGF0ZXIgPSBmdW5jdGlvbiB1cGRhdGVyKG5ld09iaikge1xuICAgIGlmIChuZXdPYmopIHtcbiAgICAgIGlmIChuZXdPYmouY3NzID09PSBvYmouY3NzICYmIG5ld09iai5tZWRpYSA9PT0gb2JqLm1lZGlhICYmIG5ld09iai5zb3VyY2VNYXAgPT09IG9iai5zb3VyY2VNYXAgJiYgbmV3T2JqLnN1cHBvcnRzID09PSBvYmouc3VwcG9ydHMgJiYgbmV3T2JqLmxheWVyID09PSBvYmoubGF5ZXIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgYXBpLnVwZGF0ZShvYmogPSBuZXdPYmopO1xuICAgIH0gZWxzZSB7XG4gICAgICBhcGkucmVtb3ZlKCk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gdXBkYXRlcjtcbn1cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGxpc3QsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGxpc3QgPSBsaXN0IHx8IFtdO1xuICB2YXIgbGFzdElkZW50aWZpZXJzID0gbW9kdWxlc1RvRG9tKGxpc3QsIG9wdGlvbnMpO1xuICByZXR1cm4gZnVuY3Rpb24gdXBkYXRlKG5ld0xpc3QpIHtcbiAgICBuZXdMaXN0ID0gbmV3TGlzdCB8fCBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxhc3RJZGVudGlmaWVycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGlkZW50aWZpZXIgPSBsYXN0SWRlbnRpZmllcnNbaV07XG4gICAgICB2YXIgaW5kZXggPSBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKTtcbiAgICAgIHN0eWxlc0luRE9NW2luZGV4XS5yZWZlcmVuY2VzLS07XG4gICAgfVxuICAgIHZhciBuZXdMYXN0SWRlbnRpZmllcnMgPSBtb2R1bGVzVG9Eb20obmV3TGlzdCwgb3B0aW9ucyk7XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGxhc3RJZGVudGlmaWVycy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBfaWRlbnRpZmllciA9IGxhc3RJZGVudGlmaWVyc1tfaV07XG4gICAgICB2YXIgX2luZGV4ID0gZ2V0SW5kZXhCeUlkZW50aWZpZXIoX2lkZW50aWZpZXIpO1xuICAgICAgaWYgKHN0eWxlc0luRE9NW19pbmRleF0ucmVmZXJlbmNlcyA9PT0gMCkge1xuICAgICAgICBzdHlsZXNJbkRPTVtfaW5kZXhdLnVwZGF0ZXIoKTtcbiAgICAgICAgc3R5bGVzSW5ET00uc3BsaWNlKF9pbmRleCwgMSk7XG4gICAgICB9XG4gICAgfVxuICAgIGxhc3RJZGVudGlmaWVycyA9IG5ld0xhc3RJZGVudGlmaWVycztcbiAgfTtcbn07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\\n//# sourceURL=webpack-internal:///72\\n\\n}')},113:module=>{\"use strict\";eval(\"{\\n\\n/* istanbul ignore next  */\\nfunction styleTagTransform(css, styleElement) {\\n  if (styleElement.styleSheet) {\\n    styleElement.styleSheet.cssText = css;\\n  } else {\\n    while (styleElement.firstChild) {\\n      styleElement.removeChild(styleElement.firstChild);\\n    }\\n    styleElement.appendChild(document.createTextNode(css));\\n  }\\n}\\nmodule.exports = styleTagTransform;//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTEzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd29ya3NwYWNlLy4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvc3R5bGVUYWdUcmFuc2Zvcm0uanM/MWRkZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5mdW5jdGlvbiBzdHlsZVRhZ1RyYW5zZm9ybShjc3MsIHN0eWxlRWxlbWVudCkge1xuICBpZiAoc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQpIHtcbiAgICBzdHlsZUVsZW1lbnQuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xuICB9IGVsc2Uge1xuICAgIHdoaWxlIChzdHlsZUVsZW1lbnQuZmlyc3RDaGlsZCkge1xuICAgICAgc3R5bGVFbGVtZW50LnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudC5maXJzdENoaWxkKTtcbiAgICB9XG4gICAgc3R5bGVFbGVtZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IHN0eWxlVGFnVHJhbnNmb3JtOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\\n//# sourceURL=webpack-internal:///113\\n\\n}\")},115:t=>{\"use strict\";t.exports=\"data:image/svg+xml,%3csvg xmlns=%27http://www.w3.org/2000/svg%27 viewBox=%270 0 16 16%27%3e%3cpath fill=%27none%27 stroke=%27%23dee2e6%27 stroke-linecap=%27round%27 stroke-linejoin=%27round%27 stroke-width=%272%27 d=%27m2 5 6 6 6-6%27/%3e%3c/svg%3e\"},154:t=>{\"use strict\";t.exports=\"data:image/svg+xml,%3csvg xmlns=%27http://www.w3.org/2000/svg%27 viewBox=%27-4 -4 8 8%27%3e%3ccircle r=%273%27 fill=%27rgba%280, 0, 0, 0.25%29%27/%3e%3c/svg%3e\"},159:module=>{\"use strict\";eval('{\\n\\n/* istanbul ignore next  */\\nfunction insertStyleElement(options) {\\n  var element = document.createElement(\"style\");\\n  options.setAttributes(element, options.attributes);\\n  options.insert(element, options.options);\\n  return element;\\n}\\nmodule.exports = insertStyleElement;//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTU5LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93b3Jrc3BhY2UvLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbnNlcnRTdHlsZUVsZW1lbnQuanM/ZGU2YyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5mdW5jdGlvbiBpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucykge1xuICB2YXIgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcbiAgb3B0aW9ucy5zZXRBdHRyaWJ1dGVzKGVsZW1lbnQsIG9wdGlvbnMuYXR0cmlidXRlcyk7XG4gIG9wdGlvbnMuaW5zZXJ0KGVsZW1lbnQsIG9wdGlvbnMub3B0aW9ucyk7XG4gIHJldHVybiBlbGVtZW50O1xufVxubW9kdWxlLmV4cG9ydHMgPSBpbnNlcnRTdHlsZUVsZW1lbnQ7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\\n//# sourceURL=webpack-internal:///159\\n\\n}')},221:(__unused_webpack_module,exports,__webpack_require__)=>{\"use strict\";eval('{/**\\n * @license React\\n * react-dom.production.js\\n *\\n * Copyright (c) Meta Platforms, Inc. and affiliates.\\n *\\n * This source code is licensed under the MIT license found in the\\n * LICENSE file in the root directory of this source tree.\\n */\\n\\n\\nvar React = __webpack_require__(540);\\nfunction formatProdErrorMessage(code) {\\n  var url = \"https://react.dev/errors/\" + code;\\n  if (1 < arguments.length) {\\n    url += \"?args[]=\" + encodeURIComponent(arguments[1]);\\n    for (var i = 2; i < arguments.length; i++)\\n      url += \"&args[]=\" + encodeURIComponent(arguments[i]);\\n  }\\n  return (\\n    \"Minified React error #\" +\\n    code +\\n    \"; visit \" +\\n    url +\\n    \" for the full message or use the non-minified dev environment for full errors and additional helpful warnings.\"\\n  );\\n}\\nfunction noop() {}\\nvar Internals = {\\n    d: {\\n      f: noop,\\n      r: function () {\\n        throw Error(formatProdErrorMessage(522));\\n      },\\n      D: noop,\\n      C: noop,\\n      L: noop,\\n      m: noop,\\n      X: noop,\\n      S: noop,\\n      M: noop\\n    },\\n    p: 0,\\n    findDOMNode: null\\n  },\\n  REACT_PORTAL_TYPE = Symbol.for(\"react.portal\");\\nfunction createPortal$1(children, containerInfo, implementation) {\\n  var key =\\n    3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;\\n  return {\\n    $$typeof: REACT_PORTAL_TYPE,\\n    key: null == key ? null : \"\" + key,\\n    children: children,\\n    containerInfo: containerInfo,\\n    implementation: implementation\\n  };\\n}\\nvar ReactSharedInternals =\\n  React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;\\nfunction getCrossOriginStringAs(as, input) {\\n  if (\"font\" === as) return \"\";\\n  if (\"string\" === typeof input)\\n    return \"use-credentials\" === input ? input : \"\";\\n}\\nexports.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE =\\n  Internals;\\nexports.createPortal = function (children, container) {\\n  var key =\\n    2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;\\n  if (\\n    !container ||\\n    (1 !== container.nodeType &&\\n      9 !== container.nodeType &&\\n      11 !== container.nodeType)\\n  )\\n    throw Error(formatProdErrorMessage(299));\\n  return createPortal$1(children, container, null, key);\\n};\\nexports.flushSync = function (fn) {\\n  var previousTransition = ReactSharedInternals.T,\\n    previousUpdatePriority = Internals.p;\\n  try {\\n    if (((ReactSharedInternals.T = null), (Internals.p = 2), fn)) return fn();\\n  } finally {\\n    (ReactSharedInternals.T = previousTransition),\\n      (Internals.p = previousUpdatePriority),\\n      Internals.d.f();\\n  }\\n};\\nexports.preconnect = function (href, options) {\\n  \"string\" === typeof href &&\\n    (options\\n      ? ((options = options.crossOrigin),\\n        (options =\\n          \"string\" === typeof options\\n            ? \"use-credentials\" === options\\n              ? options\\n              : \"\"\\n            : void 0))\\n      : (options = null),\\n    Internals.d.C(href, options));\\n};\\nexports.prefetchDNS = function (href) {\\n  \"string\" === typeof href && Internals.d.D(href);\\n};\\nexports.preinit = function (href, options) {\\n  if (\"string\" === typeof href && options && \"string\" === typeof options.as) {\\n    var as = options.as,\\n      crossOrigin = getCrossOriginStringAs(as, options.crossOrigin),\\n      integrity =\\n        \"string\" === typeof options.integrity ? options.integrity : void 0,\\n      fetchPriority =\\n        \"string\" === typeof options.fetchPriority\\n          ? options.fetchPriority\\n          : void 0;\\n    \"style\" === as\\n      ? Internals.d.S(\\n          href,\\n          \"string\" === typeof options.precedence ? options.precedence : void 0,\\n          {\\n            crossOrigin: crossOrigin,\\n            integrity: integrity,\\n            fetchPriority: fetchPriority\\n          }\\n        )\\n      : \"script\" === as &&\\n        Internals.d.X(href, {\\n          crossOrigin: crossOrigin,\\n          integrity: integrity,\\n          fetchPriority: fetchPriority,\\n          nonce: \"string\" === typeof options.nonce ? options.nonce : void 0\\n        });\\n  }\\n};\\nexports.preinitModule = function (href, options) {\\n  if (\"string\" === typeof href)\\n    if (\"object\" === typeof options && null !== options) {\\n      if (null == options.as || \"script\" === options.as) {\\n        var crossOrigin = getCrossOriginStringAs(\\n          options.as,\\n          options.crossOrigin\\n        );\\n        Internals.d.M(href, {\\n          crossOrigin: crossOrigin,\\n          integrity:\\n            \"string\" === typeof options.integrity ? options.integrity : void 0,\\n          nonce: \"string\" === typeof options.nonce ? options.nonce : void 0\\n        });\\n      }\\n    } else null == options && Internals.d.M(href);\\n};\\nexports.preload = function (href, options) {\\n  if (\\n    \"string\" === typeof href &&\\n    \"object\" === typeof options &&\\n    null !== options &&\\n    \"string\" === typeof options.as\\n  ) {\\n    var as = options.as,\\n      crossOrigin = getCrossOriginStringAs(as, options.crossOrigin);\\n    Internals.d.L(href, as, {\\n      crossOrigin: crossOrigin,\\n      integrity:\\n        \"string\" === typeof options.integrity ? options.integrity : void 0,\\n      nonce: \"string\" === typeof options.nonce ? options.nonce : void 0,\\n      type: \"string\" === typeof options.type ? options.type : void 0,\\n      fetchPriority:\\n        \"string\" === typeof options.fetchPriority\\n          ? options.fetchPriority\\n          : void 0,\\n      referrerPolicy:\\n        \"string\" === typeof options.referrerPolicy\\n          ? options.referrerPolicy\\n          : void 0,\\n      imageSrcSet:\\n        \"string\" === typeof options.imageSrcSet ? options.imageSrcSet : void 0,\\n      imageSizes:\\n        \"string\" === typeof options.imageSizes ? options.imageSizes : void 0,\\n      media: \"string\" === typeof options.media ? options.media : void 0\\n    });\\n  }\\n};\\nexports.preloadModule = function (href, options) {\\n  if (\"string\" === typeof href)\\n    if (options) {\\n      var crossOrigin = getCrossOriginStringAs(options.as, options.crossOrigin);\\n      Internals.d.m(href, {\\n        as:\\n          \"string\" === typeof options.as && \"script\" !== options.as\\n            ? options.as\\n            : void 0,\\n        crossOrigin: crossOrigin,\\n        integrity:\\n          \"string\" === typeof options.integrity ? options.integrity : void 0\\n      });\\n    } else Internals.d.m(href);\\n};\\nexports.requestFormReset = function (form) {\\n  Internals.d.r(form);\\n};\\nexports.unstable_batchedUpdates = function (fn, a) {\\n  return fn(a);\\n};\\nexports.useFormState = function (action, initialState, permalink) {\\n  return ReactSharedInternals.H.useFormState(action, initialState, permalink);\\n};\\nexports.useFormStatus = function () {\\n  return ReactSharedInternals.H.useHostTransitionStatus();\\n};\\nexports.version = \"19.1.1\";\\n//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjIxLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTtBQUNiLFlBQVksbUJBQU8sQ0FBQyxHQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0U7QUFDcEU7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxlQUFlIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd29ya3NwYWNlLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9janMvcmVhY3QtZG9tLnByb2R1Y3Rpb24uanM/NzNkZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC1kb20ucHJvZHVjdGlvbi5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgUmVhY3QgPSByZXF1aXJlKFwicmVhY3RcIik7XG5mdW5jdGlvbiBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKGNvZGUpIHtcbiAgdmFyIHVybCA9IFwiaHR0cHM6Ly9yZWFjdC5kZXYvZXJyb3JzL1wiICsgY29kZTtcbiAgaWYgKDEgPCBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgdXJsICs9IFwiP2FyZ3NbXT1cIiArIGVuY29kZVVSSUNvbXBvbmVudChhcmd1bWVudHNbMV0pO1xuICAgIGZvciAodmFyIGkgPSAyOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKVxuICAgICAgdXJsICs9IFwiJmFyZ3NbXT1cIiArIGVuY29kZVVSSUNvbXBvbmVudChhcmd1bWVudHNbaV0pO1xuICB9XG4gIHJldHVybiAoXG4gICAgXCJNaW5pZmllZCBSZWFjdCBlcnJvciAjXCIgK1xuICAgIGNvZGUgK1xuICAgIFwiOyB2aXNpdCBcIiArXG4gICAgdXJsICtcbiAgICBcIiBmb3IgdGhlIGZ1bGwgbWVzc2FnZSBvciB1c2UgdGhlIG5vbi1taW5pZmllZCBkZXYgZW52aXJvbm1lbnQgZm9yIGZ1bGwgZXJyb3JzIGFuZCBhZGRpdGlvbmFsIGhlbHBmdWwgd2FybmluZ3MuXCJcbiAgKTtcbn1cbmZ1bmN0aW9uIG5vb3AoKSB7fVxudmFyIEludGVybmFscyA9IHtcbiAgICBkOiB7XG4gICAgICBmOiBub29wLFxuICAgICAgcjogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aHJvdyBFcnJvcihmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDUyMikpO1xuICAgICAgfSxcbiAgICAgIEQ6IG5vb3AsXG4gICAgICBDOiBub29wLFxuICAgICAgTDogbm9vcCxcbiAgICAgIG06IG5vb3AsXG4gICAgICBYOiBub29wLFxuICAgICAgUzogbm9vcCxcbiAgICAgIE06IG5vb3BcbiAgICB9LFxuICAgIHA6IDAsXG4gICAgZmluZERPTU5vZGU6IG51bGxcbiAgfSxcbiAgUkVBQ1RfUE9SVEFMX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QucG9ydGFsXCIpO1xuZnVuY3Rpb24gY3JlYXRlUG9ydGFsJDEoY2hpbGRyZW4sIGNvbnRhaW5lckluZm8sIGltcGxlbWVudGF0aW9uKSB7XG4gIHZhciBrZXkgPVxuICAgIDMgPCBhcmd1bWVudHMubGVuZ3RoICYmIHZvaWQgMCAhPT0gYXJndW1lbnRzWzNdID8gYXJndW1lbnRzWzNdIDogbnVsbDtcbiAgcmV0dXJuIHtcbiAgICAkJHR5cGVvZjogUkVBQ1RfUE9SVEFMX1RZUEUsXG4gICAga2V5OiBudWxsID09IGtleSA/IG51bGwgOiBcIlwiICsga2V5LFxuICAgIGNoaWxkcmVuOiBjaGlsZHJlbixcbiAgICBjb250YWluZXJJbmZvOiBjb250YWluZXJJbmZvLFxuICAgIGltcGxlbWVudGF0aW9uOiBpbXBsZW1lbnRhdGlvblxuICB9O1xufVxudmFyIFJlYWN0U2hhcmVkSW50ZXJuYWxzID1cbiAgUmVhY3QuX19DTElFTlRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfV0FSTl9VU0VSU19USEVZX0NBTk5PVF9VUEdSQURFO1xuZnVuY3Rpb24gZ2V0Q3Jvc3NPcmlnaW5TdHJpbmdBcyhhcywgaW5wdXQpIHtcbiAgaWYgKFwiZm9udFwiID09PSBhcykgcmV0dXJuIFwiXCI7XG4gIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgaW5wdXQpXG4gICAgcmV0dXJuIFwidXNlLWNyZWRlbnRpYWxzXCIgPT09IGlucHV0ID8gaW5wdXQgOiBcIlwiO1xufVxuZXhwb3J0cy5fX0RPTV9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9XQVJOX1VTRVJTX1RIRVlfQ0FOTk9UX1VQR1JBREUgPVxuICBJbnRlcm5hbHM7XG5leHBvcnRzLmNyZWF0ZVBvcnRhbCA9IGZ1bmN0aW9uIChjaGlsZHJlbiwgY29udGFpbmVyKSB7XG4gIHZhciBrZXkgPVxuICAgIDIgPCBhcmd1bWVudHMubGVuZ3RoICYmIHZvaWQgMCAhPT0gYXJndW1lbnRzWzJdID8gYXJndW1lbnRzWzJdIDogbnVsbDtcbiAgaWYgKFxuICAgICFjb250YWluZXIgfHxcbiAgICAoMSAhPT0gY29udGFpbmVyLm5vZGVUeXBlICYmXG4gICAgICA5ICE9PSBjb250YWluZXIubm9kZVR5cGUgJiZcbiAgICAgIDExICE9PSBjb250YWluZXIubm9kZVR5cGUpXG4gIClcbiAgICB0aHJvdyBFcnJvcihmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDI5OSkpO1xuICByZXR1cm4gY3JlYXRlUG9ydGFsJDEoY2hpbGRyZW4sIGNvbnRhaW5lciwgbnVsbCwga2V5KTtcbn07XG5leHBvcnRzLmZsdXNoU3luYyA9IGZ1bmN0aW9uIChmbikge1xuICB2YXIgcHJldmlvdXNUcmFuc2l0aW9uID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCxcbiAgICBwcmV2aW91c1VwZGF0ZVByaW9yaXR5ID0gSW50ZXJuYWxzLnA7XG4gIHRyeSB7XG4gICAgaWYgKCgoUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCA9IG51bGwpLCAoSW50ZXJuYWxzLnAgPSAyKSwgZm4pKSByZXR1cm4gZm4oKTtcbiAgfSBmaW5hbGx5IHtcbiAgICAoUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCA9IHByZXZpb3VzVHJhbnNpdGlvbiksXG4gICAgICAoSW50ZXJuYWxzLnAgPSBwcmV2aW91c1VwZGF0ZVByaW9yaXR5KSxcbiAgICAgIEludGVybmFscy5kLmYoKTtcbiAgfVxufTtcbmV4cG9ydHMucHJlY29ubmVjdCA9IGZ1bmN0aW9uIChocmVmLCBvcHRpb25zKSB7XG4gIFwic3RyaW5nXCIgPT09IHR5cGVvZiBocmVmICYmXG4gICAgKG9wdGlvbnNcbiAgICAgID8gKChvcHRpb25zID0gb3B0aW9ucy5jcm9zc09yaWdpbiksXG4gICAgICAgIChvcHRpb25zID1cbiAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2Ygb3B0aW9uc1xuICAgICAgICAgICAgPyBcInVzZS1jcmVkZW50aWFsc1wiID09PSBvcHRpb25zXG4gICAgICAgICAgICAgID8gb3B0aW9uc1xuICAgICAgICAgICAgICA6IFwiXCJcbiAgICAgICAgICAgIDogdm9pZCAwKSlcbiAgICAgIDogKG9wdGlvbnMgPSBudWxsKSxcbiAgICBJbnRlcm5hbHMuZC5DKGhyZWYsIG9wdGlvbnMpKTtcbn07XG5leHBvcnRzLnByZWZldGNoRE5TID0gZnVuY3Rpb24gKGhyZWYpIHtcbiAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGhyZWYgJiYgSW50ZXJuYWxzLmQuRChocmVmKTtcbn07XG5leHBvcnRzLnByZWluaXQgPSBmdW5jdGlvbiAoaHJlZiwgb3B0aW9ucykge1xuICBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGhyZWYgJiYgb3B0aW9ucyAmJiBcInN0cmluZ1wiID09PSB0eXBlb2Ygb3B0aW9ucy5hcykge1xuICAgIHZhciBhcyA9IG9wdGlvbnMuYXMsXG4gICAgICBjcm9zc09yaWdpbiA9IGdldENyb3NzT3JpZ2luU3RyaW5nQXMoYXMsIG9wdGlvbnMuY3Jvc3NPcmlnaW4pLFxuICAgICAgaW50ZWdyaXR5ID1cbiAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIG9wdGlvbnMuaW50ZWdyaXR5ID8gb3B0aW9ucy5pbnRlZ3JpdHkgOiB2b2lkIDAsXG4gICAgICBmZXRjaFByaW9yaXR5ID1cbiAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIG9wdGlvbnMuZmV0Y2hQcmlvcml0eVxuICAgICAgICAgID8gb3B0aW9ucy5mZXRjaFByaW9yaXR5XG4gICAgICAgICAgOiB2b2lkIDA7XG4gICAgXCJzdHlsZVwiID09PSBhc1xuICAgICAgPyBJbnRlcm5hbHMuZC5TKFxuICAgICAgICAgIGhyZWYsXG4gICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIG9wdGlvbnMucHJlY2VkZW5jZSA/IG9wdGlvbnMucHJlY2VkZW5jZSA6IHZvaWQgMCxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjcm9zc09yaWdpbjogY3Jvc3NPcmlnaW4sXG4gICAgICAgICAgICBpbnRlZ3JpdHk6IGludGVncml0eSxcbiAgICAgICAgICAgIGZldGNoUHJpb3JpdHk6IGZldGNoUHJpb3JpdHlcbiAgICAgICAgICB9XG4gICAgICAgIClcbiAgICAgIDogXCJzY3JpcHRcIiA9PT0gYXMgJiZcbiAgICAgICAgSW50ZXJuYWxzLmQuWChocmVmLCB7XG4gICAgICAgICAgY3Jvc3NPcmlnaW46IGNyb3NzT3JpZ2luLFxuICAgICAgICAgIGludGVncml0eTogaW50ZWdyaXR5LFxuICAgICAgICAgIGZldGNoUHJpb3JpdHk6IGZldGNoUHJpb3JpdHksXG4gICAgICAgICAgbm9uY2U6IFwic3RyaW5nXCIgPT09IHR5cGVvZiBvcHRpb25zLm5vbmNlID8gb3B0aW9ucy5ub25jZSA6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgfVxufTtcbmV4cG9ydHMucHJlaW5pdE1vZHVsZSA9IGZ1bmN0aW9uIChocmVmLCBvcHRpb25zKSB7XG4gIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgaHJlZilcbiAgICBpZiAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIG9wdGlvbnMgJiYgbnVsbCAhPT0gb3B0aW9ucykge1xuICAgICAgaWYgKG51bGwgPT0gb3B0aW9ucy5hcyB8fCBcInNjcmlwdFwiID09PSBvcHRpb25zLmFzKSB7XG4gICAgICAgIHZhciBjcm9zc09yaWdpbiA9IGdldENyb3NzT3JpZ2luU3RyaW5nQXMoXG4gICAgICAgICAgb3B0aW9ucy5hcyxcbiAgICAgICAgICBvcHRpb25zLmNyb3NzT3JpZ2luXG4gICAgICAgICk7XG4gICAgICAgIEludGVybmFscy5kLk0oaHJlZiwge1xuICAgICAgICAgIGNyb3NzT3JpZ2luOiBjcm9zc09yaWdpbixcbiAgICAgICAgICBpbnRlZ3JpdHk6XG4gICAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2Ygb3B0aW9ucy5pbnRlZ3JpdHkgPyBvcHRpb25zLmludGVncml0eSA6IHZvaWQgMCxcbiAgICAgICAgICBub25jZTogXCJzdHJpbmdcIiA9PT0gdHlwZW9mIG9wdGlvbnMubm9uY2UgPyBvcHRpb25zLm5vbmNlIDogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSBudWxsID09IG9wdGlvbnMgJiYgSW50ZXJuYWxzLmQuTShocmVmKTtcbn07XG5leHBvcnRzLnByZWxvYWQgPSBmdW5jdGlvbiAoaHJlZiwgb3B0aW9ucykge1xuICBpZiAoXG4gICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGhyZWYgJiZcbiAgICBcIm9iamVjdFwiID09PSB0eXBlb2Ygb3B0aW9ucyAmJlxuICAgIG51bGwgIT09IG9wdGlvbnMgJiZcbiAgICBcInN0cmluZ1wiID09PSB0eXBlb2Ygb3B0aW9ucy5hc1xuICApIHtcbiAgICB2YXIgYXMgPSBvcHRpb25zLmFzLFxuICAgICAgY3Jvc3NPcmlnaW4gPSBnZXRDcm9zc09yaWdpblN0cmluZ0FzKGFzLCBvcHRpb25zLmNyb3NzT3JpZ2luKTtcbiAgICBJbnRlcm5hbHMuZC5MKGhyZWYsIGFzLCB7XG4gICAgICBjcm9zc09yaWdpbjogY3Jvc3NPcmlnaW4sXG4gICAgICBpbnRlZ3JpdHk6XG4gICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBvcHRpb25zLmludGVncml0eSA/IG9wdGlvbnMuaW50ZWdyaXR5IDogdm9pZCAwLFxuICAgICAgbm9uY2U6IFwic3RyaW5nXCIgPT09IHR5cGVvZiBvcHRpb25zLm5vbmNlID8gb3B0aW9ucy5ub25jZSA6IHZvaWQgMCxcbiAgICAgIHR5cGU6IFwic3RyaW5nXCIgPT09IHR5cGVvZiBvcHRpb25zLnR5cGUgPyBvcHRpb25zLnR5cGUgOiB2b2lkIDAsXG4gICAgICBmZXRjaFByaW9yaXR5OlxuICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2Ygb3B0aW9ucy5mZXRjaFByaW9yaXR5XG4gICAgICAgICAgPyBvcHRpb25zLmZldGNoUHJpb3JpdHlcbiAgICAgICAgICA6IHZvaWQgMCxcbiAgICAgIHJlZmVycmVyUG9saWN5OlxuICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2Ygb3B0aW9ucy5yZWZlcnJlclBvbGljeVxuICAgICAgICAgID8gb3B0aW9ucy5yZWZlcnJlclBvbGljeVxuICAgICAgICAgIDogdm9pZCAwLFxuICAgICAgaW1hZ2VTcmNTZXQ6XG4gICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBvcHRpb25zLmltYWdlU3JjU2V0ID8gb3B0aW9ucy5pbWFnZVNyY1NldCA6IHZvaWQgMCxcbiAgICAgIGltYWdlU2l6ZXM6XG4gICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBvcHRpb25zLmltYWdlU2l6ZXMgPyBvcHRpb25zLmltYWdlU2l6ZXMgOiB2b2lkIDAsXG4gICAgICBtZWRpYTogXCJzdHJpbmdcIiA9PT0gdHlwZW9mIG9wdGlvbnMubWVkaWEgPyBvcHRpb25zLm1lZGlhIDogdm9pZCAwXG4gICAgfSk7XG4gIH1cbn07XG5leHBvcnRzLnByZWxvYWRNb2R1bGUgPSBmdW5jdGlvbiAoaHJlZiwgb3B0aW9ucykge1xuICBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGhyZWYpXG4gICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgIHZhciBjcm9zc09yaWdpbiA9IGdldENyb3NzT3JpZ2luU3RyaW5nQXMob3B0aW9ucy5hcywgb3B0aW9ucy5jcm9zc09yaWdpbik7XG4gICAgICBJbnRlcm5hbHMuZC5tKGhyZWYsIHtcbiAgICAgICAgYXM6XG4gICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIG9wdGlvbnMuYXMgJiYgXCJzY3JpcHRcIiAhPT0gb3B0aW9ucy5hc1xuICAgICAgICAgICAgPyBvcHRpb25zLmFzXG4gICAgICAgICAgICA6IHZvaWQgMCxcbiAgICAgICAgY3Jvc3NPcmlnaW46IGNyb3NzT3JpZ2luLFxuICAgICAgICBpbnRlZ3JpdHk6XG4gICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIG9wdGlvbnMuaW50ZWdyaXR5ID8gb3B0aW9ucy5pbnRlZ3JpdHkgOiB2b2lkIDBcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBJbnRlcm5hbHMuZC5tKGhyZWYpO1xufTtcbmV4cG9ydHMucmVxdWVzdEZvcm1SZXNldCA9IGZ1bmN0aW9uIChmb3JtKSB7XG4gIEludGVybmFscy5kLnIoZm9ybSk7XG59O1xuZXhwb3J0cy51bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyA9IGZ1bmN0aW9uIChmbiwgYSkge1xuICByZXR1cm4gZm4oYSk7XG59O1xuZXhwb3J0cy51c2VGb3JtU3RhdGUgPSBmdW5jdGlvbiAoYWN0aW9uLCBpbml0aWFsU3RhdGUsIHBlcm1hbGluaykge1xuICByZXR1cm4gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSC51c2VGb3JtU3RhdGUoYWN0aW9uLCBpbml0aWFsU3RhdGUsIHBlcm1hbGluayk7XG59O1xuZXhwb3J0cy51c2VGb3JtU3RhdHVzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSC51c2VIb3N0VHJhbnNpdGlvblN0YXR1cygpO1xufTtcbmV4cG9ydHMudmVyc2lvbiA9IFwiMTkuMS4xXCI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\\n//# sourceURL=webpack-internal:///221\\n\\n}')},247:(__unused_webpack_module,exports,__webpack_require__)=>{\"use strict\";eval('{/**\\n * @license React\\n * react-dom-client.production.js\\n *\\n * Copyright (c) Meta Platforms, Inc. and affiliates.\\n *\\n * This source code is licensed under the MIT license found in the\\n * LICENSE file in the root directory of this source tree.\\n */\\n\\n/*\\n Modernizr 3.0.0pre (Custom Build) | MIT\\n*/\\n\\nvar Scheduler = __webpack_require__(982),\\n  React = __webpack_require__(540),\\n  ReactDOM = __webpack_require__(961);\\nfunction formatProdErrorMessage(code) {\\n  var url = \"https://react.dev/errors/\" + code;\\n  if (1 < arguments.length) {\\n    url += \"?args[]=\" + encodeURIComponent(arguments[1]);\\n    for (var i = 2; i < arguments.length; i++)\\n      url += \"&args[]=\" + encodeURIComponent(arguments[i]);\\n  }\\n  return (\\n    \"Minified React error #\" +\\n    code +\\n    \"; visit \" +\\n    url +\\n    \" for the full message or use the non-minified dev environment for full errors and additional helpful warnings.\"\\n  );\\n}\\nfunction isValidContainer(node) {\\n  return !(\\n    !node ||\\n    (1 !== node.nodeType && 9 !== node.nodeType && 11 !== node.nodeType)\\n  );\\n}\\nfunction getNearestMountedFiber(fiber) {\\n  var node = fiber,\\n    nearestMounted = fiber;\\n  if (fiber.alternate) for (; node.return; ) node = node.return;\\n  else {\\n    fiber = node;\\n    do\\n      (node = fiber),\\n        0 !== (node.flags & 4098) && (nearestMounted = node.return),\\n        (fiber = node.return);\\n    while (fiber);\\n  }\\n  return 3 === node.tag ? nearestMounted : null;\\n}\\nfunction getSuspenseInstanceFromFiber(fiber) {\\n  if (13 === fiber.tag) {\\n    var suspenseState = fiber.memoizedState;\\n    null === suspenseState &&\\n      ((fiber = fiber.alternate),\\n      null !== fiber && (suspenseState = fiber.memoizedState));\\n    if (null !== suspenseState) return suspenseState.dehydrated;\\n  }\\n  return null;\\n}\\nfunction assertIsMounted(fiber) {\\n  if (getNearestMountedFiber(fiber) !== fiber)\\n    throw Error(formatProdErrorMessage(188));\\n}\\nfunction findCurrentFiberUsingSlowPath(fiber) {\\n  var alternate = fiber.alternate;\\n  if (!alternate) {\\n    alternate = getNearestMountedFiber(fiber);\\n    if (null === alternate) throw Error(formatProdErrorMessage(188));\\n    return alternate !== fiber ? null : fiber;\\n  }\\n  for (var a = fiber, b = alternate; ; ) {\\n    var parentA = a.return;\\n    if (null === parentA) break;\\n    var parentB = parentA.alternate;\\n    if (null === parentB) {\\n      b = parentA.return;\\n      if (null !== b) {\\n        a = b;\\n        continue;\\n      }\\n      break;\\n    }\\n    if (parentA.child === parentB.child) {\\n      for (parentB = parentA.child; parentB; ) {\\n        if (parentB === a) return assertIsMounted(parentA), fiber;\\n        if (parentB === b) return assertIsMounted(parentA), alternate;\\n        parentB = parentB.sibling;\\n      }\\n      throw Error(formatProdErrorMessage(188));\\n    }\\n    if (a.return !== b.return) (a = parentA), (b = parentB);\\n    else {\\n      for (var didFindChild = !1, child$0 = parentA.child; child$0; ) {\\n        if (child$0 === a) {\\n          didFindChild = !0;\\n          a = parentA;\\n          b = parentB;\\n          break;\\n        }\\n        if (child$0 === b) {\\n          didFindChild = !0;\\n          b = parentA;\\n          a = parentB;\\n          break;\\n        }\\n        child$0 = child$0.sibling;\\n      }\\n      if (!didFindChild) {\\n        for (child$0 = parentB.child; child$0; ) {\\n          if (child$0 === a) {\\n            didFindChild = !0;\\n            a = parentB;\\n            b = parentA;\\n            break;\\n          }\\n          if (child$0 === b) {\\n            didFindChild = !0;\\n            b = parentB;\\n            a = parentA;\\n            break;\\n          }\\n          child$0 = child$0.sibling;\\n        }\\n        if (!didFindChild) throw Error(formatProdErrorMessage(189));\\n      }\\n    }\\n    if (a.alternate !== b) throw Error(formatProdErrorMessage(190));\\n  }\\n  if (3 !== a.tag) throw Error(formatProdErrorMessage(188));\\n  return a.stateNode.current === a ? fiber : alternate;\\n}\\nfunction findCurrentHostFiberImpl(node) {\\n  var tag = node.tag;\\n  if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return node;\\n  for (node = node.child; null !== node; ) {\\n    tag = findCurrentHostFiberImpl(node);\\n    if (null !== tag) return tag;\\n    node = node.sibling;\\n  }\\n  return null;\\n}\\nvar assign = Object.assign,\\n  REACT_LEGACY_ELEMENT_TYPE = Symbol.for(\"react.element\"),\\n  REACT_ELEMENT_TYPE = Symbol.for(\"react.transitional.element\"),\\n  REACT_PORTAL_TYPE = Symbol.for(\"react.portal\"),\\n  REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\"),\\n  REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\"),\\n  REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\"),\\n  REACT_PROVIDER_TYPE = Symbol.for(\"react.provider\"),\\n  REACT_CONSUMER_TYPE = Symbol.for(\"react.consumer\"),\\n  REACT_CONTEXT_TYPE = Symbol.for(\"react.context\"),\\n  REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\"),\\n  REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\"),\\n  REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\"),\\n  REACT_MEMO_TYPE = Symbol.for(\"react.memo\"),\\n  REACT_LAZY_TYPE = Symbol.for(\"react.lazy\");\\nSymbol.for(\"react.scope\");\\nvar REACT_ACTIVITY_TYPE = Symbol.for(\"react.activity\");\\nSymbol.for(\"react.legacy_hidden\");\\nSymbol.for(\"react.tracing_marker\");\\nvar REACT_MEMO_CACHE_SENTINEL = Symbol.for(\"react.memo_cache_sentinel\");\\nSymbol.for(\"react.view_transition\");\\nvar MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\\nfunction getIteratorFn(maybeIterable) {\\n  if (null === maybeIterable || \"object\" !== typeof maybeIterable) return null;\\n  maybeIterable =\\n    (MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||\\n    maybeIterable[\"@@iterator\"];\\n  return \"function\" === typeof maybeIterable ? maybeIterable : null;\\n}\\nvar REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\");\\nfunction getComponentNameFromType(type) {\\n  if (null == type) return null;\\n  if (\"function\" === typeof type)\\n    return type.$$typeof === REACT_CLIENT_REFERENCE\\n      ? null\\n      : type.displayName || type.name || null;\\n  if (\"string\" === typeof type) return type;\\n  switch (type) {\\n    case REACT_FRAGMENT_TYPE:\\n      return \"Fragment\";\\n    case REACT_PROFILER_TYPE:\\n      return \"Profiler\";\\n    case REACT_STRICT_MODE_TYPE:\\n      return \"StrictMode\";\\n    case REACT_SUSPENSE_TYPE:\\n      return \"Suspense\";\\n    case REACT_SUSPENSE_LIST_TYPE:\\n      return \"SuspenseList\";\\n    case REACT_ACTIVITY_TYPE:\\n      return \"Activity\";\\n  }\\n  if (\"object\" === typeof type)\\n    switch (type.$$typeof) {\\n      case REACT_PORTAL_TYPE:\\n        return \"Portal\";\\n      case REACT_CONTEXT_TYPE:\\n        return (type.displayName || \"Context\") + \".Provider\";\\n      case REACT_CONSUMER_TYPE:\\n        return (type._context.displayName || \"Context\") + \".Consumer\";\\n      case REACT_FORWARD_REF_TYPE:\\n        var innerType = type.render;\\n        type = type.displayName;\\n        type ||\\n          ((type = innerType.displayName || innerType.name || \"\"),\\n          (type = \"\" !== type ? \"ForwardRef(\" + type + \")\" : \"ForwardRef\"));\\n        return type;\\n      case REACT_MEMO_TYPE:\\n        return (\\n          (innerType = type.displayName || null),\\n          null !== innerType\\n            ? innerType\\n            : getComponentNameFromType(type.type) || \"Memo\"\\n        );\\n      case REACT_LAZY_TYPE:\\n        innerType = type._payload;\\n        type = type._init;\\n        try {\\n          return getComponentNameFromType(type(innerType));\\n        } catch (x) {}\\n    }\\n  return null;\\n}\\nvar isArrayImpl = Array.isArray,\\n  ReactSharedInternals =\\n    React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,\\n  ReactDOMSharedInternals =\\n    ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,\\n  sharedNotPendingObject = {\\n    pending: !1,\\n    data: null,\\n    method: null,\\n    action: null\\n  },\\n  valueStack = [],\\n  index = -1;\\nfunction createCursor(defaultValue) {\\n  return { current: defaultValue };\\n}\\nfunction pop(cursor) {\\n  0 > index ||\\n    ((cursor.current = valueStack[index]), (valueStack[index] = null), index--);\\n}\\nfunction push(cursor, value) {\\n  index++;\\n  valueStack[index] = cursor.current;\\n  cursor.current = value;\\n}\\nvar contextStackCursor = createCursor(null),\\n  contextFiberStackCursor = createCursor(null),\\n  rootInstanceStackCursor = createCursor(null),\\n  hostTransitionProviderCursor = createCursor(null);\\nfunction pushHostContainer(fiber, nextRootInstance) {\\n  push(rootInstanceStackCursor, nextRootInstance);\\n  push(contextFiberStackCursor, fiber);\\n  push(contextStackCursor, null);\\n  switch (nextRootInstance.nodeType) {\\n    case 9:\\n    case 11:\\n      fiber = (fiber = nextRootInstance.documentElement)\\n        ? (fiber = fiber.namespaceURI)\\n          ? getOwnHostContext(fiber)\\n          : 0\\n        : 0;\\n      break;\\n    default:\\n      if (\\n        ((fiber = nextRootInstance.tagName),\\n        (nextRootInstance = nextRootInstance.namespaceURI))\\n      )\\n        (nextRootInstance = getOwnHostContext(nextRootInstance)),\\n          (fiber = getChildHostContextProd(nextRootInstance, fiber));\\n      else\\n        switch (fiber) {\\n          case \"svg\":\\n            fiber = 1;\\n            break;\\n          case \"math\":\\n            fiber = 2;\\n            break;\\n          default:\\n            fiber = 0;\\n        }\\n  }\\n  pop(contextStackCursor);\\n  push(contextStackCursor, fiber);\\n}\\nfunction popHostContainer() {\\n  pop(contextStackCursor);\\n  pop(contextFiberStackCursor);\\n  pop(rootInstanceStackCursor);\\n}\\nfunction pushHostContext(fiber) {\\n  null !== fiber.memoizedState && push(hostTransitionProviderCursor, fiber);\\n  var context = contextStackCursor.current;\\n  var JSCompiler_inline_result = getChildHostContextProd(context, fiber.type);\\n  context !== JSCompiler_inline_result &&\\n    (push(contextFiberStackCursor, fiber),\\n    push(contextStackCursor, JSCompiler_inline_result));\\n}\\nfunction popHostContext(fiber) {\\n  contextFiberStackCursor.current === fiber &&\\n    (pop(contextStackCursor), pop(contextFiberStackCursor));\\n  hostTransitionProviderCursor.current === fiber &&\\n    (pop(hostTransitionProviderCursor),\\n    (HostTransitionContext._currentValue = sharedNotPendingObject));\\n}\\nvar hasOwnProperty = Object.prototype.hasOwnProperty,\\n  scheduleCallback$3 = Scheduler.unstable_scheduleCallback,\\n  cancelCallback$1 = Scheduler.unstable_cancelCallback,\\n  shouldYield = Scheduler.unstable_shouldYield,\\n  requestPaint = Scheduler.unstable_requestPaint,\\n  now = Scheduler.unstable_now,\\n  getCurrentPriorityLevel = Scheduler.unstable_getCurrentPriorityLevel,\\n  ImmediatePriority = Scheduler.unstable_ImmediatePriority,\\n  UserBlockingPriority = Scheduler.unstable_UserBlockingPriority,\\n  NormalPriority$1 = Scheduler.unstable_NormalPriority,\\n  LowPriority = Scheduler.unstable_LowPriority,\\n  IdlePriority = Scheduler.unstable_IdlePriority,\\n  log$1 = Scheduler.log,\\n  unstable_setDisableYieldValue = Scheduler.unstable_setDisableYieldValue,\\n  rendererID = null,\\n  injectedHook = null;\\nfunction setIsStrictModeForDevtools(newIsStrictMode) {\\n  \"function\" === typeof log$1 && unstable_setDisableYieldValue(newIsStrictMode);\\n  if (injectedHook && \"function\" === typeof injectedHook.setStrictMode)\\n    try {\\n      injectedHook.setStrictMode(rendererID, newIsStrictMode);\\n    } catch (err) {}\\n}\\nvar clz32 = Math.clz32 ? Math.clz32 : clz32Fallback,\\n  log = Math.log,\\n  LN2 = Math.LN2;\\nfunction clz32Fallback(x) {\\n  x >>>= 0;\\n  return 0 === x ? 32 : (31 - ((log(x) / LN2) | 0)) | 0;\\n}\\nvar nextTransitionLane = 256,\\n  nextRetryLane = 4194304;\\nfunction getHighestPriorityLanes(lanes) {\\n  var pendingSyncLanes = lanes & 42;\\n  if (0 !== pendingSyncLanes) return pendingSyncLanes;\\n  switch (lanes & -lanes) {\\n    case 1:\\n      return 1;\\n    case 2:\\n      return 2;\\n    case 4:\\n      return 4;\\n    case 8:\\n      return 8;\\n    case 16:\\n      return 16;\\n    case 32:\\n      return 32;\\n    case 64:\\n      return 64;\\n    case 128:\\n      return 128;\\n    case 256:\\n    case 512:\\n    case 1024:\\n    case 2048:\\n    case 4096:\\n    case 8192:\\n    case 16384:\\n    case 32768:\\n    case 65536:\\n    case 131072:\\n    case 262144:\\n    case 524288:\\n    case 1048576:\\n    case 2097152:\\n      return lanes & 4194048;\\n    case 4194304:\\n    case 8388608:\\n    case 16777216:\\n    case 33554432:\\n      return lanes & 62914560;\\n    case 67108864:\\n      return 67108864;\\n    case 134217728:\\n      return 134217728;\\n    case 268435456:\\n      return 268435456;\\n    case 536870912:\\n      return 536870912;\\n    case 1073741824:\\n      return 0;\\n    default:\\n      return lanes;\\n  }\\n}\\nfunction getNextLanes(root, wipLanes, rootHasPendingCommit) {\\n  var pendingLanes = root.pendingLanes;\\n  if (0 === pendingLanes) return 0;\\n  var nextLanes = 0,\\n    suspendedLanes = root.suspendedLanes,\\n    pingedLanes = root.pingedLanes;\\n  root = root.warmLanes;\\n  var nonIdlePendingLanes = pendingLanes & 134217727;\\n  0 !== nonIdlePendingLanes\\n    ? ((pendingLanes = nonIdlePendingLanes & ~suspendedLanes),\\n      0 !== pendingLanes\\n        ? (nextLanes = getHighestPriorityLanes(pendingLanes))\\n        : ((pingedLanes &= nonIdlePendingLanes),\\n          0 !== pingedLanes\\n            ? (nextLanes = getHighestPriorityLanes(pingedLanes))\\n            : rootHasPendingCommit ||\\n              ((rootHasPendingCommit = nonIdlePendingLanes & ~root),\\n              0 !== rootHasPendingCommit &&\\n                (nextLanes = getHighestPriorityLanes(rootHasPendingCommit)))))\\n    : ((nonIdlePendingLanes = pendingLanes & ~suspendedLanes),\\n      0 !== nonIdlePendingLanes\\n        ? (nextLanes = getHighestPriorityLanes(nonIdlePendingLanes))\\n        : 0 !== pingedLanes\\n          ? (nextLanes = getHighestPriorityLanes(pingedLanes))\\n          : rootHasPendingCommit ||\\n            ((rootHasPendingCommit = pendingLanes & ~root),\\n            0 !== rootHasPendingCommit &&\\n              (nextLanes = getHighestPriorityLanes(rootHasPendingCommit))));\\n  return 0 === nextLanes\\n    ? 0\\n    : 0 !== wipLanes &&\\n        wipLanes !== nextLanes &&\\n        0 === (wipLanes & suspendedLanes) &&\\n        ((suspendedLanes = nextLanes & -nextLanes),\\n        (rootHasPendingCommit = wipLanes & -wipLanes),\\n        suspendedLanes >= rootHasPendingCommit ||\\n          (32 === suspendedLanes && 0 !== (rootHasPendingCommit & 4194048)))\\n      ? wipLanes\\n      : nextLanes;\\n}\\nfunction checkIfRootIsPrerendering(root, renderLanes) {\\n  return (\\n    0 ===\\n    (root.pendingLanes &\\n      ~(root.suspendedLanes & ~root.pingedLanes) &\\n      renderLanes)\\n  );\\n}\\nfunction computeExpirationTime(lane, currentTime) {\\n  switch (lane) {\\n    case 1:\\n    case 2:\\n    case 4:\\n    case 8:\\n    case 64:\\n      return currentTime + 250;\\n    case 16:\\n    case 32:\\n    case 128:\\n    case 256:\\n    case 512:\\n    case 1024:\\n    case 2048:\\n    case 4096:\\n    case 8192:\\n    case 16384:\\n    case 32768:\\n    case 65536:\\n    case 131072:\\n    case 262144:\\n    case 524288:\\n    case 1048576:\\n    case 2097152:\\n      return currentTime + 5e3;\\n    case 4194304:\\n    case 8388608:\\n    case 16777216:\\n    case 33554432:\\n      return -1;\\n    case 67108864:\\n    case 134217728:\\n    case 268435456:\\n    case 536870912:\\n    case 1073741824:\\n      return -1;\\n    default:\\n      return -1;\\n  }\\n}\\nfunction claimNextTransitionLane() {\\n  var lane = nextTransitionLane;\\n  nextTransitionLane <<= 1;\\n  0 === (nextTransitionLane & 4194048) && (nextTransitionLane = 256);\\n  return lane;\\n}\\nfunction claimNextRetryLane() {\\n  var lane = nextRetryLane;\\n  nextRetryLane <<= 1;\\n  0 === (nextRetryLane & 62914560) && (nextRetryLane = 4194304);\\n  return lane;\\n}\\nfunction createLaneMap(initial) {\\n  for (var laneMap = [], i = 0; 31 > i; i++) laneMap.push(initial);\\n  return laneMap;\\n}\\nfunction markRootUpdated$1(root, updateLane) {\\n  root.pendingLanes |= updateLane;\\n  268435456 !== updateLane &&\\n    ((root.suspendedLanes = 0), (root.pingedLanes = 0), (root.warmLanes = 0));\\n}\\nfunction markRootFinished(\\n  root,\\n  finishedLanes,\\n  remainingLanes,\\n  spawnedLane,\\n  updatedLanes,\\n  suspendedRetryLanes\\n) {\\n  var previouslyPendingLanes = root.pendingLanes;\\n  root.pendingLanes = remainingLanes;\\n  root.suspendedLanes = 0;\\n  root.pingedLanes = 0;\\n  root.warmLanes = 0;\\n  root.expiredLanes &= remainingLanes;\\n  root.entangledLanes &= remainingLanes;\\n  root.errorRecoveryDisabledLanes &= remainingLanes;\\n  root.shellSuspendCounter = 0;\\n  var entanglements = root.entanglements,\\n    expirationTimes = root.expirationTimes,\\n    hiddenUpdates = root.hiddenUpdates;\\n  for (\\n    remainingLanes = previouslyPendingLanes & ~remainingLanes;\\n    0 < remainingLanes;\\n\\n  ) {\\n    var index$5 = 31 - clz32(remainingLanes),\\n      lane = 1 << index$5;\\n    entanglements[index$5] = 0;\\n    expirationTimes[index$5] = -1;\\n    var hiddenUpdatesForLane = hiddenUpdates[index$5];\\n    if (null !== hiddenUpdatesForLane)\\n      for (\\n        hiddenUpdates[index$5] = null, index$5 = 0;\\n        index$5 < hiddenUpdatesForLane.length;\\n        index$5++\\n      ) {\\n        var update = hiddenUpdatesForLane[index$5];\\n        null !== update && (update.lane &= -536870913);\\n      }\\n    remainingLanes &= ~lane;\\n  }\\n  0 !== spawnedLane && markSpawnedDeferredLane(root, spawnedLane, 0);\\n  0 !== suspendedRetryLanes &&\\n    0 === updatedLanes &&\\n    0 !== root.tag &&\\n    (root.suspendedLanes |=\\n      suspendedRetryLanes & ~(previouslyPendingLanes & ~finishedLanes));\\n}\\nfunction markSpawnedDeferredLane(root, spawnedLane, entangledLanes) {\\n  root.pendingLanes |= spawnedLane;\\n  root.suspendedLanes &= ~spawnedLane;\\n  var spawnedLaneIndex = 31 - clz32(spawnedLane);\\n  root.entangledLanes |= spawnedLane;\\n  root.entanglements[spawnedLaneIndex] =\\n    root.entanglements[spawnedLaneIndex] |\\n    1073741824 |\\n    (entangledLanes & 4194090);\\n}\\nfunction markRootEntangled(root, entangledLanes) {\\n  var rootEntangledLanes = (root.entangledLanes |= entangledLanes);\\n  for (root = root.entanglements; rootEntangledLanes; ) {\\n    var index$6 = 31 - clz32(rootEntangledLanes),\\n      lane = 1 << index$6;\\n    (lane & entangledLanes) | (root[index$6] & entangledLanes) &&\\n      (root[index$6] |= entangledLanes);\\n    rootEntangledLanes &= ~lane;\\n  }\\n}\\nfunction getBumpedLaneForHydrationByLane(lane) {\\n  switch (lane) {\\n    case 2:\\n      lane = 1;\\n      break;\\n    case 8:\\n      lane = 4;\\n      break;\\n    case 32:\\n      lane = 16;\\n      break;\\n    case 256:\\n    case 512:\\n    case 1024:\\n    case 2048:\\n    case 4096:\\n    case 8192:\\n    case 16384:\\n    case 32768:\\n    case 65536:\\n    case 131072:\\n    case 262144:\\n    case 524288:\\n    case 1048576:\\n    case 2097152:\\n    case 4194304:\\n    case 8388608:\\n    case 16777216:\\n    case 33554432:\\n      lane = 128;\\n      break;\\n    case 268435456:\\n      lane = 134217728;\\n      break;\\n    default:\\n      lane = 0;\\n  }\\n  return lane;\\n}\\nfunction lanesToEventPriority(lanes) {\\n  lanes &= -lanes;\\n  return 2 < lanes\\n    ? 8 < lanes\\n      ? 0 !== (lanes & 134217727)\\n        ? 32\\n        : 268435456\\n      : 8\\n    : 2;\\n}\\nfunction resolveUpdatePriority() {\\n  var updatePriority = ReactDOMSharedInternals.p;\\n  if (0 !== updatePriority) return updatePriority;\\n  updatePriority = window.event;\\n  return void 0 === updatePriority ? 32 : getEventPriority(updatePriority.type);\\n}\\nfunction runWithPriority(priority, fn) {\\n  var previousPriority = ReactDOMSharedInternals.p;\\n  try {\\n    return (ReactDOMSharedInternals.p = priority), fn();\\n  } finally {\\n    ReactDOMSharedInternals.p = previousPriority;\\n  }\\n}\\nvar randomKey = Math.random().toString(36).slice(2),\\n  internalInstanceKey = \"__reactFiber$\" + randomKey,\\n  internalPropsKey = \"__reactProps$\" + randomKey,\\n  internalContainerInstanceKey = \"__reactContainer$\" + randomKey,\\n  internalEventHandlersKey = \"__reactEvents$\" + randomKey,\\n  internalEventHandlerListenersKey = \"__reactListeners$\" + randomKey,\\n  internalEventHandlesSetKey = \"__reactHandles$\" + randomKey,\\n  internalRootNodeResourcesKey = \"__reactResources$\" + randomKey,\\n  internalHoistableMarker = \"__reactMarker$\" + randomKey;\\nfunction detachDeletedInstance(node) {\\n  delete node[internalInstanceKey];\\n  delete node[internalPropsKey];\\n  delete node[internalEventHandlersKey];\\n  delete node[internalEventHandlerListenersKey];\\n  delete node[internalEventHandlesSetKey];\\n}\\nfunction getClosestInstanceFromNode(targetNode) {\\n  var targetInst = targetNode[internalInstanceKey];\\n  if (targetInst) return targetInst;\\n  for (var parentNode = targetNode.parentNode; parentNode; ) {\\n    if (\\n      (targetInst =\\n        parentNode[internalContainerInstanceKey] ||\\n        parentNode[internalInstanceKey])\\n    ) {\\n      parentNode = targetInst.alternate;\\n      if (\\n        null !== targetInst.child ||\\n        (null !== parentNode && null !== parentNode.child)\\n      )\\n        for (\\n          targetNode = getParentSuspenseInstance(targetNode);\\n          null !== targetNode;\\n\\n        ) {\\n          if ((parentNode = targetNode[internalInstanceKey])) return parentNode;\\n          targetNode = getParentSuspenseInstance(targetNode);\\n        }\\n      return targetInst;\\n    }\\n    targetNode = parentNode;\\n    parentNode = targetNode.parentNode;\\n  }\\n  return null;\\n}\\nfunction getInstanceFromNode(node) {\\n  if (\\n    (node = node[internalInstanceKey] || node[internalContainerInstanceKey])\\n  ) {\\n    var tag = node.tag;\\n    if (\\n      5 === tag ||\\n      6 === tag ||\\n      13 === tag ||\\n      26 === tag ||\\n      27 === tag ||\\n      3 === tag\\n    )\\n      return node;\\n  }\\n  return null;\\n}\\nfunction getNodeFromInstance(inst) {\\n  var tag = inst.tag;\\n  if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return inst.stateNode;\\n  throw Error(formatProdErrorMessage(33));\\n}\\nfunction getResourcesFromRoot(root) {\\n  var resources = root[internalRootNodeResourcesKey];\\n  resources ||\\n    (resources = root[internalRootNodeResourcesKey] =\\n      { hoistableStyles: new Map(), hoistableScripts: new Map() });\\n  return resources;\\n}\\nfunction markNodeAsHoistable(node) {\\n  node[internalHoistableMarker] = !0;\\n}\\nvar allNativeEvents = new Set(),\\n  registrationNameDependencies = {};\\nfunction registerTwoPhaseEvent(registrationName, dependencies) {\\n  registerDirectEvent(registrationName, dependencies);\\n  registerDirectEvent(registrationName + \"Capture\", dependencies);\\n}\\nfunction registerDirectEvent(registrationName, dependencies) {\\n  registrationNameDependencies[registrationName] = dependencies;\\n  for (\\n    registrationName = 0;\\n    registrationName < dependencies.length;\\n    registrationName++\\n  )\\n    allNativeEvents.add(dependencies[registrationName]);\\n}\\nvar VALID_ATTRIBUTE_NAME_REGEX = RegExp(\\n    \"^[:A-Z_a-z\\\\\\\\u00C0-\\\\\\\\u00D6\\\\\\\\u00D8-\\\\\\\\u00F6\\\\\\\\u00F8-\\\\\\\\u02FF\\\\\\\\u0370-\\\\\\\\u037D\\\\\\\\u037F-\\\\\\\\u1FFF\\\\\\\\u200C-\\\\\\\\u200D\\\\\\\\u2070-\\\\\\\\u218F\\\\\\\\u2C00-\\\\\\\\u2FEF\\\\\\\\u3001-\\\\\\\\uD7FF\\\\\\\\uF900-\\\\\\\\uFDCF\\\\\\\\uFDF0-\\\\\\\\uFFFD][:A-Z_a-z\\\\\\\\u00C0-\\\\\\\\u00D6\\\\\\\\u00D8-\\\\\\\\u00F6\\\\\\\\u00F8-\\\\\\\\u02FF\\\\\\\\u0370-\\\\\\\\u037D\\\\\\\\u037F-\\\\\\\\u1FFF\\\\\\\\u200C-\\\\\\\\u200D\\\\\\\\u2070-\\\\\\\\u218F\\\\\\\\u2C00-\\\\\\\\u2FEF\\\\\\\\u3001-\\\\\\\\uD7FF\\\\\\\\uF900-\\\\\\\\uFDCF\\\\\\\\uFDF0-\\\\\\\\uFFFD\\\\\\\\-.0-9\\\\\\\\u00B7\\\\\\\\u0300-\\\\\\\\u036F\\\\\\\\u203F-\\\\\\\\u2040]*$\"\\n  ),\\n  illegalAttributeNameCache = {},\\n  validatedAttributeNameCache = {};\\nfunction isAttributeNameSafe(attributeName) {\\n  if (hasOwnProperty.call(validatedAttributeNameCache, attributeName))\\n    return !0;\\n  if (hasOwnProperty.call(illegalAttributeNameCache, attributeName)) return !1;\\n  if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName))\\n    return (validatedAttributeNameCache[attributeName] = !0);\\n  illegalAttributeNameCache[attributeName] = !0;\\n  return !1;\\n}\\nfunction setValueForAttribute(node, name, value) {\\n  if (isAttributeNameSafe(name))\\n    if (null === value) node.removeAttribute(name);\\n    else {\\n      switch (typeof value) {\\n        case \"undefined\":\\n        case \"function\":\\n        case \"symbol\":\\n          node.removeAttribute(name);\\n          return;\\n        case \"boolean\":\\n          var prefix$8 = name.toLowerCase().slice(0, 5);\\n          if (\"data-\" !== prefix$8 && \"aria-\" !== prefix$8) {\\n            node.removeAttribute(name);\\n            return;\\n          }\\n      }\\n      node.setAttribute(name, \"\" + value);\\n    }\\n}\\nfunction setValueForKnownAttribute(node, name, value) {\\n  if (null === value) node.removeAttribute(name);\\n  else {\\n    switch (typeof value) {\\n      case \"undefined\":\\n      case \"function\":\\n      case \"symbol\":\\n      case \"boolean\":\\n        node.removeAttribute(name);\\n        return;\\n    }\\n    node.setAttribute(name, \"\" + value);\\n  }\\n}\\nfunction setValueForNamespacedAttribute(node, namespace, name, value) {\\n  if (null === value) node.removeAttribute(name);\\n  else {\\n    switch (typeof value) {\\n      case \"undefined\":\\n      case \"function\":\\n      case \"symbol\":\\n      case \"boolean\":\\n        node.removeAttribute(name);\\n        return;\\n    }\\n    node.setAttributeNS(namespace, name, \"\" + value);\\n  }\\n}\\nvar prefix, suffix;\\nfunction describeBuiltInComponentFrame(name) {\\n  if (void 0 === prefix)\\n    try {\\n      throw Error();\\n    } catch (x) {\\n      var match = x.stack.trim().match(/\\\\n( *(at )?)/);\\n      prefix = (match && match[1]) || \"\";\\n      suffix =\\n        -1 < x.stack.indexOf(\"\\\\n    at\")\\n          ? \" (<anonymous>)\"\\n          : -1 < x.stack.indexOf(\"@\")\\n            ? \"@unknown:0:0\"\\n            : \"\";\\n    }\\n  return \"\\\\n\" + prefix + name + suffix;\\n}\\nvar reentry = !1;\\nfunction describeNativeComponentFrame(fn, construct) {\\n  if (!fn || reentry) return \"\";\\n  reentry = !0;\\n  var previousPrepareStackTrace = Error.prepareStackTrace;\\n  Error.prepareStackTrace = void 0;\\n  try {\\n    var RunInRootFrame = {\\n      DetermineComponentFrameRoot: function () {\\n        try {\\n          if (construct) {\\n            var Fake = function () {\\n              throw Error();\\n            };\\n            Object.defineProperty(Fake.prototype, \"props\", {\\n              set: function () {\\n                throw Error();\\n              }\\n            });\\n            if (\"object\" === typeof Reflect && Reflect.construct) {\\n              try {\\n                Reflect.construct(Fake, []);\\n              } catch (x) {\\n                var control = x;\\n              }\\n              Reflect.construct(fn, [], Fake);\\n            } else {\\n              try {\\n                Fake.call();\\n              } catch (x$9) {\\n                control = x$9;\\n              }\\n              fn.call(Fake.prototype);\\n            }\\n          } else {\\n            try {\\n              throw Error();\\n            } catch (x$10) {\\n              control = x$10;\\n            }\\n            (Fake = fn()) &&\\n              \"function\" === typeof Fake.catch &&\\n              Fake.catch(function () {});\\n          }\\n        } catch (sample) {\\n          if (sample && control && \"string\" === typeof sample.stack)\\n            return [sample.stack, control.stack];\\n        }\\n        return [null, null];\\n      }\\n    };\\n    RunInRootFrame.DetermineComponentFrameRoot.displayName =\\n      \"DetermineComponentFrameRoot\";\\n    var namePropDescriptor = Object.getOwnPropertyDescriptor(\\n      RunInRootFrame.DetermineComponentFrameRoot,\\n      \"name\"\\n    );\\n    namePropDescriptor &&\\n      namePropDescriptor.configurable &&\\n      Object.defineProperty(\\n        RunInRootFrame.DetermineComponentFrameRoot,\\n        \"name\",\\n        { value: \"DetermineComponentFrameRoot\" }\\n      );\\n    var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(),\\n      sampleStack = _RunInRootFrame$Deter[0],\\n      controlStack = _RunInRootFrame$Deter[1];\\n    if (sampleStack && controlStack) {\\n      var sampleLines = sampleStack.split(\"\\\\n\"),\\n        controlLines = controlStack.split(\"\\\\n\");\\n      for (\\n        namePropDescriptor = RunInRootFrame = 0;\\n        RunInRootFrame < sampleLines.length &&\\n        !sampleLines[RunInRootFrame].includes(\"DetermineComponentFrameRoot\");\\n\\n      )\\n        RunInRootFrame++;\\n      for (\\n        ;\\n        namePropDescriptor < controlLines.length &&\\n        !controlLines[namePropDescriptor].includes(\\n          \"DetermineComponentFrameRoot\"\\n        );\\n\\n      )\\n        namePropDescriptor++;\\n      if (\\n        RunInRootFrame === sampleLines.length ||\\n        namePropDescriptor === controlLines.length\\n      )\\n        for (\\n          RunInRootFrame = sampleLines.length - 1,\\n            namePropDescriptor = controlLines.length - 1;\\n          1 <= RunInRootFrame &&\\n          0 <= namePropDescriptor &&\\n          sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor];\\n\\n        )\\n          namePropDescriptor--;\\n      for (\\n        ;\\n        1 <= RunInRootFrame && 0 <= namePropDescriptor;\\n        RunInRootFrame--, namePropDescriptor--\\n      )\\n        if (sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]) {\\n          if (1 !== RunInRootFrame || 1 !== namePropDescriptor) {\\n            do\\n              if (\\n                (RunInRootFrame--,\\n                namePropDescriptor--,\\n                0 > namePropDescriptor ||\\n                  sampleLines[RunInRootFrame] !==\\n                    controlLines[namePropDescriptor])\\n              ) {\\n                var frame =\\n                  \"\\\\n\" +\\n                  sampleLines[RunInRootFrame].replace(\" at new \", \" at \");\\n                fn.displayName &&\\n                  frame.includes(\"<anonymous>\") &&\\n                  (frame = frame.replace(\"<anonymous>\", fn.displayName));\\n                return frame;\\n              }\\n            while (1 <= RunInRootFrame && 0 <= namePropDescriptor);\\n          }\\n          break;\\n        }\\n    }\\n  } finally {\\n    (reentry = !1), (Error.prepareStackTrace = previousPrepareStackTrace);\\n  }\\n  return (previousPrepareStackTrace = fn ? fn.displayName || fn.name : \"\")\\n    ? describeBuiltInComponentFrame(previousPrepareStackTrace)\\n    : \"\";\\n}\\nfunction describeFiber(fiber) {\\n  switch (fiber.tag) {\\n    case 26:\\n    case 27:\\n    case 5:\\n      return describeBuiltInComponentFrame(fiber.type);\\n    case 16:\\n      return describeBuiltInComponentFrame(\"Lazy\");\\n    case 13:\\n      return describeBuiltInComponentFrame(\"Suspense\");\\n    case 19:\\n      return describeBuiltInComponentFrame(\"SuspenseList\");\\n    case 0:\\n    case 15:\\n      return describeNativeComponentFrame(fiber.type, !1);\\n    case 11:\\n      return describeNativeComponentFrame(fiber.type.render, !1);\\n    case 1:\\n      return describeNativeComponentFrame(fiber.type, !0);\\n    case 31:\\n      return describeBuiltInComponentFrame(\"Activity\");\\n    default:\\n      return \"\";\\n  }\\n}\\nfunction getStackByFiberInDevAndProd(workInProgress) {\\n  try {\\n    var info = \"\";\\n    do\\n      (info += describeFiber(workInProgress)),\\n        (workInProgress = workInProgress.return);\\n    while (workInProgress);\\n    return info;\\n  } catch (x) {\\n    return \"\\\\nError generating stack: \" + x.message + \"\\\\n\" + x.stack;\\n  }\\n}\\nfunction getToStringValue(value) {\\n  switch (typeof value) {\\n    case \"bigint\":\\n    case \"boolean\":\\n    case \"number\":\\n    case \"string\":\\n    case \"undefined\":\\n      return value;\\n    case \"object\":\\n      return value;\\n    default:\\n      return \"\";\\n  }\\n}\\nfunction isCheckable(elem) {\\n  var type = elem.type;\\n  return (\\n    (elem = elem.nodeName) &&\\n    \"input\" === elem.toLowerCase() &&\\n    (\"checkbox\" === type || \"radio\" === type)\\n  );\\n}\\nfunction trackValueOnNode(node) {\\n  var valueField = isCheckable(node) ? \"checked\" : \"value\",\\n    descriptor = Object.getOwnPropertyDescriptor(\\n      node.constructor.prototype,\\n      valueField\\n    ),\\n    currentValue = \"\" + node[valueField];\\n  if (\\n    !node.hasOwnProperty(valueField) &&\\n    \"undefined\" !== typeof descriptor &&\\n    \"function\" === typeof descriptor.get &&\\n    \"function\" === typeof descriptor.set\\n  ) {\\n    var get = descriptor.get,\\n      set = descriptor.set;\\n    Object.defineProperty(node, valueField, {\\n      configurable: !0,\\n      get: function () {\\n        return get.call(this);\\n      },\\n      set: function (value) {\\n        currentValue = \"\" + value;\\n        set.call(this, value);\\n      }\\n    });\\n    Object.defineProperty(node, valueField, {\\n      enumerable: descriptor.enumerable\\n    });\\n    return {\\n      getValue: function () {\\n        return currentValue;\\n      },\\n      setValue: function (value) {\\n        currentValue = \"\" + value;\\n      },\\n      stopTracking: function () {\\n        node._valueTracker = null;\\n        delete node[valueField];\\n      }\\n    };\\n  }\\n}\\nfunction track(node) {\\n  node._valueTracker || (node._valueTracker = trackValueOnNode(node));\\n}\\nfunction updateValueIfChanged(node) {\\n  if (!node) return !1;\\n  var tracker = node._valueTracker;\\n  if (!tracker) return !0;\\n  var lastValue = tracker.getValue();\\n  var value = \"\";\\n  node &&\\n    (value = isCheckable(node)\\n      ? node.checked\\n        ? \"true\"\\n        : \"false\"\\n      : node.value);\\n  node = value;\\n  return node !== lastValue ? (tracker.setValue(node), !0) : !1;\\n}\\nfunction getActiveElement(doc) {\\n  doc = doc || (\"undefined\" !== typeof document ? document : void 0);\\n  if (\"undefined\" === typeof doc) return null;\\n  try {\\n    return doc.activeElement || doc.body;\\n  } catch (e) {\\n    return doc.body;\\n  }\\n}\\nvar escapeSelectorAttributeValueInsideDoubleQuotesRegex = /[\\\\n\"\\\\\\\\]/g;\\nfunction escapeSelectorAttributeValueInsideDoubleQuotes(value) {\\n  return value.replace(\\n    escapeSelectorAttributeValueInsideDoubleQuotesRegex,\\n    function (ch) {\\n      return \"\\\\\\\\\" + ch.charCodeAt(0).toString(16) + \" \";\\n    }\\n  );\\n}\\nfunction updateInput(\\n  element,\\n  value,\\n  defaultValue,\\n  lastDefaultValue,\\n  checked,\\n  defaultChecked,\\n  type,\\n  name\\n) {\\n  element.name = \"\";\\n  null != type &&\\n  \"function\" !== typeof type &&\\n  \"symbol\" !== typeof type &&\\n  \"boolean\" !== typeof type\\n    ? (element.type = type)\\n    : element.removeAttribute(\"type\");\\n  if (null != value)\\n    if (\"number\" === type) {\\n      if ((0 === value && \"\" === element.value) || element.value != value)\\n        element.value = \"\" + getToStringValue(value);\\n    } else\\n      element.value !== \"\" + getToStringValue(value) &&\\n        (element.value = \"\" + getToStringValue(value));\\n  else\\n    (\"submit\" !== type && \"reset\" !== type) || element.removeAttribute(\"value\");\\n  null != value\\n    ? setDefaultValue(element, type, getToStringValue(value))\\n    : null != defaultValue\\n      ? setDefaultValue(element, type, getToStringValue(defaultValue))\\n      : null != lastDefaultValue && element.removeAttribute(\"value\");\\n  null == checked &&\\n    null != defaultChecked &&\\n    (element.defaultChecked = !!defaultChecked);\\n  null != checked &&\\n    (element.checked =\\n      checked && \"function\" !== typeof checked && \"symbol\" !== typeof checked);\\n  null != name &&\\n  \"function\" !== typeof name &&\\n  \"symbol\" !== typeof name &&\\n  \"boolean\" !== typeof name\\n    ? (element.name = \"\" + getToStringValue(name))\\n    : element.removeAttribute(\"name\");\\n}\\nfunction initInput(\\n  element,\\n  value,\\n  defaultValue,\\n  checked,\\n  defaultChecked,\\n  type,\\n  name,\\n  isHydrating\\n) {\\n  null != type &&\\n    \"function\" !== typeof type &&\\n    \"symbol\" !== typeof type &&\\n    \"boolean\" !== typeof type &&\\n    (element.type = type);\\n  if (null != value || null != defaultValue) {\\n    if (\\n      !(\\n        (\"submit\" !== type && \"reset\" !== type) ||\\n        (void 0 !== value && null !== value)\\n      )\\n    )\\n      return;\\n    defaultValue =\\n      null != defaultValue ? \"\" + getToStringValue(defaultValue) : \"\";\\n    value = null != value ? \"\" + getToStringValue(value) : defaultValue;\\n    isHydrating || value === element.value || (element.value = value);\\n    element.defaultValue = value;\\n  }\\n  checked = null != checked ? checked : defaultChecked;\\n  checked =\\n    \"function\" !== typeof checked && \"symbol\" !== typeof checked && !!checked;\\n  element.checked = isHydrating ? element.checked : !!checked;\\n  element.defaultChecked = !!checked;\\n  null != name &&\\n    \"function\" !== typeof name &&\\n    \"symbol\" !== typeof name &&\\n    \"boolean\" !== typeof name &&\\n    (element.name = name);\\n}\\nfunction setDefaultValue(node, type, value) {\\n  (\"number\" === type && getActiveElement(node.ownerDocument) === node) ||\\n    node.defaultValue === \"\" + value ||\\n    (node.defaultValue = \"\" + value);\\n}\\nfunction updateOptions(node, multiple, propValue, setDefaultSelected) {\\n  node = node.options;\\n  if (multiple) {\\n    multiple = {};\\n    for (var i = 0; i < propValue.length; i++)\\n      multiple[\"$\" + propValue[i]] = !0;\\n    for (propValue = 0; propValue < node.length; propValue++)\\n      (i = multiple.hasOwnProperty(\"$\" + node[propValue].value)),\\n        node[propValue].selected !== i && (node[propValue].selected = i),\\n        i && setDefaultSelected && (node[propValue].defaultSelected = !0);\\n  } else {\\n    propValue = \"\" + getToStringValue(propValue);\\n    multiple = null;\\n    for (i = 0; i < node.length; i++) {\\n      if (node[i].value === propValue) {\\n        node[i].selected = !0;\\n        setDefaultSelected && (node[i].defaultSelected = !0);\\n        return;\\n      }\\n      null !== multiple || node[i].disabled || (multiple = node[i]);\\n    }\\n    null !== multiple && (multiple.selected = !0);\\n  }\\n}\\nfunction updateTextarea(element, value, defaultValue) {\\n  if (\\n    null != value &&\\n    ((value = \"\" + getToStringValue(value)),\\n    value !== element.value && (element.value = value),\\n    null == defaultValue)\\n  ) {\\n    element.defaultValue !== value && (element.defaultValue = value);\\n    return;\\n  }\\n  element.defaultValue =\\n    null != defaultValue ? \"\" + getToStringValue(defaultValue) : \"\";\\n}\\nfunction initTextarea(element, value, defaultValue, children) {\\n  if (null == value) {\\n    if (null != children) {\\n      if (null != defaultValue) throw Error(formatProdErrorMessage(92));\\n      if (isArrayImpl(children)) {\\n        if (1 < children.length) throw Error(formatProdErrorMessage(93));\\n        children = children[0];\\n      }\\n      defaultValue = children;\\n    }\\n    null == defaultValue && (defaultValue = \"\");\\n    value = defaultValue;\\n  }\\n  defaultValue = getToStringValue(value);\\n  element.defaultValue = defaultValue;\\n  children = element.textContent;\\n  children === defaultValue &&\\n    \"\" !== children &&\\n    null !== children &&\\n    (element.value = children);\\n}\\nfunction setTextContent(node, text) {\\n  if (text) {\\n    var firstChild = node.firstChild;\\n    if (\\n      firstChild &&\\n      firstChild === node.lastChild &&\\n      3 === firstChild.nodeType\\n    ) {\\n      firstChild.nodeValue = text;\\n      return;\\n    }\\n  }\\n  node.textContent = text;\\n}\\nvar unitlessNumbers = new Set(\\n  \"animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp\".split(\\n    \" \"\\n  )\\n);\\nfunction setValueForStyle(style, styleName, value) {\\n  var isCustomProperty = 0 === styleName.indexOf(\"--\");\\n  null == value || \"boolean\" === typeof value || \"\" === value\\n    ? isCustomProperty\\n      ? style.setProperty(styleName, \"\")\\n      : \"float\" === styleName\\n        ? (style.cssFloat = \"\")\\n        : (style[styleName] = \"\")\\n    : isCustomProperty\\n      ? style.setProperty(styleName, value)\\n      : \"number\" !== typeof value ||\\n          0 === value ||\\n          unitlessNumbers.has(styleName)\\n        ? \"float\" === styleName\\n          ? (style.cssFloat = value)\\n          : (style[styleName] = (\"\" + value).trim())\\n        : (style[styleName] = value + \"px\");\\n}\\nfunction setValueForStyles(node, styles, prevStyles) {\\n  if (null != styles && \"object\" !== typeof styles)\\n    throw Error(formatProdErrorMessage(62));\\n  node = node.style;\\n  if (null != prevStyles) {\\n    for (var styleName in prevStyles)\\n      !prevStyles.hasOwnProperty(styleName) ||\\n        (null != styles && styles.hasOwnProperty(styleName)) ||\\n        (0 === styleName.indexOf(\"--\")\\n          ? node.setProperty(styleName, \"\")\\n          : \"float\" === styleName\\n            ? (node.cssFloat = \"\")\\n            : (node[styleName] = \"\"));\\n    for (var styleName$16 in styles)\\n      (styleName = styles[styleName$16]),\\n        styles.hasOwnProperty(styleName$16) &&\\n          prevStyles[styleName$16] !== styleName &&\\n          setValueForStyle(node, styleName$16, styleName);\\n  } else\\n    for (var styleName$17 in styles)\\n      styles.hasOwnProperty(styleName$17) &&\\n        setValueForStyle(node, styleName$17, styles[styleName$17]);\\n}\\nfunction isCustomElement(tagName) {\\n  if (-1 === tagName.indexOf(\"-\")) return !1;\\n  switch (tagName) {\\n    case \"annotation-xml\":\\n    case \"color-profile\":\\n    case \"font-face\":\\n    case \"font-face-src\":\\n    case \"font-face-uri\":\\n    case \"font-face-format\":\\n    case \"font-face-name\":\\n    case \"missing-glyph\":\\n      return !1;\\n    default:\\n      return !0;\\n  }\\n}\\nvar aliases = new Map([\\n    [\"acceptCharset\", \"accept-charset\"],\\n    [\"htmlFor\", \"for\"],\\n    [\"httpEquiv\", \"http-equiv\"],\\n    [\"crossOrigin\", \"crossorigin\"],\\n    [\"accentHeight\", \"accent-height\"],\\n    [\"alignmentBaseline\", \"alignment-baseline\"],\\n    [\"arabicForm\", \"arabic-form\"],\\n    [\"baselineShift\", \"baseline-shift\"],\\n    [\"capHeight\", \"cap-height\"],\\n    [\"clipPath\", \"clip-path\"],\\n    [\"clipRule\", \"clip-rule\"],\\n    [\"colorInterpolation\", \"color-interpolation\"],\\n    [\"colorInterpolationFilters\", \"color-interpolation-filters\"],\\n    [\"colorProfile\", \"color-profile\"],\\n    [\"colorRendering\", \"color-rendering\"],\\n    [\"dominantBaseline\", \"dominant-baseline\"],\\n    [\"enableBackground\", \"enable-background\"],\\n    [\"fillOpacity\", \"fill-opacity\"],\\n    [\"fillRule\", \"fill-rule\"],\\n    [\"floodColor\", \"flood-color\"],\\n    [\"floodOpacity\", \"flood-opacity\"],\\n    [\"fontFamily\", \"font-family\"],\\n    [\"fontSize\", \"font-size\"],\\n    [\"fontSizeAdjust\", \"font-size-adjust\"],\\n    [\"fontStretch\", \"font-stretch\"],\\n    [\"fontStyle\", \"font-style\"],\\n    [\"fontVariant\", \"font-variant\"],\\n    [\"fontWeight\", \"font-weight\"],\\n    [\"glyphName\", \"glyph-name\"],\\n    [\"glyphOrientationHorizontal\", \"glyph-orientation-horizontal\"],\\n    [\"glyphOrientationVertical\", \"glyph-orientation-vertical\"],\\n    [\"horizAdvX\", \"horiz-adv-x\"],\\n    [\"horizOriginX\", \"horiz-origin-x\"],\\n    [\"imageRendering\", \"image-rendering\"],\\n    [\"letterSpacing\", \"letter-spacing\"],\\n    [\"lightingColor\", \"lighting-color\"],\\n    [\"markerEnd\", \"marker-end\"],\\n    [\"markerMid\", \"marker-mid\"],\\n    [\"markerStart\", \"marker-start\"],\\n    [\"overlinePosition\", \"overline-position\"],\\n    [\"overlineThickness\", \"overline-thickness\"],\\n    [\"paintOrder\", \"paint-order\"],\\n    [\"panose-1\", \"panose-1\"],\\n    [\"pointerEvents\", \"pointer-events\"],\\n    [\"renderingIntent\", \"rendering-intent\"],\\n    [\"shapeRendering\", \"shape-rendering\"],\\n    [\"stopColor\", \"stop-color\"],\\n    [\"stopOpacity\", \"stop-opacity\"],\\n    [\"strikethroughPosition\", \"strikethrough-position\"],\\n    [\"strikethroughThickness\", \"strikethrough-thickness\"],\\n    [\"strokeDasharray\", \"stroke-dasharray\"],\\n    [\"strokeDashoffset\", \"stroke-dashoffset\"],\\n    [\"strokeLinecap\", \"stroke-linecap\"],\\n    [\"strokeLinejoin\", \"stroke-linejoin\"],\\n    [\"strokeMiterlimit\", \"stroke-miterlimit\"],\\n    [\"strokeOpacity\", \"stroke-opacity\"],\\n    [\"strokeWidth\", \"stroke-width\"],\\n    [\"textAnchor\", \"text-anchor\"],\\n    [\"textDecoration\", \"text-decoration\"],\\n    [\"textRendering\", \"text-rendering\"],\\n    [\"transformOrigin\", \"transform-origin\"],\\n    [\"underlinePosition\", \"underline-position\"],\\n    [\"underlineThickness\", \"underline-thickness\"],\\n    [\"unicodeBidi\", \"unicode-bidi\"],\\n    [\"unicodeRange\", \"unicode-range\"],\\n    [\"unitsPerEm\", \"units-per-em\"],\\n    [\"vAlphabetic\", \"v-alphabetic\"],\\n    [\"vHanging\", \"v-hanging\"],\\n    [\"vIdeographic\", \"v-ideographic\"],\\n    [\"vMathematical\", \"v-mathematical\"],\\n    [\"vectorEffect\", \"vector-effect\"],\\n    [\"vertAdvY\", \"vert-adv-y\"],\\n    [\"vertOriginX\", \"vert-origin-x\"],\\n    [\"vertOriginY\", \"vert-origin-y\"],\\n    [\"wordSpacing\", \"word-spacing\"],\\n    [\"writingMode\", \"writing-mode\"],\\n    [\"xmlnsXlink\", \"xmlns:xlink\"],\\n    [\"xHeight\", \"x-height\"]\\n  ]),\\n  isJavaScriptProtocol =\\n    /^[\\\\u0000-\\\\u001F ]*j[\\\\r\\\\n\\\\t]*a[\\\\r\\\\n\\\\t]*v[\\\\r\\\\n\\\\t]*a[\\\\r\\\\n\\\\t]*s[\\\\r\\\\n\\\\t]*c[\\\\r\\\\n\\\\t]*r[\\\\r\\\\n\\\\t]*i[\\\\r\\\\n\\\\t]*p[\\\\r\\\\n\\\\t]*t[\\\\r\\\\n\\\\t]*:/i;\\nfunction sanitizeURL(url) {\\n  return isJavaScriptProtocol.test(\"\" + url)\\n    ? \"javascript:throw new Error(\\'React has blocked a javascript: URL as a security precaution.\\')\"\\n    : url;\\n}\\nvar currentReplayingEvent = null;\\nfunction getEventTarget(nativeEvent) {\\n  nativeEvent = nativeEvent.target || nativeEvent.srcElement || window;\\n  nativeEvent.correspondingUseElement &&\\n    (nativeEvent = nativeEvent.correspondingUseElement);\\n  return 3 === nativeEvent.nodeType ? nativeEvent.parentNode : nativeEvent;\\n}\\nvar restoreTarget = null,\\n  restoreQueue = null;\\nfunction restoreStateOfTarget(target) {\\n  var internalInstance = getInstanceFromNode(target);\\n  if (internalInstance && (target = internalInstance.stateNode)) {\\n    var props = target[internalPropsKey] || null;\\n    a: switch (((target = internalInstance.stateNode), internalInstance.type)) {\\n      case \"input\":\\n        updateInput(\\n          target,\\n          props.value,\\n          props.defaultValue,\\n          props.defaultValue,\\n          props.checked,\\n          props.defaultChecked,\\n          props.type,\\n          props.name\\n        );\\n        internalInstance = props.name;\\n        if (\"radio\" === props.type && null != internalInstance) {\\n          for (props = target; props.parentNode; ) props = props.parentNode;\\n          props = props.querySelectorAll(\\n            \\'input[name=\"\\' +\\n              escapeSelectorAttributeValueInsideDoubleQuotes(\\n                \"\" + internalInstance\\n              ) +\\n              \\'\"][type=\"radio\"]\\'\\n          );\\n          for (\\n            internalInstance = 0;\\n            internalInstance < props.length;\\n            internalInstance++\\n          ) {\\n            var otherNode = props[internalInstance];\\n            if (otherNode !== target && otherNode.form === target.form) {\\n              var otherProps = otherNode[internalPropsKey] || null;\\n              if (!otherProps) throw Error(formatProdErrorMessage(90));\\n              updateInput(\\n                otherNode,\\n                otherProps.value,\\n                otherProps.defaultValue,\\n                otherProps.defaultValue,\\n                otherProps.checked,\\n                otherProps.defaultChecked,\\n                otherProps.type,\\n                otherProps.name\\n              );\\n            }\\n          }\\n          for (\\n            internalInstance = 0;\\n            internalInstance < props.length;\\n            internalInstance++\\n          )\\n            (otherNode = props[internalInstance]),\\n              otherNode.form === target.form && updateValueIfChanged(otherNode);\\n        }\\n        break a;\\n      case \"textarea\":\\n        updateTextarea(target, props.value, props.defaultValue);\\n        break a;\\n      case \"select\":\\n        (internalInstance = props.value),\\n          null != internalInstance &&\\n            updateOptions(target, !!props.multiple, internalInstance, !1);\\n    }\\n  }\\n}\\nvar isInsideEventHandler = !1;\\nfunction batchedUpdates$1(fn, a, b) {\\n  if (isInsideEventHandler) return fn(a, b);\\n  isInsideEventHandler = !0;\\n  try {\\n    var JSCompiler_inline_result = fn(a);\\n    return JSCompiler_inline_result;\\n  } finally {\\n    if (\\n      ((isInsideEventHandler = !1),\\n      null !== restoreTarget || null !== restoreQueue)\\n    )\\n      if (\\n        (flushSyncWork$1(),\\n        restoreTarget &&\\n          ((a = restoreTarget),\\n          (fn = restoreQueue),\\n          (restoreQueue = restoreTarget = null),\\n          restoreStateOfTarget(a),\\n          fn))\\n      )\\n        for (a = 0; a < fn.length; a++) restoreStateOfTarget(fn[a]);\\n  }\\n}\\nfunction getListener(inst, registrationName) {\\n  var stateNode = inst.stateNode;\\n  if (null === stateNode) return null;\\n  var props = stateNode[internalPropsKey] || null;\\n  if (null === props) return null;\\n  stateNode = props[registrationName];\\n  a: switch (registrationName) {\\n    case \"onClick\":\\n    case \"onClickCapture\":\\n    case \"onDoubleClick\":\\n    case \"onDoubleClickCapture\":\\n    case \"onMouseDown\":\\n    case \"onMouseDownCapture\":\\n    case \"onMouseMove\":\\n    case \"onMouseMoveCapture\":\\n    case \"onMouseUp\":\\n    case \"onMouseUpCapture\":\\n    case \"onMouseEnter\":\\n      (props = !props.disabled) ||\\n        ((inst = inst.type),\\n        (props = !(\\n          \"button\" === inst ||\\n          \"input\" === inst ||\\n          \"select\" === inst ||\\n          \"textarea\" === inst\\n        )));\\n      inst = !props;\\n      break a;\\n    default:\\n      inst = !1;\\n  }\\n  if (inst) return null;\\n  if (stateNode && \"function\" !== typeof stateNode)\\n    throw Error(\\n      formatProdErrorMessage(231, registrationName, typeof stateNode)\\n    );\\n  return stateNode;\\n}\\nvar canUseDOM = !(\\n    \"undefined\" === typeof window ||\\n    \"undefined\" === typeof window.document ||\\n    \"undefined\" === typeof window.document.createElement\\n  ),\\n  passiveBrowserEventsSupported = !1;\\nif (canUseDOM)\\n  try {\\n    var options = {};\\n    Object.defineProperty(options, \"passive\", {\\n      get: function () {\\n        passiveBrowserEventsSupported = !0;\\n      }\\n    });\\n    window.addEventListener(\"test\", options, options);\\n    window.removeEventListener(\"test\", options, options);\\n  } catch (e) {\\n    passiveBrowserEventsSupported = !1;\\n  }\\nvar root = null,\\n  startText = null,\\n  fallbackText = null;\\nfunction getData() {\\n  if (fallbackText) return fallbackText;\\n  var start,\\n    startValue = startText,\\n    startLength = startValue.length,\\n    end,\\n    endValue = \"value\" in root ? root.value : root.textContent,\\n    endLength = endValue.length;\\n  for (\\n    start = 0;\\n    start < startLength && startValue[start] === endValue[start];\\n    start++\\n  );\\n  var minEnd = startLength - start;\\n  for (\\n    end = 1;\\n    end <= minEnd &&\\n    startValue[startLength - end] === endValue[endLength - end];\\n    end++\\n  );\\n  return (fallbackText = endValue.slice(start, 1 < end ? 1 - end : void 0));\\n}\\nfunction getEventCharCode(nativeEvent) {\\n  var keyCode = nativeEvent.keyCode;\\n  \"charCode\" in nativeEvent\\n    ? ((nativeEvent = nativeEvent.charCode),\\n      0 === nativeEvent && 13 === keyCode && (nativeEvent = 13))\\n    : (nativeEvent = keyCode);\\n  10 === nativeEvent && (nativeEvent = 13);\\n  return 32 <= nativeEvent || 13 === nativeEvent ? nativeEvent : 0;\\n}\\nfunction functionThatReturnsTrue() {\\n  return !0;\\n}\\nfunction functionThatReturnsFalse() {\\n  return !1;\\n}\\nfunction createSyntheticEvent(Interface) {\\n  function SyntheticBaseEvent(\\n    reactName,\\n    reactEventType,\\n    targetInst,\\n    nativeEvent,\\n    nativeEventTarget\\n  ) {\\n    this._reactName = reactName;\\n    this._targetInst = targetInst;\\n    this.type = reactEventType;\\n    this.nativeEvent = nativeEvent;\\n    this.target = nativeEventTarget;\\n    this.currentTarget = null;\\n    for (var propName in Interface)\\n      Interface.hasOwnProperty(propName) &&\\n        ((reactName = Interface[propName]),\\n        (this[propName] = reactName\\n          ? reactName(nativeEvent)\\n          : nativeEvent[propName]));\\n    this.isDefaultPrevented = (\\n      null != nativeEvent.defaultPrevented\\n        ? nativeEvent.defaultPrevented\\n        : !1 === nativeEvent.returnValue\\n    )\\n      ? functionThatReturnsTrue\\n      : functionThatReturnsFalse;\\n    this.isPropagationStopped = functionThatReturnsFalse;\\n    return this;\\n  }\\n  assign(SyntheticBaseEvent.prototype, {\\n    preventDefault: function () {\\n      this.defaultPrevented = !0;\\n      var event = this.nativeEvent;\\n      event &&\\n        (event.preventDefault\\n          ? event.preventDefault()\\n          : \"unknown\" !== typeof event.returnValue && (event.returnValue = !1),\\n        (this.isDefaultPrevented = functionThatReturnsTrue));\\n    },\\n    stopPropagation: function () {\\n      var event = this.nativeEvent;\\n      event &&\\n        (event.stopPropagation\\n          ? event.stopPropagation()\\n          : \"unknown\" !== typeof event.cancelBubble &&\\n            (event.cancelBubble = !0),\\n        (this.isPropagationStopped = functionThatReturnsTrue));\\n    },\\n    persist: function () {},\\n    isPersistent: functionThatReturnsTrue\\n  });\\n  return SyntheticBaseEvent;\\n}\\nvar EventInterface = {\\n    eventPhase: 0,\\n    bubbles: 0,\\n    cancelable: 0,\\n    timeStamp: function (event) {\\n      return event.timeStamp || Date.now();\\n    },\\n    defaultPrevented: 0,\\n    isTrusted: 0\\n  },\\n  SyntheticEvent = createSyntheticEvent(EventInterface),\\n  UIEventInterface = assign({}, EventInterface, { view: 0, detail: 0 }),\\n  SyntheticUIEvent = createSyntheticEvent(UIEventInterface),\\n  lastMovementX,\\n  lastMovementY,\\n  lastMouseEvent,\\n  MouseEventInterface = assign({}, UIEventInterface, {\\n    screenX: 0,\\n    screenY: 0,\\n    clientX: 0,\\n    clientY: 0,\\n    pageX: 0,\\n    pageY: 0,\\n    ctrlKey: 0,\\n    shiftKey: 0,\\n    altKey: 0,\\n    metaKey: 0,\\n    getModifierState: getEventModifierState,\\n    button: 0,\\n    buttons: 0,\\n    relatedTarget: function (event) {\\n      return void 0 === event.relatedTarget\\n        ? event.fromElement === event.srcElement\\n          ? event.toElement\\n          : event.fromElement\\n        : event.relatedTarget;\\n    },\\n    movementX: function (event) {\\n      if (\"movementX\" in event) return event.movementX;\\n      event !== lastMouseEvent &&\\n        (lastMouseEvent && \"mousemove\" === event.type\\n          ? ((lastMovementX = event.screenX - lastMouseEvent.screenX),\\n            (lastMovementY = event.screenY - lastMouseEvent.screenY))\\n          : (lastMovementY = lastMovementX = 0),\\n        (lastMouseEvent = event));\\n      return lastMovementX;\\n    },\\n    movementY: function (event) {\\n      return \"movementY\" in event ? event.movementY : lastMovementY;\\n    }\\n  }),\\n  SyntheticMouseEvent = createSyntheticEvent(MouseEventInterface),\\n  DragEventInterface = assign({}, MouseEventInterface, { dataTransfer: 0 }),\\n  SyntheticDragEvent = createSyntheticEvent(DragEventInterface),\\n  FocusEventInterface = assign({}, UIEventInterface, { relatedTarget: 0 }),\\n  SyntheticFocusEvent = createSyntheticEvent(FocusEventInterface),\\n  AnimationEventInterface = assign({}, EventInterface, {\\n    animationName: 0,\\n    elapsedTime: 0,\\n    pseudoElement: 0\\n  }),\\n  SyntheticAnimationEvent = createSyntheticEvent(AnimationEventInterface),\\n  ClipboardEventInterface = assign({}, EventInterface, {\\n    clipboardData: function (event) {\\n      return \"clipboardData\" in event\\n        ? event.clipboardData\\n        : window.clipboardData;\\n    }\\n  }),\\n  SyntheticClipboardEvent = createSyntheticEvent(ClipboardEventInterface),\\n  CompositionEventInterface = assign({}, EventInterface, { data: 0 }),\\n  SyntheticCompositionEvent = createSyntheticEvent(CompositionEventInterface),\\n  normalizeKey = {\\n    Esc: \"Escape\",\\n    Spacebar: \" \",\\n    Left: \"ArrowLeft\",\\n    Up: \"ArrowUp\",\\n    Right: \"ArrowRight\",\\n    Down: \"ArrowDown\",\\n    Del: \"Delete\",\\n    Win: \"OS\",\\n    Menu: \"ContextMenu\",\\n    Apps: \"ContextMenu\",\\n    Scroll: \"ScrollLock\",\\n    MozPrintableKey: \"Unidentified\"\\n  },\\n  translateToKey = {\\n    8: \"Backspace\",\\n    9: \"Tab\",\\n    12: \"Clear\",\\n    13: \"Enter\",\\n    16: \"Shift\",\\n    17: \"Control\",\\n    18: \"Alt\",\\n    19: \"Pause\",\\n    20: \"CapsLock\",\\n    27: \"Escape\",\\n    32: \" \",\\n    33: \"PageUp\",\\n    34: \"PageDown\",\\n    35: \"End\",\\n    36: \"Home\",\\n    37: \"ArrowLeft\",\\n    38: \"ArrowUp\",\\n    39: \"ArrowRight\",\\n    40: \"ArrowDown\",\\n    45: \"Insert\",\\n    46: \"Delete\",\\n    112: \"F1\",\\n    113: \"F2\",\\n    114: \"F3\",\\n    115: \"F4\",\\n    116: \"F5\",\\n    117: \"F6\",\\n    118: \"F7\",\\n    119: \"F8\",\\n    120: \"F9\",\\n    121: \"F10\",\\n    122: \"F11\",\\n    123: \"F12\",\\n    144: \"NumLock\",\\n    145: \"ScrollLock\",\\n    224: \"Meta\"\\n  },\\n  modifierKeyToProp = {\\n    Alt: \"altKey\",\\n    Control: \"ctrlKey\",\\n    Meta: \"metaKey\",\\n    Shift: \"shiftKey\"\\n  };\\nfunction modifierStateGetter(keyArg) {\\n  var nativeEvent = this.nativeEvent;\\n  return nativeEvent.getModifierState\\n    ? nativeEvent.getModifierState(keyArg)\\n    : (keyArg = modifierKeyToProp[keyArg])\\n      ? !!nativeEvent[keyArg]\\n      : !1;\\n}\\nfunction getEventModifierState() {\\n  return modifierStateGetter;\\n}\\nvar KeyboardEventInterface = assign({}, UIEventInterface, {\\n    key: function (nativeEvent) {\\n      if (nativeEvent.key) {\\n        var key = normalizeKey[nativeEvent.key] || nativeEvent.key;\\n        if (\"Unidentified\" !== key) return key;\\n      }\\n      return \"keypress\" === nativeEvent.type\\n        ? ((nativeEvent = getEventCharCode(nativeEvent)),\\n          13 === nativeEvent ? \"Enter\" : String.fromCharCode(nativeEvent))\\n        : \"keydown\" === nativeEvent.type || \"keyup\" === nativeEvent.type\\n          ? translateToKey[nativeEvent.keyCode] || \"Unidentified\"\\n          : \"\";\\n    },\\n    code: 0,\\n    location: 0,\\n    ctrlKey: 0,\\n    shiftKey: 0,\\n    altKey: 0,\\n    metaKey: 0,\\n    repeat: 0,\\n    locale: 0,\\n    getModifierState: getEventModifierState,\\n    charCode: function (event) {\\n      return \"keypress\" === event.type ? getEventCharCode(event) : 0;\\n    },\\n    keyCode: function (event) {\\n      return \"keydown\" === event.type || \"keyup\" === event.type\\n        ? event.keyCode\\n        : 0;\\n    },\\n    which: function (event) {\\n      return \"keypress\" === event.type\\n        ? getEventCharCode(event)\\n        : \"keydown\" === event.type || \"keyup\" === event.type\\n          ? event.keyCode\\n          : 0;\\n    }\\n  }),\\n  SyntheticKeyboardEvent = createSyntheticEvent(KeyboardEventInterface),\\n  PointerEventInterface = assign({}, MouseEventInterface, {\\n    pointerId: 0,\\n    width: 0,\\n    height: 0,\\n    pressure: 0,\\n    tangentialPressure: 0,\\n    tiltX: 0,\\n    tiltY: 0,\\n    twist: 0,\\n    pointerType: 0,\\n    isPrimary: 0\\n  }),\\n  SyntheticPointerEvent = createSyntheticEvent(PointerEventInterface),\\n  TouchEventInterface = assign({}, UIEventInterface, {\\n    touches: 0,\\n    targetTouches: 0,\\n    changedTouches: 0,\\n    altKey: 0,\\n    metaKey: 0,\\n    ctrlKey: 0,\\n    shiftKey: 0,\\n    getModifierState: getEventModifierState\\n  }),\\n  SyntheticTouchEvent = createSyntheticEvent(TouchEventInterface),\\n  TransitionEventInterface = assign({}, EventInterface, {\\n    propertyName: 0,\\n    elapsedTime: 0,\\n    pseudoElement: 0\\n  }),\\n  SyntheticTransitionEvent = createSyntheticEvent(TransitionEventInterface),\\n  WheelEventInterface = assign({}, MouseEventInterface, {\\n    deltaX: function (event) {\\n      return \"deltaX\" in event\\n        ? event.deltaX\\n        : \"wheelDeltaX\" in event\\n          ? -event.wheelDeltaX\\n          : 0;\\n    },\\n    deltaY: function (event) {\\n      return \"deltaY\" in event\\n        ? event.deltaY\\n        : \"wheelDeltaY\" in event\\n          ? -event.wheelDeltaY\\n          : \"wheelDelta\" in event\\n            ? -event.wheelDelta\\n            : 0;\\n    },\\n    deltaZ: 0,\\n    deltaMode: 0\\n  }),\\n  SyntheticWheelEvent = createSyntheticEvent(WheelEventInterface),\\n  ToggleEventInterface = assign({}, EventInterface, {\\n    newState: 0,\\n    oldState: 0\\n  }),\\n  SyntheticToggleEvent = createSyntheticEvent(ToggleEventInterface),\\n  END_KEYCODES = [9, 13, 27, 32],\\n  canUseCompositionEvent = canUseDOM && \"CompositionEvent\" in window,\\n  documentMode = null;\\ncanUseDOM &&\\n  \"documentMode\" in document &&\\n  (documentMode = document.documentMode);\\nvar canUseTextInputEvent = canUseDOM && \"TextEvent\" in window && !documentMode,\\n  useFallbackCompositionData =\\n    canUseDOM &&\\n    (!canUseCompositionEvent ||\\n      (documentMode && 8 < documentMode && 11 >= documentMode)),\\n  SPACEBAR_CHAR = String.fromCharCode(32),\\n  hasSpaceKeypress = !1;\\nfunction isFallbackCompositionEnd(domEventName, nativeEvent) {\\n  switch (domEventName) {\\n    case \"keyup\":\\n      return -1 !== END_KEYCODES.indexOf(nativeEvent.keyCode);\\n    case \"keydown\":\\n      return 229 !== nativeEvent.keyCode;\\n    case \"keypress\":\\n    case \"mousedown\":\\n    case \"focusout\":\\n      return !0;\\n    default:\\n      return !1;\\n  }\\n}\\nfunction getDataFromCustomEvent(nativeEvent) {\\n  nativeEvent = nativeEvent.detail;\\n  return \"object\" === typeof nativeEvent && \"data\" in nativeEvent\\n    ? nativeEvent.data\\n    : null;\\n}\\nvar isComposing = !1;\\nfunction getNativeBeforeInputChars(domEventName, nativeEvent) {\\n  switch (domEventName) {\\n    case \"compositionend\":\\n      return getDataFromCustomEvent(nativeEvent);\\n    case \"keypress\":\\n      if (32 !== nativeEvent.which) return null;\\n      hasSpaceKeypress = !0;\\n      return SPACEBAR_CHAR;\\n    case \"textInput\":\\n      return (\\n        (domEventName = nativeEvent.data),\\n        domEventName === SPACEBAR_CHAR && hasSpaceKeypress ? null : domEventName\\n      );\\n    default:\\n      return null;\\n  }\\n}\\nfunction getFallbackBeforeInputChars(domEventName, nativeEvent) {\\n  if (isComposing)\\n    return \"compositionend\" === domEventName ||\\n      (!canUseCompositionEvent &&\\n        isFallbackCompositionEnd(domEventName, nativeEvent))\\n      ? ((domEventName = getData()),\\n        (fallbackText = startText = root = null),\\n        (isComposing = !1),\\n        domEventName)\\n      : null;\\n  switch (domEventName) {\\n    case \"paste\":\\n      return null;\\n    case \"keypress\":\\n      if (\\n        !(nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) ||\\n        (nativeEvent.ctrlKey && nativeEvent.altKey)\\n      ) {\\n        if (nativeEvent.char && 1 < nativeEvent.char.length)\\n          return nativeEvent.char;\\n        if (nativeEvent.which) return String.fromCharCode(nativeEvent.which);\\n      }\\n      return null;\\n    case \"compositionend\":\\n      return useFallbackCompositionData && \"ko\" !== nativeEvent.locale\\n        ? null\\n        : nativeEvent.data;\\n    default:\\n      return null;\\n  }\\n}\\nvar supportedInputTypes = {\\n  color: !0,\\n  date: !0,\\n  datetime: !0,\\n  \"datetime-local\": !0,\\n  email: !0,\\n  month: !0,\\n  number: !0,\\n  password: !0,\\n  range: !0,\\n  search: !0,\\n  tel: !0,\\n  text: !0,\\n  time: !0,\\n  url: !0,\\n  week: !0\\n};\\nfunction isTextInputElement(elem) {\\n  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();\\n  return \"input\" === nodeName\\n    ? !!supportedInputTypes[elem.type]\\n    : \"textarea\" === nodeName\\n      ? !0\\n      : !1;\\n}\\nfunction createAndAccumulateChangeEvent(\\n  dispatchQueue,\\n  inst,\\n  nativeEvent,\\n  target\\n) {\\n  restoreTarget\\n    ? restoreQueue\\n      ? restoreQueue.push(target)\\n      : (restoreQueue = [target])\\n    : (restoreTarget = target);\\n  inst = accumulateTwoPhaseListeners(inst, \"onChange\");\\n  0 < inst.length &&\\n    ((nativeEvent = new SyntheticEvent(\\n      \"onChange\",\\n      \"change\",\\n      null,\\n      nativeEvent,\\n      target\\n    )),\\n    dispatchQueue.push({ event: nativeEvent, listeners: inst }));\\n}\\nvar activeElement$1 = null,\\n  activeElementInst$1 = null;\\nfunction runEventInBatch(dispatchQueue) {\\n  processDispatchQueue(dispatchQueue, 0);\\n}\\nfunction getInstIfValueChanged(targetInst) {\\n  var targetNode = getNodeFromInstance(targetInst);\\n  if (updateValueIfChanged(targetNode)) return targetInst;\\n}\\nfunction getTargetInstForChangeEvent(domEventName, targetInst) {\\n  if (\"change\" === domEventName) return targetInst;\\n}\\nvar isInputEventSupported = !1;\\nif (canUseDOM) {\\n  var JSCompiler_inline_result$jscomp$282;\\n  if (canUseDOM) {\\n    var isSupported$jscomp$inline_417 = \"oninput\" in document;\\n    if (!isSupported$jscomp$inline_417) {\\n      var element$jscomp$inline_418 = document.createElement(\"div\");\\n      element$jscomp$inline_418.setAttribute(\"oninput\", \"return;\");\\n      isSupported$jscomp$inline_417 =\\n        \"function\" === typeof element$jscomp$inline_418.oninput;\\n    }\\n    JSCompiler_inline_result$jscomp$282 = isSupported$jscomp$inline_417;\\n  } else JSCompiler_inline_result$jscomp$282 = !1;\\n  isInputEventSupported =\\n    JSCompiler_inline_result$jscomp$282 &&\\n    (!document.documentMode || 9 < document.documentMode);\\n}\\nfunction stopWatchingForValueChange() {\\n  activeElement$1 &&\\n    (activeElement$1.detachEvent(\"onpropertychange\", handlePropertyChange),\\n    (activeElementInst$1 = activeElement$1 = null));\\n}\\nfunction handlePropertyChange(nativeEvent) {\\n  if (\\n    \"value\" === nativeEvent.propertyName &&\\n    getInstIfValueChanged(activeElementInst$1)\\n  ) {\\n    var dispatchQueue = [];\\n    createAndAccumulateChangeEvent(\\n      dispatchQueue,\\n      activeElementInst$1,\\n      nativeEvent,\\n      getEventTarget(nativeEvent)\\n    );\\n    batchedUpdates$1(runEventInBatch, dispatchQueue);\\n  }\\n}\\nfunction handleEventsForInputEventPolyfill(domEventName, target, targetInst) {\\n  \"focusin\" === domEventName\\n    ? (stopWatchingForValueChange(),\\n      (activeElement$1 = target),\\n      (activeElementInst$1 = targetInst),\\n      activeElement$1.attachEvent(\"onpropertychange\", handlePropertyChange))\\n    : \"focusout\" === domEventName && stopWatchingForValueChange();\\n}\\nfunction getTargetInstForInputEventPolyfill(domEventName) {\\n  if (\\n    \"selectionchange\" === domEventName ||\\n    \"keyup\" === domEventName ||\\n    \"keydown\" === domEventName\\n  )\\n    return getInstIfValueChanged(activeElementInst$1);\\n}\\nfunction getTargetInstForClickEvent(domEventName, targetInst) {\\n  if (\"click\" === domEventName) return getInstIfValueChanged(targetInst);\\n}\\nfunction getTargetInstForInputOrChangeEvent(domEventName, targetInst) {\\n  if (\"input\" === domEventName || \"change\" === domEventName)\\n    return getInstIfValueChanged(targetInst);\\n}\\nfunction is(x, y) {\\n  return (x === y && (0 !== x || 1 / x === 1 / y)) || (x !== x && y !== y);\\n}\\nvar objectIs = \"function\" === typeof Object.is ? Object.is : is;\\nfunction shallowEqual(objA, objB) {\\n  if (objectIs(objA, objB)) return !0;\\n  if (\\n    \"object\" !== typeof objA ||\\n    null === objA ||\\n    \"object\" !== typeof objB ||\\n    null === objB\\n  )\\n    return !1;\\n  var keysA = Object.keys(objA),\\n    keysB = Object.keys(objB);\\n  if (keysA.length !== keysB.length) return !1;\\n  for (keysB = 0; keysB < keysA.length; keysB++) {\\n    var currentKey = keysA[keysB];\\n    if (\\n      !hasOwnProperty.call(objB, currentKey) ||\\n      !objectIs(objA[currentKey], objB[currentKey])\\n    )\\n      return !1;\\n  }\\n  return !0;\\n}\\nfunction getLeafNode(node) {\\n  for (; node && node.firstChild; ) node = node.firstChild;\\n  return node;\\n}\\nfunction getNodeForCharacterOffset(root, offset) {\\n  var node = getLeafNode(root);\\n  root = 0;\\n  for (var nodeEnd; node; ) {\\n    if (3 === node.nodeType) {\\n      nodeEnd = root + node.textContent.length;\\n      if (root <= offset && nodeEnd >= offset)\\n        return { node: node, offset: offset - root };\\n      root = nodeEnd;\\n    }\\n    a: {\\n      for (; node; ) {\\n        if (node.nextSibling) {\\n          node = node.nextSibling;\\n          break a;\\n        }\\n        node = node.parentNode;\\n      }\\n      node = void 0;\\n    }\\n    node = getLeafNode(node);\\n  }\\n}\\nfunction containsNode(outerNode, innerNode) {\\n  return outerNode && innerNode\\n    ? outerNode === innerNode\\n      ? !0\\n      : outerNode && 3 === outerNode.nodeType\\n        ? !1\\n        : innerNode && 3 === innerNode.nodeType\\n          ? containsNode(outerNode, innerNode.parentNode)\\n          : \"contains\" in outerNode\\n            ? outerNode.contains(innerNode)\\n            : outerNode.compareDocumentPosition\\n              ? !!(outerNode.compareDocumentPosition(innerNode) & 16)\\n              : !1\\n    : !1;\\n}\\nfunction getActiveElementDeep(containerInfo) {\\n  containerInfo =\\n    null != containerInfo &&\\n    null != containerInfo.ownerDocument &&\\n    null != containerInfo.ownerDocument.defaultView\\n      ? containerInfo.ownerDocument.defaultView\\n      : window;\\n  for (\\n    var element = getActiveElement(containerInfo.document);\\n    element instanceof containerInfo.HTMLIFrameElement;\\n\\n  ) {\\n    try {\\n      var JSCompiler_inline_result =\\n        \"string\" === typeof element.contentWindow.location.href;\\n    } catch (err) {\\n      JSCompiler_inline_result = !1;\\n    }\\n    if (JSCompiler_inline_result) containerInfo = element.contentWindow;\\n    else break;\\n    element = getActiveElement(containerInfo.document);\\n  }\\n  return element;\\n}\\nfunction hasSelectionCapabilities(elem) {\\n  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();\\n  return (\\n    nodeName &&\\n    ((\"input\" === nodeName &&\\n      (\"text\" === elem.type ||\\n        \"search\" === elem.type ||\\n        \"tel\" === elem.type ||\\n        \"url\" === elem.type ||\\n        \"password\" === elem.type)) ||\\n      \"textarea\" === nodeName ||\\n      \"true\" === elem.contentEditable)\\n  );\\n}\\nvar skipSelectionChangeEvent =\\n    canUseDOM && \"documentMode\" in document && 11 >= document.documentMode,\\n  activeElement = null,\\n  activeElementInst = null,\\n  lastSelection = null,\\n  mouseDown = !1;\\nfunction constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget) {\\n  var doc =\\n    nativeEventTarget.window === nativeEventTarget\\n      ? nativeEventTarget.document\\n      : 9 === nativeEventTarget.nodeType\\n        ? nativeEventTarget\\n        : nativeEventTarget.ownerDocument;\\n  mouseDown ||\\n    null == activeElement ||\\n    activeElement !== getActiveElement(doc) ||\\n    ((doc = activeElement),\\n    \"selectionStart\" in doc && hasSelectionCapabilities(doc)\\n      ? (doc = { start: doc.selectionStart, end: doc.selectionEnd })\\n      : ((doc = (\\n          (doc.ownerDocument && doc.ownerDocument.defaultView) ||\\n          window\\n        ).getSelection()),\\n        (doc = {\\n          anchorNode: doc.anchorNode,\\n          anchorOffset: doc.anchorOffset,\\n          focusNode: doc.focusNode,\\n          focusOffset: doc.focusOffset\\n        })),\\n    (lastSelection && shallowEqual(lastSelection, doc)) ||\\n      ((lastSelection = doc),\\n      (doc = accumulateTwoPhaseListeners(activeElementInst, \"onSelect\")),\\n      0 < doc.length &&\\n        ((nativeEvent = new SyntheticEvent(\\n          \"onSelect\",\\n          \"select\",\\n          null,\\n          nativeEvent,\\n          nativeEventTarget\\n        )),\\n        dispatchQueue.push({ event: nativeEvent, listeners: doc }),\\n        (nativeEvent.target = activeElement))));\\n}\\nfunction makePrefixMap(styleProp, eventName) {\\n  var prefixes = {};\\n  prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();\\n  prefixes[\"Webkit\" + styleProp] = \"webkit\" + eventName;\\n  prefixes[\"Moz\" + styleProp] = \"moz\" + eventName;\\n  return prefixes;\\n}\\nvar vendorPrefixes = {\\n    animationend: makePrefixMap(\"Animation\", \"AnimationEnd\"),\\n    animationiteration: makePrefixMap(\"Animation\", \"AnimationIteration\"),\\n    animationstart: makePrefixMap(\"Animation\", \"AnimationStart\"),\\n    transitionrun: makePrefixMap(\"Transition\", \"TransitionRun\"),\\n    transitionstart: makePrefixMap(\"Transition\", \"TransitionStart\"),\\n    transitioncancel: makePrefixMap(\"Transition\", \"TransitionCancel\"),\\n    transitionend: makePrefixMap(\"Transition\", \"TransitionEnd\")\\n  },\\n  prefixedEventNames = {},\\n  style = {};\\ncanUseDOM &&\\n  ((style = document.createElement(\"div\").style),\\n  \"AnimationEvent\" in window ||\\n    (delete vendorPrefixes.animationend.animation,\\n    delete vendorPrefixes.animationiteration.animation,\\n    delete vendorPrefixes.animationstart.animation),\\n  \"TransitionEvent\" in window ||\\n    delete vendorPrefixes.transitionend.transition);\\nfunction getVendorPrefixedEventName(eventName) {\\n  if (prefixedEventNames[eventName]) return prefixedEventNames[eventName];\\n  if (!vendorPrefixes[eventName]) return eventName;\\n  var prefixMap = vendorPrefixes[eventName],\\n    styleProp;\\n  for (styleProp in prefixMap)\\n    if (prefixMap.hasOwnProperty(styleProp) && styleProp in style)\\n      return (prefixedEventNames[eventName] = prefixMap[styleProp]);\\n  return eventName;\\n}\\nvar ANIMATION_END = getVendorPrefixedEventName(\"animationend\"),\\n  ANIMATION_ITERATION = getVendorPrefixedEventName(\"animationiteration\"),\\n  ANIMATION_START = getVendorPrefixedEventName(\"animationstart\"),\\n  TRANSITION_RUN = getVendorPrefixedEventName(\"transitionrun\"),\\n  TRANSITION_START = getVendorPrefixedEventName(\"transitionstart\"),\\n  TRANSITION_CANCEL = getVendorPrefixedEventName(\"transitioncancel\"),\\n  TRANSITION_END = getVendorPrefixedEventName(\"transitionend\"),\\n  topLevelEventsToReactNames = new Map(),\\n  simpleEventPluginEvents =\\n    \"abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel\".split(\\n      \" \"\\n    );\\nsimpleEventPluginEvents.push(\"scrollEnd\");\\nfunction registerSimpleEvent(domEventName, reactName) {\\n  topLevelEventsToReactNames.set(domEventName, reactName);\\n  registerTwoPhaseEvent(reactName, [domEventName]);\\n}\\nvar CapturedStacks = new WeakMap();\\nfunction createCapturedValueAtFiber(value, source) {\\n  if (\"object\" === typeof value && null !== value) {\\n    var existing = CapturedStacks.get(value);\\n    if (void 0 !== existing) return existing;\\n    source = {\\n      value: value,\\n      source: source,\\n      stack: getStackByFiberInDevAndProd(source)\\n    };\\n    CapturedStacks.set(value, source);\\n    return source;\\n  }\\n  return {\\n    value: value,\\n    source: source,\\n    stack: getStackByFiberInDevAndProd(source)\\n  };\\n}\\nvar concurrentQueues = [],\\n  concurrentQueuesIndex = 0,\\n  concurrentlyUpdatedLanes = 0;\\nfunction finishQueueingConcurrentUpdates() {\\n  for (\\n    var endIndex = concurrentQueuesIndex,\\n      i = (concurrentlyUpdatedLanes = concurrentQueuesIndex = 0);\\n    i < endIndex;\\n\\n  ) {\\n    var fiber = concurrentQueues[i];\\n    concurrentQueues[i++] = null;\\n    var queue = concurrentQueues[i];\\n    concurrentQueues[i++] = null;\\n    var update = concurrentQueues[i];\\n    concurrentQueues[i++] = null;\\n    var lane = concurrentQueues[i];\\n    concurrentQueues[i++] = null;\\n    if (null !== queue && null !== update) {\\n      var pending = queue.pending;\\n      null === pending\\n        ? (update.next = update)\\n        : ((update.next = pending.next), (pending.next = update));\\n      queue.pending = update;\\n    }\\n    0 !== lane && markUpdateLaneFromFiberToRoot(fiber, update, lane);\\n  }\\n}\\nfunction enqueueUpdate$1(fiber, queue, update, lane) {\\n  concurrentQueues[concurrentQueuesIndex++] = fiber;\\n  concurrentQueues[concurrentQueuesIndex++] = queue;\\n  concurrentQueues[concurrentQueuesIndex++] = update;\\n  concurrentQueues[concurrentQueuesIndex++] = lane;\\n  concurrentlyUpdatedLanes |= lane;\\n  fiber.lanes |= lane;\\n  fiber = fiber.alternate;\\n  null !== fiber && (fiber.lanes |= lane);\\n}\\nfunction enqueueConcurrentHookUpdate(fiber, queue, update, lane) {\\n  enqueueUpdate$1(fiber, queue, update, lane);\\n  return getRootForUpdatedFiber(fiber);\\n}\\nfunction enqueueConcurrentRenderForLane(fiber, lane) {\\n  enqueueUpdate$1(fiber, null, null, lane);\\n  return getRootForUpdatedFiber(fiber);\\n}\\nfunction markUpdateLaneFromFiberToRoot(sourceFiber, update, lane) {\\n  sourceFiber.lanes |= lane;\\n  var alternate = sourceFiber.alternate;\\n  null !== alternate && (alternate.lanes |= lane);\\n  for (var isHidden = !1, parent = sourceFiber.return; null !== parent; )\\n    (parent.childLanes |= lane),\\n      (alternate = parent.alternate),\\n      null !== alternate && (alternate.childLanes |= lane),\\n      22 === parent.tag &&\\n        ((sourceFiber = parent.stateNode),\\n        null === sourceFiber || sourceFiber._visibility & 1 || (isHidden = !0)),\\n      (sourceFiber = parent),\\n      (parent = parent.return);\\n  return 3 === sourceFiber.tag\\n    ? ((parent = sourceFiber.stateNode),\\n      isHidden &&\\n        null !== update &&\\n        ((isHidden = 31 - clz32(lane)),\\n        (sourceFiber = parent.hiddenUpdates),\\n        (alternate = sourceFiber[isHidden]),\\n        null === alternate\\n          ? (sourceFiber[isHidden] = [update])\\n          : alternate.push(update),\\n        (update.lane = lane | 536870912)),\\n      parent)\\n    : null;\\n}\\nfunction getRootForUpdatedFiber(sourceFiber) {\\n  if (50 < nestedUpdateCount)\\n    throw (\\n      ((nestedUpdateCount = 0),\\n      (rootWithNestedUpdates = null),\\n      Error(formatProdErrorMessage(185)))\\n    );\\n  for (var parent = sourceFiber.return; null !== parent; )\\n    (sourceFiber = parent), (parent = sourceFiber.return);\\n  return 3 === sourceFiber.tag ? sourceFiber.stateNode : null;\\n}\\nvar emptyContextObject = {};\\nfunction FiberNode(tag, pendingProps, key, mode) {\\n  this.tag = tag;\\n  this.key = key;\\n  this.sibling =\\n    this.child =\\n    this.return =\\n    this.stateNode =\\n    this.type =\\n    this.elementType =\\n      null;\\n  this.index = 0;\\n  this.refCleanup = this.ref = null;\\n  this.pendingProps = pendingProps;\\n  this.dependencies =\\n    this.memoizedState =\\n    this.updateQueue =\\n    this.memoizedProps =\\n      null;\\n  this.mode = mode;\\n  this.subtreeFlags = this.flags = 0;\\n  this.deletions = null;\\n  this.childLanes = this.lanes = 0;\\n  this.alternate = null;\\n}\\nfunction createFiberImplClass(tag, pendingProps, key, mode) {\\n  return new FiberNode(tag, pendingProps, key, mode);\\n}\\nfunction shouldConstruct(Component) {\\n  Component = Component.prototype;\\n  return !(!Component || !Component.isReactComponent);\\n}\\nfunction createWorkInProgress(current, pendingProps) {\\n  var workInProgress = current.alternate;\\n  null === workInProgress\\n    ? ((workInProgress = createFiberImplClass(\\n        current.tag,\\n        pendingProps,\\n        current.key,\\n        current.mode\\n      )),\\n      (workInProgress.elementType = current.elementType),\\n      (workInProgress.type = current.type),\\n      (workInProgress.stateNode = current.stateNode),\\n      (workInProgress.alternate = current),\\n      (current.alternate = workInProgress))\\n    : ((workInProgress.pendingProps = pendingProps),\\n      (workInProgress.type = current.type),\\n      (workInProgress.flags = 0),\\n      (workInProgress.subtreeFlags = 0),\\n      (workInProgress.deletions = null));\\n  workInProgress.flags = current.flags & 65011712;\\n  workInProgress.childLanes = current.childLanes;\\n  workInProgress.lanes = current.lanes;\\n  workInProgress.child = current.child;\\n  workInProgress.memoizedProps = current.memoizedProps;\\n  workInProgress.memoizedState = current.memoizedState;\\n  workInProgress.updateQueue = current.updateQueue;\\n  pendingProps = current.dependencies;\\n  workInProgress.dependencies =\\n    null === pendingProps\\n      ? null\\n      : { lanes: pendingProps.lanes, firstContext: pendingProps.firstContext };\\n  workInProgress.sibling = current.sibling;\\n  workInProgress.index = current.index;\\n  workInProgress.ref = current.ref;\\n  workInProgress.refCleanup = current.refCleanup;\\n  return workInProgress;\\n}\\nfunction resetWorkInProgress(workInProgress, renderLanes) {\\n  workInProgress.flags &= 65011714;\\n  var current = workInProgress.alternate;\\n  null === current\\n    ? ((workInProgress.childLanes = 0),\\n      (workInProgress.lanes = renderLanes),\\n      (workInProgress.child = null),\\n      (workInProgress.subtreeFlags = 0),\\n      (workInProgress.memoizedProps = null),\\n      (workInProgress.memoizedState = null),\\n      (workInProgress.updateQueue = null),\\n      (workInProgress.dependencies = null),\\n      (workInProgress.stateNode = null))\\n    : ((workInProgress.childLanes = current.childLanes),\\n      (workInProgress.lanes = current.lanes),\\n      (workInProgress.child = current.child),\\n      (workInProgress.subtreeFlags = 0),\\n      (workInProgress.deletions = null),\\n      (workInProgress.memoizedProps = current.memoizedProps),\\n      (workInProgress.memoizedState = current.memoizedState),\\n      (workInProgress.updateQueue = current.updateQueue),\\n      (workInProgress.type = current.type),\\n      (renderLanes = current.dependencies),\\n      (workInProgress.dependencies =\\n        null === renderLanes\\n          ? null\\n          : {\\n              lanes: renderLanes.lanes,\\n              firstContext: renderLanes.firstContext\\n            }));\\n  return workInProgress;\\n}\\nfunction createFiberFromTypeAndProps(\\n  type,\\n  key,\\n  pendingProps,\\n  owner,\\n  mode,\\n  lanes\\n) {\\n  var fiberTag = 0;\\n  owner = type;\\n  if (\"function\" === typeof type) shouldConstruct(type) && (fiberTag = 1);\\n  else if (\"string\" === typeof type)\\n    fiberTag = isHostHoistableType(\\n      type,\\n      pendingProps,\\n      contextStackCursor.current\\n    )\\n      ? 26\\n      : \"html\" === type || \"head\" === type || \"body\" === type\\n        ? 27\\n        : 5;\\n  else\\n    a: switch (type) {\\n      case REACT_ACTIVITY_TYPE:\\n        return (\\n          (type = createFiberImplClass(31, pendingProps, key, mode)),\\n          (type.elementType = REACT_ACTIVITY_TYPE),\\n          (type.lanes = lanes),\\n          type\\n        );\\n      case REACT_FRAGMENT_TYPE:\\n        return createFiberFromFragment(pendingProps.children, mode, lanes, key);\\n      case REACT_STRICT_MODE_TYPE:\\n        fiberTag = 8;\\n        mode |= 24;\\n        break;\\n      case REACT_PROFILER_TYPE:\\n        return (\\n          (type = createFiberImplClass(12, pendingProps, key, mode | 2)),\\n          (type.elementType = REACT_PROFILER_TYPE),\\n          (type.lanes = lanes),\\n          type\\n        );\\n      case REACT_SUSPENSE_TYPE:\\n        return (\\n          (type = createFiberImplClass(13, pendingProps, key, mode)),\\n          (type.elementType = REACT_SUSPENSE_TYPE),\\n          (type.lanes = lanes),\\n          type\\n        );\\n      case REACT_SUSPENSE_LIST_TYPE:\\n        return (\\n          (type = createFiberImplClass(19, pendingProps, key, mode)),\\n          (type.elementType = REACT_SUSPENSE_LIST_TYPE),\\n          (type.lanes = lanes),\\n          type\\n        );\\n      default:\\n        if (\"object\" === typeof type && null !== type)\\n          switch (type.$$typeof) {\\n            case REACT_PROVIDER_TYPE:\\n            case REACT_CONTEXT_TYPE:\\n              fiberTag = 10;\\n              break a;\\n            case REACT_CONSUMER_TYPE:\\n              fiberTag = 9;\\n              break a;\\n            case REACT_FORWARD_REF_TYPE:\\n              fiberTag = 11;\\n              break a;\\n            case REACT_MEMO_TYPE:\\n              fiberTag = 14;\\n              break a;\\n            case REACT_LAZY_TYPE:\\n              fiberTag = 16;\\n              owner = null;\\n              break a;\\n          }\\n        fiberTag = 29;\\n        pendingProps = Error(\\n          formatProdErrorMessage(130, null === type ? \"null\" : typeof type, \"\")\\n        );\\n        owner = null;\\n    }\\n  key = createFiberImplClass(fiberTag, pendingProps, key, mode);\\n  key.elementType = type;\\n  key.type = owner;\\n  key.lanes = lanes;\\n  return key;\\n}\\nfunction createFiberFromFragment(elements, mode, lanes, key) {\\n  elements = createFiberImplClass(7, elements, key, mode);\\n  elements.lanes = lanes;\\n  return elements;\\n}\\nfunction createFiberFromText(content, mode, lanes) {\\n  content = createFiberImplClass(6, content, null, mode);\\n  content.lanes = lanes;\\n  return content;\\n}\\nfunction createFiberFromPortal(portal, mode, lanes) {\\n  mode = createFiberImplClass(\\n    4,\\n    null !== portal.children ? portal.children : [],\\n    portal.key,\\n    mode\\n  );\\n  mode.lanes = lanes;\\n  mode.stateNode = {\\n    containerInfo: portal.containerInfo,\\n    pendingChildren: null,\\n    implementation: portal.implementation\\n  };\\n  return mode;\\n}\\nvar forkStack = [],\\n  forkStackIndex = 0,\\n  treeForkProvider = null,\\n  treeForkCount = 0,\\n  idStack = [],\\n  idStackIndex = 0,\\n  treeContextProvider = null,\\n  treeContextId = 1,\\n  treeContextOverflow = \"\";\\nfunction pushTreeFork(workInProgress, totalChildren) {\\n  forkStack[forkStackIndex++] = treeForkCount;\\n  forkStack[forkStackIndex++] = treeForkProvider;\\n  treeForkProvider = workInProgress;\\n  treeForkCount = totalChildren;\\n}\\nfunction pushTreeId(workInProgress, totalChildren, index) {\\n  idStack[idStackIndex++] = treeContextId;\\n  idStack[idStackIndex++] = treeContextOverflow;\\n  idStack[idStackIndex++] = treeContextProvider;\\n  treeContextProvider = workInProgress;\\n  var baseIdWithLeadingBit = treeContextId;\\n  workInProgress = treeContextOverflow;\\n  var baseLength = 32 - clz32(baseIdWithLeadingBit) - 1;\\n  baseIdWithLeadingBit &= ~(1 << baseLength);\\n  index += 1;\\n  var length = 32 - clz32(totalChildren) + baseLength;\\n  if (30 < length) {\\n    var numberOfOverflowBits = baseLength - (baseLength % 5);\\n    length = (\\n      baseIdWithLeadingBit &\\n      ((1 << numberOfOverflowBits) - 1)\\n    ).toString(32);\\n    baseIdWithLeadingBit >>= numberOfOverflowBits;\\n    baseLength -= numberOfOverflowBits;\\n    treeContextId =\\n      (1 << (32 - clz32(totalChildren) + baseLength)) |\\n      (index << baseLength) |\\n      baseIdWithLeadingBit;\\n    treeContextOverflow = length + workInProgress;\\n  } else\\n    (treeContextId =\\n      (1 << length) | (index << baseLength) | baseIdWithLeadingBit),\\n      (treeContextOverflow = workInProgress);\\n}\\nfunction pushMaterializedTreeId(workInProgress) {\\n  null !== workInProgress.return &&\\n    (pushTreeFork(workInProgress, 1), pushTreeId(workInProgress, 1, 0));\\n}\\nfunction popTreeContext(workInProgress) {\\n  for (; workInProgress === treeForkProvider; )\\n    (treeForkProvider = forkStack[--forkStackIndex]),\\n      (forkStack[forkStackIndex] = null),\\n      (treeForkCount = forkStack[--forkStackIndex]),\\n      (forkStack[forkStackIndex] = null);\\n  for (; workInProgress === treeContextProvider; )\\n    (treeContextProvider = idStack[--idStackIndex]),\\n      (idStack[idStackIndex] = null),\\n      (treeContextOverflow = idStack[--idStackIndex]),\\n      (idStack[idStackIndex] = null),\\n      (treeContextId = idStack[--idStackIndex]),\\n      (idStack[idStackIndex] = null);\\n}\\nvar hydrationParentFiber = null,\\n  nextHydratableInstance = null,\\n  isHydrating = !1,\\n  hydrationErrors = null,\\n  rootOrSingletonContext = !1,\\n  HydrationMismatchException = Error(formatProdErrorMessage(519));\\nfunction throwOnHydrationMismatch(fiber) {\\n  var error = Error(formatProdErrorMessage(418, \"\"));\\n  queueHydrationError(createCapturedValueAtFiber(error, fiber));\\n  throw HydrationMismatchException;\\n}\\nfunction prepareToHydrateHostInstance(fiber) {\\n  var instance = fiber.stateNode,\\n    type = fiber.type,\\n    props = fiber.memoizedProps;\\n  instance[internalInstanceKey] = fiber;\\n  instance[internalPropsKey] = props;\\n  switch (type) {\\n    case \"dialog\":\\n      listenToNonDelegatedEvent(\"cancel\", instance);\\n      listenToNonDelegatedEvent(\"close\", instance);\\n      break;\\n    case \"iframe\":\\n    case \"object\":\\n    case \"embed\":\\n      listenToNonDelegatedEvent(\"load\", instance);\\n      break;\\n    case \"video\":\\n    case \"audio\":\\n      for (type = 0; type < mediaEventTypes.length; type++)\\n        listenToNonDelegatedEvent(mediaEventTypes[type], instance);\\n      break;\\n    case \"source\":\\n      listenToNonDelegatedEvent(\"error\", instance);\\n      break;\\n    case \"img\":\\n    case \"image\":\\n    case \"link\":\\n      listenToNonDelegatedEvent(\"error\", instance);\\n      listenToNonDelegatedEvent(\"load\", instance);\\n      break;\\n    case \"details\":\\n      listenToNonDelegatedEvent(\"toggle\", instance);\\n      break;\\n    case \"input\":\\n      listenToNonDelegatedEvent(\"invalid\", instance);\\n      initInput(\\n        instance,\\n        props.value,\\n        props.defaultValue,\\n        props.checked,\\n        props.defaultChecked,\\n        props.type,\\n        props.name,\\n        !0\\n      );\\n      track(instance);\\n      break;\\n    case \"select\":\\n      listenToNonDelegatedEvent(\"invalid\", instance);\\n      break;\\n    case \"textarea\":\\n      listenToNonDelegatedEvent(\"invalid\", instance),\\n        initTextarea(instance, props.value, props.defaultValue, props.children),\\n        track(instance);\\n  }\\n  type = props.children;\\n  (\"string\" !== typeof type &&\\n    \"number\" !== typeof type &&\\n    \"bigint\" !== typeof type) ||\\n  instance.textContent === \"\" + type ||\\n  !0 === props.suppressHydrationWarning ||\\n  checkForUnmatchedText(instance.textContent, type)\\n    ? (null != props.popover &&\\n        (listenToNonDelegatedEvent(\"beforetoggle\", instance),\\n        listenToNonDelegatedEvent(\"toggle\", instance)),\\n      null != props.onScroll && listenToNonDelegatedEvent(\"scroll\", instance),\\n      null != props.onScrollEnd &&\\n        listenToNonDelegatedEvent(\"scrollend\", instance),\\n      null != props.onClick && (instance.onclick = noop$1),\\n      (instance = !0))\\n    : (instance = !1);\\n  instance || throwOnHydrationMismatch(fiber);\\n}\\nfunction popToNextHostParent(fiber) {\\n  for (hydrationParentFiber = fiber.return; hydrationParentFiber; )\\n    switch (hydrationParentFiber.tag) {\\n      case 5:\\n      case 13:\\n        rootOrSingletonContext = !1;\\n        return;\\n      case 27:\\n      case 3:\\n        rootOrSingletonContext = !0;\\n        return;\\n      default:\\n        hydrationParentFiber = hydrationParentFiber.return;\\n    }\\n}\\nfunction popHydrationState(fiber) {\\n  if (fiber !== hydrationParentFiber) return !1;\\n  if (!isHydrating) return popToNextHostParent(fiber), (isHydrating = !0), !1;\\n  var tag = fiber.tag,\\n    JSCompiler_temp;\\n  if ((JSCompiler_temp = 3 !== tag && 27 !== tag)) {\\n    if ((JSCompiler_temp = 5 === tag))\\n      (JSCompiler_temp = fiber.type),\\n        (JSCompiler_temp =\\n          !(\"form\" !== JSCompiler_temp && \"button\" !== JSCompiler_temp) ||\\n          shouldSetTextContent(fiber.type, fiber.memoizedProps));\\n    JSCompiler_temp = !JSCompiler_temp;\\n  }\\n  JSCompiler_temp && nextHydratableInstance && throwOnHydrationMismatch(fiber);\\n  popToNextHostParent(fiber);\\n  if (13 === tag) {\\n    fiber = fiber.memoizedState;\\n    fiber = null !== fiber ? fiber.dehydrated : null;\\n    if (!fiber) throw Error(formatProdErrorMessage(317));\\n    a: {\\n      fiber = fiber.nextSibling;\\n      for (tag = 0; fiber; ) {\\n        if (8 === fiber.nodeType)\\n          if (((JSCompiler_temp = fiber.data), \"/$\" === JSCompiler_temp)) {\\n            if (0 === tag) {\\n              nextHydratableInstance = getNextHydratable(fiber.nextSibling);\\n              break a;\\n            }\\n            tag--;\\n          } else\\n            (\"$\" !== JSCompiler_temp &&\\n              \"$!\" !== JSCompiler_temp &&\\n              \"$?\" !== JSCompiler_temp) ||\\n              tag++;\\n        fiber = fiber.nextSibling;\\n      }\\n      nextHydratableInstance = null;\\n    }\\n  } else\\n    27 === tag\\n      ? ((tag = nextHydratableInstance),\\n        isSingletonScope(fiber.type)\\n          ? ((fiber = previousHydratableOnEnteringScopedSingleton),\\n            (previousHydratableOnEnteringScopedSingleton = null),\\n            (nextHydratableInstance = fiber))\\n          : (nextHydratableInstance = tag))\\n      : (nextHydratableInstance = hydrationParentFiber\\n          ? getNextHydratable(fiber.stateNode.nextSibling)\\n          : null);\\n  return !0;\\n}\\nfunction resetHydrationState() {\\n  nextHydratableInstance = hydrationParentFiber = null;\\n  isHydrating = !1;\\n}\\nfunction upgradeHydrationErrorsToRecoverable() {\\n  var queuedErrors = hydrationErrors;\\n  null !== queuedErrors &&\\n    (null === workInProgressRootRecoverableErrors\\n      ? (workInProgressRootRecoverableErrors = queuedErrors)\\n      : workInProgressRootRecoverableErrors.push.apply(\\n          workInProgressRootRecoverableErrors,\\n          queuedErrors\\n        ),\\n    (hydrationErrors = null));\\n  return queuedErrors;\\n}\\nfunction queueHydrationError(error) {\\n  null === hydrationErrors\\n    ? (hydrationErrors = [error])\\n    : hydrationErrors.push(error);\\n}\\nvar valueCursor = createCursor(null),\\n  currentlyRenderingFiber$1 = null,\\n  lastContextDependency = null;\\nfunction pushProvider(providerFiber, context, nextValue) {\\n  push(valueCursor, context._currentValue);\\n  context._currentValue = nextValue;\\n}\\nfunction popProvider(context) {\\n  context._currentValue = valueCursor.current;\\n  pop(valueCursor);\\n}\\nfunction scheduleContextWorkOnParentPath(parent, renderLanes, propagationRoot) {\\n  for (; null !== parent; ) {\\n    var alternate = parent.alternate;\\n    (parent.childLanes & renderLanes) !== renderLanes\\n      ? ((parent.childLanes |= renderLanes),\\n        null !== alternate && (alternate.childLanes |= renderLanes))\\n      : null !== alternate &&\\n        (alternate.childLanes & renderLanes) !== renderLanes &&\\n        (alternate.childLanes |= renderLanes);\\n    if (parent === propagationRoot) break;\\n    parent = parent.return;\\n  }\\n}\\nfunction propagateContextChanges(\\n  workInProgress,\\n  contexts,\\n  renderLanes,\\n  forcePropagateEntireTree\\n) {\\n  var fiber = workInProgress.child;\\n  null !== fiber && (fiber.return = workInProgress);\\n  for (; null !== fiber; ) {\\n    var list = fiber.dependencies;\\n    if (null !== list) {\\n      var nextFiber = fiber.child;\\n      list = list.firstContext;\\n      a: for (; null !== list; ) {\\n        var dependency = list;\\n        list = fiber;\\n        for (var i = 0; i < contexts.length; i++)\\n          if (dependency.context === contexts[i]) {\\n            list.lanes |= renderLanes;\\n            dependency = list.alternate;\\n            null !== dependency && (dependency.lanes |= renderLanes);\\n            scheduleContextWorkOnParentPath(\\n              list.return,\\n              renderLanes,\\n              workInProgress\\n            );\\n            forcePropagateEntireTree || (nextFiber = null);\\n            break a;\\n          }\\n        list = dependency.next;\\n      }\\n    } else if (18 === fiber.tag) {\\n      nextFiber = fiber.return;\\n      if (null === nextFiber) throw Error(formatProdErrorMessage(341));\\n      nextFiber.lanes |= renderLanes;\\n      list = nextFiber.alternate;\\n      null !== list && (list.lanes |= renderLanes);\\n      scheduleContextWorkOnParentPath(nextFiber, renderLanes, workInProgress);\\n      nextFiber = null;\\n    } else nextFiber = fiber.child;\\n    if (null !== nextFiber) nextFiber.return = fiber;\\n    else\\n      for (nextFiber = fiber; null !== nextFiber; ) {\\n        if (nextFiber === workInProgress) {\\n          nextFiber = null;\\n          break;\\n        }\\n        fiber = nextFiber.sibling;\\n        if (null !== fiber) {\\n          fiber.return = nextFiber.return;\\n          nextFiber = fiber;\\n          break;\\n        }\\n        nextFiber = nextFiber.return;\\n      }\\n    fiber = nextFiber;\\n  }\\n}\\nfunction propagateParentContextChanges(\\n  current,\\n  workInProgress,\\n  renderLanes,\\n  forcePropagateEntireTree\\n) {\\n  current = null;\\n  for (\\n    var parent = workInProgress, isInsidePropagationBailout = !1;\\n    null !== parent;\\n\\n  ) {\\n    if (!isInsidePropagationBailout)\\n      if (0 !== (parent.flags & 524288)) isInsidePropagationBailout = !0;\\n      else if (0 !== (parent.flags & 262144)) break;\\n    if (10 === parent.tag) {\\n      var currentParent = parent.alternate;\\n      if (null === currentParent) throw Error(formatProdErrorMessage(387));\\n      currentParent = currentParent.memoizedProps;\\n      if (null !== currentParent) {\\n        var context = parent.type;\\n        objectIs(parent.pendingProps.value, currentParent.value) ||\\n          (null !== current ? current.push(context) : (current = [context]));\\n      }\\n    } else if (parent === hostTransitionProviderCursor.current) {\\n      currentParent = parent.alternate;\\n      if (null === currentParent) throw Error(formatProdErrorMessage(387));\\n      currentParent.memoizedState.memoizedState !==\\n        parent.memoizedState.memoizedState &&\\n        (null !== current\\n          ? current.push(HostTransitionContext)\\n          : (current = [HostTransitionContext]));\\n    }\\n    parent = parent.return;\\n  }\\n  null !== current &&\\n    propagateContextChanges(\\n      workInProgress,\\n      current,\\n      renderLanes,\\n      forcePropagateEntireTree\\n    );\\n  workInProgress.flags |= 262144;\\n}\\nfunction checkIfContextChanged(currentDependencies) {\\n  for (\\n    currentDependencies = currentDependencies.firstContext;\\n    null !== currentDependencies;\\n\\n  ) {\\n    if (\\n      !objectIs(\\n        currentDependencies.context._currentValue,\\n        currentDependencies.memoizedValue\\n      )\\n    )\\n      return !0;\\n    currentDependencies = currentDependencies.next;\\n  }\\n  return !1;\\n}\\nfunction prepareToReadContext(workInProgress) {\\n  currentlyRenderingFiber$1 = workInProgress;\\n  lastContextDependency = null;\\n  workInProgress = workInProgress.dependencies;\\n  null !== workInProgress && (workInProgress.firstContext = null);\\n}\\nfunction readContext(context) {\\n  return readContextForConsumer(currentlyRenderingFiber$1, context);\\n}\\nfunction readContextDuringReconciliation(consumer, context) {\\n  null === currentlyRenderingFiber$1 && prepareToReadContext(consumer);\\n  return readContextForConsumer(consumer, context);\\n}\\nfunction readContextForConsumer(consumer, context) {\\n  var value = context._currentValue;\\n  context = { context: context, memoizedValue: value, next: null };\\n  if (null === lastContextDependency) {\\n    if (null === consumer) throw Error(formatProdErrorMessage(308));\\n    lastContextDependency = context;\\n    consumer.dependencies = { lanes: 0, firstContext: context };\\n    consumer.flags |= 524288;\\n  } else lastContextDependency = lastContextDependency.next = context;\\n  return value;\\n}\\nvar AbortControllerLocal =\\n    \"undefined\" !== typeof AbortController\\n      ? AbortController\\n      : function () {\\n          var listeners = [],\\n            signal = (this.signal = {\\n              aborted: !1,\\n              addEventListener: function (type, listener) {\\n                listeners.push(listener);\\n              }\\n            });\\n          this.abort = function () {\\n            signal.aborted = !0;\\n            listeners.forEach(function (listener) {\\n              return listener();\\n            });\\n          };\\n        },\\n  scheduleCallback$2 = Scheduler.unstable_scheduleCallback,\\n  NormalPriority = Scheduler.unstable_NormalPriority,\\n  CacheContext = {\\n    $$typeof: REACT_CONTEXT_TYPE,\\n    Consumer: null,\\n    Provider: null,\\n    _currentValue: null,\\n    _currentValue2: null,\\n    _threadCount: 0\\n  };\\nfunction createCache() {\\n  return {\\n    controller: new AbortControllerLocal(),\\n    data: new Map(),\\n    refCount: 0\\n  };\\n}\\nfunction releaseCache(cache) {\\n  cache.refCount--;\\n  0 === cache.refCount &&\\n    scheduleCallback$2(NormalPriority, function () {\\n      cache.controller.abort();\\n    });\\n}\\nvar currentEntangledListeners = null,\\n  currentEntangledPendingCount = 0,\\n  currentEntangledLane = 0,\\n  currentEntangledActionThenable = null;\\nfunction entangleAsyncAction(transition, thenable) {\\n  if (null === currentEntangledListeners) {\\n    var entangledListeners = (currentEntangledListeners = []);\\n    currentEntangledPendingCount = 0;\\n    currentEntangledLane = requestTransitionLane();\\n    currentEntangledActionThenable = {\\n      status: \"pending\",\\n      value: void 0,\\n      then: function (resolve) {\\n        entangledListeners.push(resolve);\\n      }\\n    };\\n  }\\n  currentEntangledPendingCount++;\\n  thenable.then(pingEngtangledActionScope, pingEngtangledActionScope);\\n  return thenable;\\n}\\nfunction pingEngtangledActionScope() {\\n  if (\\n    0 === --currentEntangledPendingCount &&\\n    null !== currentEntangledListeners\\n  ) {\\n    null !== currentEntangledActionThenable &&\\n      (currentEntangledActionThenable.status = \"fulfilled\");\\n    var listeners = currentEntangledListeners;\\n    currentEntangledListeners = null;\\n    currentEntangledLane = 0;\\n    currentEntangledActionThenable = null;\\n    for (var i = 0; i < listeners.length; i++) (0, listeners[i])();\\n  }\\n}\\nfunction chainThenableValue(thenable, result) {\\n  var listeners = [],\\n    thenableWithOverride = {\\n      status: \"pending\",\\n      value: null,\\n      reason: null,\\n      then: function (resolve) {\\n        listeners.push(resolve);\\n      }\\n    };\\n  thenable.then(\\n    function () {\\n      thenableWithOverride.status = \"fulfilled\";\\n      thenableWithOverride.value = result;\\n      for (var i = 0; i < listeners.length; i++) (0, listeners[i])(result);\\n    },\\n    function (error) {\\n      thenableWithOverride.status = \"rejected\";\\n      thenableWithOverride.reason = error;\\n      for (error = 0; error < listeners.length; error++)\\n        (0, listeners[error])(void 0);\\n    }\\n  );\\n  return thenableWithOverride;\\n}\\nvar prevOnStartTransitionFinish = ReactSharedInternals.S;\\nReactSharedInternals.S = function (transition, returnValue) {\\n  \"object\" === typeof returnValue &&\\n    null !== returnValue &&\\n    \"function\" === typeof returnValue.then &&\\n    entangleAsyncAction(transition, returnValue);\\n  null !== prevOnStartTransitionFinish &&\\n    prevOnStartTransitionFinish(transition, returnValue);\\n};\\nvar resumedCache = createCursor(null);\\nfunction peekCacheFromPool() {\\n  var cacheResumedFromPreviousRender = resumedCache.current;\\n  return null !== cacheResumedFromPreviousRender\\n    ? cacheResumedFromPreviousRender\\n    : workInProgressRoot.pooledCache;\\n}\\nfunction pushTransition(offscreenWorkInProgress, prevCachePool) {\\n  null === prevCachePool\\n    ? push(resumedCache, resumedCache.current)\\n    : push(resumedCache, prevCachePool.pool);\\n}\\nfunction getSuspendedCache() {\\n  var cacheFromPool = peekCacheFromPool();\\n  return null === cacheFromPool\\n    ? null\\n    : { parent: CacheContext._currentValue, pool: cacheFromPool };\\n}\\nvar SuspenseException = Error(formatProdErrorMessage(460)),\\n  SuspenseyCommitException = Error(formatProdErrorMessage(474)),\\n  SuspenseActionException = Error(formatProdErrorMessage(542)),\\n  noopSuspenseyCommitThenable = { then: function () {} };\\nfunction isThenableResolved(thenable) {\\n  thenable = thenable.status;\\n  return \"fulfilled\" === thenable || \"rejected\" === thenable;\\n}\\nfunction noop$3() {}\\nfunction trackUsedThenable(thenableState, thenable, index) {\\n  index = thenableState[index];\\n  void 0 === index\\n    ? thenableState.push(thenable)\\n    : index !== thenable && (thenable.then(noop$3, noop$3), (thenable = index));\\n  switch (thenable.status) {\\n    case \"fulfilled\":\\n      return thenable.value;\\n    case \"rejected\":\\n      throw (\\n        ((thenableState = thenable.reason),\\n        checkIfUseWrappedInAsyncCatch(thenableState),\\n        thenableState)\\n      );\\n    default:\\n      if (\"string\" === typeof thenable.status) thenable.then(noop$3, noop$3);\\n      else {\\n        thenableState = workInProgressRoot;\\n        if (null !== thenableState && 100 < thenableState.shellSuspendCounter)\\n          throw Error(formatProdErrorMessage(482));\\n        thenableState = thenable;\\n        thenableState.status = \"pending\";\\n        thenableState.then(\\n          function (fulfilledValue) {\\n            if (\"pending\" === thenable.status) {\\n              var fulfilledThenable = thenable;\\n              fulfilledThenable.status = \"fulfilled\";\\n              fulfilledThenable.value = fulfilledValue;\\n            }\\n          },\\n          function (error) {\\n            if (\"pending\" === thenable.status) {\\n              var rejectedThenable = thenable;\\n              rejectedThenable.status = \"rejected\";\\n              rejectedThenable.reason = error;\\n            }\\n          }\\n        );\\n      }\\n      switch (thenable.status) {\\n        case \"fulfilled\":\\n          return thenable.value;\\n        case \"rejected\":\\n          throw (\\n            ((thenableState = thenable.reason),\\n            checkIfUseWrappedInAsyncCatch(thenableState),\\n            thenableState)\\n          );\\n      }\\n      suspendedThenable = thenable;\\n      throw SuspenseException;\\n  }\\n}\\nvar suspendedThenable = null;\\nfunction getSuspendedThenable() {\\n  if (null === suspendedThenable) throw Error(formatProdErrorMessage(459));\\n  var thenable = suspendedThenable;\\n  suspendedThenable = null;\\n  return thenable;\\n}\\nfunction checkIfUseWrappedInAsyncCatch(rejectedReason) {\\n  if (\\n    rejectedReason === SuspenseException ||\\n    rejectedReason === SuspenseActionException\\n  )\\n    throw Error(formatProdErrorMessage(483));\\n}\\nvar hasForceUpdate = !1;\\nfunction initializeUpdateQueue(fiber) {\\n  fiber.updateQueue = {\\n    baseState: fiber.memoizedState,\\n    firstBaseUpdate: null,\\n    lastBaseUpdate: null,\\n    shared: { pending: null, lanes: 0, hiddenCallbacks: null },\\n    callbacks: null\\n  };\\n}\\nfunction cloneUpdateQueue(current, workInProgress) {\\n  current = current.updateQueue;\\n  workInProgress.updateQueue === current &&\\n    (workInProgress.updateQueue = {\\n      baseState: current.baseState,\\n      firstBaseUpdate: current.firstBaseUpdate,\\n      lastBaseUpdate: current.lastBaseUpdate,\\n      shared: current.shared,\\n      callbacks: null\\n    });\\n}\\nfunction createUpdate(lane) {\\n  return { lane: lane, tag: 0, payload: null, callback: null, next: null };\\n}\\nfunction enqueueUpdate(fiber, update, lane) {\\n  var updateQueue = fiber.updateQueue;\\n  if (null === updateQueue) return null;\\n  updateQueue = updateQueue.shared;\\n  if (0 !== (executionContext & 2)) {\\n    var pending = updateQueue.pending;\\n    null === pending\\n      ? (update.next = update)\\n      : ((update.next = pending.next), (pending.next = update));\\n    updateQueue.pending = update;\\n    update = getRootForUpdatedFiber(fiber);\\n    markUpdateLaneFromFiberToRoot(fiber, null, lane);\\n    return update;\\n  }\\n  enqueueUpdate$1(fiber, updateQueue, update, lane);\\n  return getRootForUpdatedFiber(fiber);\\n}\\nfunction entangleTransitions(root, fiber, lane) {\\n  fiber = fiber.updateQueue;\\n  if (null !== fiber && ((fiber = fiber.shared), 0 !== (lane & 4194048))) {\\n    var queueLanes = fiber.lanes;\\n    queueLanes &= root.pendingLanes;\\n    lane |= queueLanes;\\n    fiber.lanes = lane;\\n    markRootEntangled(root, lane);\\n  }\\n}\\nfunction enqueueCapturedUpdate(workInProgress, capturedUpdate) {\\n  var queue = workInProgress.updateQueue,\\n    current = workInProgress.alternate;\\n  if (\\n    null !== current &&\\n    ((current = current.updateQueue), queue === current)\\n  ) {\\n    var newFirst = null,\\n      newLast = null;\\n    queue = queue.firstBaseUpdate;\\n    if (null !== queue) {\\n      do {\\n        var clone = {\\n          lane: queue.lane,\\n          tag: queue.tag,\\n          payload: queue.payload,\\n          callback: null,\\n          next: null\\n        };\\n        null === newLast\\n          ? (newFirst = newLast = clone)\\n          : (newLast = newLast.next = clone);\\n        queue = queue.next;\\n      } while (null !== queue);\\n      null === newLast\\n        ? (newFirst = newLast = capturedUpdate)\\n        : (newLast = newLast.next = capturedUpdate);\\n    } else newFirst = newLast = capturedUpdate;\\n    queue = {\\n      baseState: current.baseState,\\n      firstBaseUpdate: newFirst,\\n      lastBaseUpdate: newLast,\\n      shared: current.shared,\\n      callbacks: current.callbacks\\n    };\\n    workInProgress.updateQueue = queue;\\n    return;\\n  }\\n  workInProgress = queue.lastBaseUpdate;\\n  null === workInProgress\\n    ? (queue.firstBaseUpdate = capturedUpdate)\\n    : (workInProgress.next = capturedUpdate);\\n  queue.lastBaseUpdate = capturedUpdate;\\n}\\nvar didReadFromEntangledAsyncAction = !1;\\nfunction suspendIfUpdateReadFromEntangledAsyncAction() {\\n  if (didReadFromEntangledAsyncAction) {\\n    var entangledActionThenable = currentEntangledActionThenable;\\n    if (null !== entangledActionThenable) throw entangledActionThenable;\\n  }\\n}\\nfunction processUpdateQueue(\\n  workInProgress$jscomp$0,\\n  props,\\n  instance$jscomp$0,\\n  renderLanes\\n) {\\n  didReadFromEntangledAsyncAction = !1;\\n  var queue = workInProgress$jscomp$0.updateQueue;\\n  hasForceUpdate = !1;\\n  var firstBaseUpdate = queue.firstBaseUpdate,\\n    lastBaseUpdate = queue.lastBaseUpdate,\\n    pendingQueue = queue.shared.pending;\\n  if (null !== pendingQueue) {\\n    queue.shared.pending = null;\\n    var lastPendingUpdate = pendingQueue,\\n      firstPendingUpdate = lastPendingUpdate.next;\\n    lastPendingUpdate.next = null;\\n    null === lastBaseUpdate\\n      ? (firstBaseUpdate = firstPendingUpdate)\\n      : (lastBaseUpdate.next = firstPendingUpdate);\\n    lastBaseUpdate = lastPendingUpdate;\\n    var current = workInProgress$jscomp$0.alternate;\\n    null !== current &&\\n      ((current = current.updateQueue),\\n      (pendingQueue = current.lastBaseUpdate),\\n      pendingQueue !== lastBaseUpdate &&\\n        (null === pendingQueue\\n          ? (current.firstBaseUpdate = firstPendingUpdate)\\n          : (pendingQueue.next = firstPendingUpdate),\\n        (current.lastBaseUpdate = lastPendingUpdate)));\\n  }\\n  if (null !== firstBaseUpdate) {\\n    var newState = queue.baseState;\\n    lastBaseUpdate = 0;\\n    current = firstPendingUpdate = lastPendingUpdate = null;\\n    pendingQueue = firstBaseUpdate;\\n    do {\\n      var updateLane = pendingQueue.lane & -536870913,\\n        isHiddenUpdate = updateLane !== pendingQueue.lane;\\n      if (\\n        isHiddenUpdate\\n          ? (workInProgressRootRenderLanes & updateLane) === updateLane\\n          : (renderLanes & updateLane) === updateLane\\n      ) {\\n        0 !== updateLane &&\\n          updateLane === currentEntangledLane &&\\n          (didReadFromEntangledAsyncAction = !0);\\n        null !== current &&\\n          (current = current.next =\\n            {\\n              lane: 0,\\n              tag: pendingQueue.tag,\\n              payload: pendingQueue.payload,\\n              callback: null,\\n              next: null\\n            });\\n        a: {\\n          var workInProgress = workInProgress$jscomp$0,\\n            update = pendingQueue;\\n          updateLane = props;\\n          var instance = instance$jscomp$0;\\n          switch (update.tag) {\\n            case 1:\\n              workInProgress = update.payload;\\n              if (\"function\" === typeof workInProgress) {\\n                newState = workInProgress.call(instance, newState, updateLane);\\n                break a;\\n              }\\n              newState = workInProgress;\\n              break a;\\n            case 3:\\n              workInProgress.flags = (workInProgress.flags & -65537) | 128;\\n            case 0:\\n              workInProgress = update.payload;\\n              updateLane =\\n                \"function\" === typeof workInProgress\\n                  ? workInProgress.call(instance, newState, updateLane)\\n                  : workInProgress;\\n              if (null === updateLane || void 0 === updateLane) break a;\\n              newState = assign({}, newState, updateLane);\\n              break a;\\n            case 2:\\n              hasForceUpdate = !0;\\n          }\\n        }\\n        updateLane = pendingQueue.callback;\\n        null !== updateLane &&\\n          ((workInProgress$jscomp$0.flags |= 64),\\n          isHiddenUpdate && (workInProgress$jscomp$0.flags |= 8192),\\n          (isHiddenUpdate = queue.callbacks),\\n          null === isHiddenUpdate\\n            ? (queue.callbacks = [updateLane])\\n            : isHiddenUpdate.push(updateLane));\\n      } else\\n        (isHiddenUpdate = {\\n          lane: updateLane,\\n          tag: pendingQueue.tag,\\n          payload: pendingQueue.payload,\\n          callback: pendingQueue.callback,\\n          next: null\\n        }),\\n          null === current\\n            ? ((firstPendingUpdate = current = isHiddenUpdate),\\n              (lastPendingUpdate = newState))\\n            : (current = current.next = isHiddenUpdate),\\n          (lastBaseUpdate |= updateLane);\\n      pendingQueue = pendingQueue.next;\\n      if (null === pendingQueue)\\n        if (((pendingQueue = queue.shared.pending), null === pendingQueue))\\n          break;\\n        else\\n          (isHiddenUpdate = pendingQueue),\\n            (pendingQueue = isHiddenUpdate.next),\\n            (isHiddenUpdate.next = null),\\n            (queue.lastBaseUpdate = isHiddenUpdate),\\n            (queue.shared.pending = null);\\n    } while (1);\\n    null === current && (lastPendingUpdate = newState);\\n    queue.baseState = lastPendingUpdate;\\n    queue.firstBaseUpdate = firstPendingUpdate;\\n    queue.lastBaseUpdate = current;\\n    null === firstBaseUpdate && (queue.shared.lanes = 0);\\n    workInProgressRootSkippedLanes |= lastBaseUpdate;\\n    workInProgress$jscomp$0.lanes = lastBaseUpdate;\\n    workInProgress$jscomp$0.memoizedState = newState;\\n  }\\n}\\nfunction callCallback(callback, context) {\\n  if (\"function\" !== typeof callback)\\n    throw Error(formatProdErrorMessage(191, callback));\\n  callback.call(context);\\n}\\nfunction commitCallbacks(updateQueue, context) {\\n  var callbacks = updateQueue.callbacks;\\n  if (null !== callbacks)\\n    for (\\n      updateQueue.callbacks = null, updateQueue = 0;\\n      updateQueue < callbacks.length;\\n      updateQueue++\\n    )\\n      callCallback(callbacks[updateQueue], context);\\n}\\nvar currentTreeHiddenStackCursor = createCursor(null),\\n  prevEntangledRenderLanesCursor = createCursor(0);\\nfunction pushHiddenContext(fiber, context) {\\n  fiber = entangledRenderLanes;\\n  push(prevEntangledRenderLanesCursor, fiber);\\n  push(currentTreeHiddenStackCursor, context);\\n  entangledRenderLanes = fiber | context.baseLanes;\\n}\\nfunction reuseHiddenContextOnStack() {\\n  push(prevEntangledRenderLanesCursor, entangledRenderLanes);\\n  push(currentTreeHiddenStackCursor, currentTreeHiddenStackCursor.current);\\n}\\nfunction popHiddenContext() {\\n  entangledRenderLanes = prevEntangledRenderLanesCursor.current;\\n  pop(currentTreeHiddenStackCursor);\\n  pop(prevEntangledRenderLanesCursor);\\n}\\nvar renderLanes = 0,\\n  currentlyRenderingFiber = null,\\n  currentHook = null,\\n  workInProgressHook = null,\\n  didScheduleRenderPhaseUpdate = !1,\\n  didScheduleRenderPhaseUpdateDuringThisPass = !1,\\n  shouldDoubleInvokeUserFnsInHooksDEV = !1,\\n  localIdCounter = 0,\\n  thenableIndexCounter$1 = 0,\\n  thenableState$1 = null,\\n  globalClientIdCounter = 0;\\nfunction throwInvalidHookError() {\\n  throw Error(formatProdErrorMessage(321));\\n}\\nfunction areHookInputsEqual(nextDeps, prevDeps) {\\n  if (null === prevDeps) return !1;\\n  for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++)\\n    if (!objectIs(nextDeps[i], prevDeps[i])) return !1;\\n  return !0;\\n}\\nfunction renderWithHooks(\\n  current,\\n  workInProgress,\\n  Component,\\n  props,\\n  secondArg,\\n  nextRenderLanes\\n) {\\n  renderLanes = nextRenderLanes;\\n  currentlyRenderingFiber = workInProgress;\\n  workInProgress.memoizedState = null;\\n  workInProgress.updateQueue = null;\\n  workInProgress.lanes = 0;\\n  ReactSharedInternals.H =\\n    null === current || null === current.memoizedState\\n      ? HooksDispatcherOnMount\\n      : HooksDispatcherOnUpdate;\\n  shouldDoubleInvokeUserFnsInHooksDEV = !1;\\n  nextRenderLanes = Component(props, secondArg);\\n  shouldDoubleInvokeUserFnsInHooksDEV = !1;\\n  didScheduleRenderPhaseUpdateDuringThisPass &&\\n    (nextRenderLanes = renderWithHooksAgain(\\n      workInProgress,\\n      Component,\\n      props,\\n      secondArg\\n    ));\\n  finishRenderingHooks(current);\\n  return nextRenderLanes;\\n}\\nfunction finishRenderingHooks(current) {\\n  ReactSharedInternals.H = ContextOnlyDispatcher;\\n  var didRenderTooFewHooks = null !== currentHook && null !== currentHook.next;\\n  renderLanes = 0;\\n  workInProgressHook = currentHook = currentlyRenderingFiber = null;\\n  didScheduleRenderPhaseUpdate = !1;\\n  thenableIndexCounter$1 = 0;\\n  thenableState$1 = null;\\n  if (didRenderTooFewHooks) throw Error(formatProdErrorMessage(300));\\n  null === current ||\\n    didReceiveUpdate ||\\n    ((current = current.dependencies),\\n    null !== current &&\\n      checkIfContextChanged(current) &&\\n      (didReceiveUpdate = !0));\\n}\\nfunction renderWithHooksAgain(workInProgress, Component, props, secondArg) {\\n  currentlyRenderingFiber = workInProgress;\\n  var numberOfReRenders = 0;\\n  do {\\n    didScheduleRenderPhaseUpdateDuringThisPass && (thenableState$1 = null);\\n    thenableIndexCounter$1 = 0;\\n    didScheduleRenderPhaseUpdateDuringThisPass = !1;\\n    if (25 <= numberOfReRenders) throw Error(formatProdErrorMessage(301));\\n    numberOfReRenders += 1;\\n    workInProgressHook = currentHook = null;\\n    if (null != workInProgress.updateQueue) {\\n      var children = workInProgress.updateQueue;\\n      children.lastEffect = null;\\n      children.events = null;\\n      children.stores = null;\\n      null != children.memoCache && (children.memoCache.index = 0);\\n    }\\n    ReactSharedInternals.H = HooksDispatcherOnRerender;\\n    children = Component(props, secondArg);\\n  } while (didScheduleRenderPhaseUpdateDuringThisPass);\\n  return children;\\n}\\nfunction TransitionAwareHostComponent() {\\n  var dispatcher = ReactSharedInternals.H,\\n    maybeThenable = dispatcher.useState()[0];\\n  maybeThenable =\\n    \"function\" === typeof maybeThenable.then\\n      ? useThenable(maybeThenable)\\n      : maybeThenable;\\n  dispatcher = dispatcher.useState()[0];\\n  (null !== currentHook ? currentHook.memoizedState : null) !== dispatcher &&\\n    (currentlyRenderingFiber.flags |= 1024);\\n  return maybeThenable;\\n}\\nfunction checkDidRenderIdHook() {\\n  var didRenderIdHook = 0 !== localIdCounter;\\n  localIdCounter = 0;\\n  return didRenderIdHook;\\n}\\nfunction bailoutHooks(current, workInProgress, lanes) {\\n  workInProgress.updateQueue = current.updateQueue;\\n  workInProgress.flags &= -2053;\\n  current.lanes &= ~lanes;\\n}\\nfunction resetHooksOnUnwind(workInProgress) {\\n  if (didScheduleRenderPhaseUpdate) {\\n    for (\\n      workInProgress = workInProgress.memoizedState;\\n      null !== workInProgress;\\n\\n    ) {\\n      var queue = workInProgress.queue;\\n      null !== queue && (queue.pending = null);\\n      workInProgress = workInProgress.next;\\n    }\\n    didScheduleRenderPhaseUpdate = !1;\\n  }\\n  renderLanes = 0;\\n  workInProgressHook = currentHook = currentlyRenderingFiber = null;\\n  didScheduleRenderPhaseUpdateDuringThisPass = !1;\\n  thenableIndexCounter$1 = localIdCounter = 0;\\n  thenableState$1 = null;\\n}\\nfunction mountWorkInProgressHook() {\\n  var hook = {\\n    memoizedState: null,\\n    baseState: null,\\n    baseQueue: null,\\n    queue: null,\\n    next: null\\n  };\\n  null === workInProgressHook\\n    ? (currentlyRenderingFiber.memoizedState = workInProgressHook = hook)\\n    : (workInProgressHook = workInProgressHook.next = hook);\\n  return workInProgressHook;\\n}\\nfunction updateWorkInProgressHook() {\\n  if (null === currentHook) {\\n    var nextCurrentHook = currentlyRenderingFiber.alternate;\\n    nextCurrentHook =\\n      null !== nextCurrentHook ? nextCurrentHook.memoizedState : null;\\n  } else nextCurrentHook = currentHook.next;\\n  var nextWorkInProgressHook =\\n    null === workInProgressHook\\n      ? currentlyRenderingFiber.memoizedState\\n      : workInProgressHook.next;\\n  if (null !== nextWorkInProgressHook)\\n    (workInProgressHook = nextWorkInProgressHook),\\n      (currentHook = nextCurrentHook);\\n  else {\\n    if (null === nextCurrentHook) {\\n      if (null === currentlyRenderingFiber.alternate)\\n        throw Error(formatProdErrorMessage(467));\\n      throw Error(formatProdErrorMessage(310));\\n    }\\n    currentHook = nextCurrentHook;\\n    nextCurrentHook = {\\n      memoizedState: currentHook.memoizedState,\\n      baseState: currentHook.baseState,\\n      baseQueue: currentHook.baseQueue,\\n      queue: currentHook.queue,\\n      next: null\\n    };\\n    null === workInProgressHook\\n      ? (currentlyRenderingFiber.memoizedState = workInProgressHook =\\n          nextCurrentHook)\\n      : (workInProgressHook = workInProgressHook.next = nextCurrentHook);\\n  }\\n  return workInProgressHook;\\n}\\nfunction createFunctionComponentUpdateQueue() {\\n  return { lastEffect: null, events: null, stores: null, memoCache: null };\\n}\\nfunction useThenable(thenable) {\\n  var index = thenableIndexCounter$1;\\n  thenableIndexCounter$1 += 1;\\n  null === thenableState$1 && (thenableState$1 = []);\\n  thenable = trackUsedThenable(thenableState$1, thenable, index);\\n  index = currentlyRenderingFiber;\\n  null ===\\n    (null === workInProgressHook\\n      ? index.memoizedState\\n      : workInProgressHook.next) &&\\n    ((index = index.alternate),\\n    (ReactSharedInternals.H =\\n      null === index || null === index.memoizedState\\n        ? HooksDispatcherOnMount\\n        : HooksDispatcherOnUpdate));\\n  return thenable;\\n}\\nfunction use(usable) {\\n  if (null !== usable && \"object\" === typeof usable) {\\n    if (\"function\" === typeof usable.then) return useThenable(usable);\\n    if (usable.$$typeof === REACT_CONTEXT_TYPE) return readContext(usable);\\n  }\\n  throw Error(formatProdErrorMessage(438, String(usable)));\\n}\\nfunction useMemoCache(size) {\\n  var memoCache = null,\\n    updateQueue = currentlyRenderingFiber.updateQueue;\\n  null !== updateQueue && (memoCache = updateQueue.memoCache);\\n  if (null == memoCache) {\\n    var current = currentlyRenderingFiber.alternate;\\n    null !== current &&\\n      ((current = current.updateQueue),\\n      null !== current &&\\n        ((current = current.memoCache),\\n        null != current &&\\n          (memoCache = {\\n            data: current.data.map(function (array) {\\n              return array.slice();\\n            }),\\n            index: 0\\n          })));\\n  }\\n  null == memoCache && (memoCache = { data: [], index: 0 });\\n  null === updateQueue &&\\n    ((updateQueue = createFunctionComponentUpdateQueue()),\\n    (currentlyRenderingFiber.updateQueue = updateQueue));\\n  updateQueue.memoCache = memoCache;\\n  updateQueue = memoCache.data[memoCache.index];\\n  if (void 0 === updateQueue)\\n    for (\\n      updateQueue = memoCache.data[memoCache.index] = Array(size), current = 0;\\n      current < size;\\n      current++\\n    )\\n      updateQueue[current] = REACT_MEMO_CACHE_SENTINEL;\\n  memoCache.index++;\\n  return updateQueue;\\n}\\nfunction basicStateReducer(state, action) {\\n  return \"function\" === typeof action ? action(state) : action;\\n}\\nfunction updateReducer(reducer) {\\n  var hook = updateWorkInProgressHook();\\n  return updateReducerImpl(hook, currentHook, reducer);\\n}\\nfunction updateReducerImpl(hook, current, reducer) {\\n  var queue = hook.queue;\\n  if (null === queue) throw Error(formatProdErrorMessage(311));\\n  queue.lastRenderedReducer = reducer;\\n  var baseQueue = hook.baseQueue,\\n    pendingQueue = queue.pending;\\n  if (null !== pendingQueue) {\\n    if (null !== baseQueue) {\\n      var baseFirst = baseQueue.next;\\n      baseQueue.next = pendingQueue.next;\\n      pendingQueue.next = baseFirst;\\n    }\\n    current.baseQueue = baseQueue = pendingQueue;\\n    queue.pending = null;\\n  }\\n  pendingQueue = hook.baseState;\\n  if (null === baseQueue) hook.memoizedState = pendingQueue;\\n  else {\\n    current = baseQueue.next;\\n    var newBaseQueueFirst = (baseFirst = null),\\n      newBaseQueueLast = null,\\n      update = current,\\n      didReadFromEntangledAsyncAction$32 = !1;\\n    do {\\n      var updateLane = update.lane & -536870913;\\n      if (\\n        updateLane !== update.lane\\n          ? (workInProgressRootRenderLanes & updateLane) === updateLane\\n          : (renderLanes & updateLane) === updateLane\\n      ) {\\n        var revertLane = update.revertLane;\\n        if (0 === revertLane)\\n          null !== newBaseQueueLast &&\\n            (newBaseQueueLast = newBaseQueueLast.next =\\n              {\\n                lane: 0,\\n                revertLane: 0,\\n                action: update.action,\\n                hasEagerState: update.hasEagerState,\\n                eagerState: update.eagerState,\\n                next: null\\n              }),\\n            updateLane === currentEntangledLane &&\\n              (didReadFromEntangledAsyncAction$32 = !0);\\n        else if ((renderLanes & revertLane) === revertLane) {\\n          update = update.next;\\n          revertLane === currentEntangledLane &&\\n            (didReadFromEntangledAsyncAction$32 = !0);\\n          continue;\\n        } else\\n          (updateLane = {\\n            lane: 0,\\n            revertLane: update.revertLane,\\n            action: update.action,\\n            hasEagerState: update.hasEagerState,\\n            eagerState: update.eagerState,\\n            next: null\\n          }),\\n            null === newBaseQueueLast\\n              ? ((newBaseQueueFirst = newBaseQueueLast = updateLane),\\n                (baseFirst = pendingQueue))\\n              : (newBaseQueueLast = newBaseQueueLast.next = updateLane),\\n            (currentlyRenderingFiber.lanes |= revertLane),\\n            (workInProgressRootSkippedLanes |= revertLane);\\n        updateLane = update.action;\\n        shouldDoubleInvokeUserFnsInHooksDEV &&\\n          reducer(pendingQueue, updateLane);\\n        pendingQueue = update.hasEagerState\\n          ? update.eagerState\\n          : reducer(pendingQueue, updateLane);\\n      } else\\n        (revertLane = {\\n          lane: updateLane,\\n          revertLane: update.revertLane,\\n          action: update.action,\\n          hasEagerState: update.hasEagerState,\\n          eagerState: update.eagerState,\\n          next: null\\n        }),\\n          null === newBaseQueueLast\\n            ? ((newBaseQueueFirst = newBaseQueueLast = revertLane),\\n              (baseFirst = pendingQueue))\\n            : (newBaseQueueLast = newBaseQueueLast.next = revertLane),\\n          (currentlyRenderingFiber.lanes |= updateLane),\\n          (workInProgressRootSkippedLanes |= updateLane);\\n      update = update.next;\\n    } while (null !== update && update !== current);\\n    null === newBaseQueueLast\\n      ? (baseFirst = pendingQueue)\\n      : (newBaseQueueLast.next = newBaseQueueFirst);\\n    if (\\n      !objectIs(pendingQueue, hook.memoizedState) &&\\n      ((didReceiveUpdate = !0),\\n      didReadFromEntangledAsyncAction$32 &&\\n        ((reducer = currentEntangledActionThenable), null !== reducer))\\n    )\\n      throw reducer;\\n    hook.memoizedState = pendingQueue;\\n    hook.baseState = baseFirst;\\n    hook.baseQueue = newBaseQueueLast;\\n    queue.lastRenderedState = pendingQueue;\\n  }\\n  null === baseQueue && (queue.lanes = 0);\\n  return [hook.memoizedState, queue.dispatch];\\n}\\nfunction rerenderReducer(reducer) {\\n  var hook = updateWorkInProgressHook(),\\n    queue = hook.queue;\\n  if (null === queue) throw Error(formatProdErrorMessage(311));\\n  queue.lastRenderedReducer = reducer;\\n  var dispatch = queue.dispatch,\\n    lastRenderPhaseUpdate = queue.pending,\\n    newState = hook.memoizedState;\\n  if (null !== lastRenderPhaseUpdate) {\\n    queue.pending = null;\\n    var update = (lastRenderPhaseUpdate = lastRenderPhaseUpdate.next);\\n    do (newState = reducer(newState, update.action)), (update = update.next);\\n    while (update !== lastRenderPhaseUpdate);\\n    objectIs(newState, hook.memoizedState) || (didReceiveUpdate = !0);\\n    hook.memoizedState = newState;\\n    null === hook.baseQueue && (hook.baseState = newState);\\n    queue.lastRenderedState = newState;\\n  }\\n  return [newState, dispatch];\\n}\\nfunction updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {\\n  var fiber = currentlyRenderingFiber,\\n    hook = updateWorkInProgressHook(),\\n    isHydrating$jscomp$0 = isHydrating;\\n  if (isHydrating$jscomp$0) {\\n    if (void 0 === getServerSnapshot) throw Error(formatProdErrorMessage(407));\\n    getServerSnapshot = getServerSnapshot();\\n  } else getServerSnapshot = getSnapshot();\\n  var snapshotChanged = !objectIs(\\n    (currentHook || hook).memoizedState,\\n    getServerSnapshot\\n  );\\n  snapshotChanged &&\\n    ((hook.memoizedState = getServerSnapshot), (didReceiveUpdate = !0));\\n  hook = hook.queue;\\n  var create = subscribeToStore.bind(null, fiber, hook, subscribe);\\n  updateEffectImpl(2048, 8, create, [subscribe]);\\n  if (\\n    hook.getSnapshot !== getSnapshot ||\\n    snapshotChanged ||\\n    (null !== workInProgressHook && workInProgressHook.memoizedState.tag & 1)\\n  ) {\\n    fiber.flags |= 2048;\\n    pushSimpleEffect(\\n      9,\\n      createEffectInstance(),\\n      updateStoreInstance.bind(\\n        null,\\n        fiber,\\n        hook,\\n        getServerSnapshot,\\n        getSnapshot\\n      ),\\n      null\\n    );\\n    if (null === workInProgressRoot) throw Error(formatProdErrorMessage(349));\\n    isHydrating$jscomp$0 ||\\n      0 !== (renderLanes & 124) ||\\n      pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);\\n  }\\n  return getServerSnapshot;\\n}\\nfunction pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {\\n  fiber.flags |= 16384;\\n  fiber = { getSnapshot: getSnapshot, value: renderedSnapshot };\\n  getSnapshot = currentlyRenderingFiber.updateQueue;\\n  null === getSnapshot\\n    ? ((getSnapshot = createFunctionComponentUpdateQueue()),\\n      (currentlyRenderingFiber.updateQueue = getSnapshot),\\n      (getSnapshot.stores = [fiber]))\\n    : ((renderedSnapshot = getSnapshot.stores),\\n      null === renderedSnapshot\\n        ? (getSnapshot.stores = [fiber])\\n        : renderedSnapshot.push(fiber));\\n}\\nfunction updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {\\n  inst.value = nextSnapshot;\\n  inst.getSnapshot = getSnapshot;\\n  checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);\\n}\\nfunction subscribeToStore(fiber, inst, subscribe) {\\n  return subscribe(function () {\\n    checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);\\n  });\\n}\\nfunction checkIfSnapshotChanged(inst) {\\n  var latestGetSnapshot = inst.getSnapshot;\\n  inst = inst.value;\\n  try {\\n    var nextValue = latestGetSnapshot();\\n    return !objectIs(inst, nextValue);\\n  } catch (error) {\\n    return !0;\\n  }\\n}\\nfunction forceStoreRerender(fiber) {\\n  var root = enqueueConcurrentRenderForLane(fiber, 2);\\n  null !== root && scheduleUpdateOnFiber(root, fiber, 2);\\n}\\nfunction mountStateImpl(initialState) {\\n  var hook = mountWorkInProgressHook();\\n  if (\"function\" === typeof initialState) {\\n    var initialStateInitializer = initialState;\\n    initialState = initialStateInitializer();\\n    if (shouldDoubleInvokeUserFnsInHooksDEV) {\\n      setIsStrictModeForDevtools(!0);\\n      try {\\n        initialStateInitializer();\\n      } finally {\\n        setIsStrictModeForDevtools(!1);\\n      }\\n    }\\n  }\\n  hook.memoizedState = hook.baseState = initialState;\\n  hook.queue = {\\n    pending: null,\\n    lanes: 0,\\n    dispatch: null,\\n    lastRenderedReducer: basicStateReducer,\\n    lastRenderedState: initialState\\n  };\\n  return hook;\\n}\\nfunction updateOptimisticImpl(hook, current, passthrough, reducer) {\\n  hook.baseState = passthrough;\\n  return updateReducerImpl(\\n    hook,\\n    currentHook,\\n    \"function\" === typeof reducer ? reducer : basicStateReducer\\n  );\\n}\\nfunction dispatchActionState(\\n  fiber,\\n  actionQueue,\\n  setPendingState,\\n  setState,\\n  payload\\n) {\\n  if (isRenderPhaseUpdate(fiber)) throw Error(formatProdErrorMessage(485));\\n  fiber = actionQueue.action;\\n  if (null !== fiber) {\\n    var actionNode = {\\n      payload: payload,\\n      action: fiber,\\n      next: null,\\n      isTransition: !0,\\n      status: \"pending\",\\n      value: null,\\n      reason: null,\\n      listeners: [],\\n      then: function (listener) {\\n        actionNode.listeners.push(listener);\\n      }\\n    };\\n    null !== ReactSharedInternals.T\\n      ? setPendingState(!0)\\n      : (actionNode.isTransition = !1);\\n    setState(actionNode);\\n    setPendingState = actionQueue.pending;\\n    null === setPendingState\\n      ? ((actionNode.next = actionQueue.pending = actionNode),\\n        runActionStateAction(actionQueue, actionNode))\\n      : ((actionNode.next = setPendingState.next),\\n        (actionQueue.pending = setPendingState.next = actionNode));\\n  }\\n}\\nfunction runActionStateAction(actionQueue, node) {\\n  var action = node.action,\\n    payload = node.payload,\\n    prevState = actionQueue.state;\\n  if (node.isTransition) {\\n    var prevTransition = ReactSharedInternals.T,\\n      currentTransition = {};\\n    ReactSharedInternals.T = currentTransition;\\n    try {\\n      var returnValue = action(prevState, payload),\\n        onStartTransitionFinish = ReactSharedInternals.S;\\n      null !== onStartTransitionFinish &&\\n        onStartTransitionFinish(currentTransition, returnValue);\\n      handleActionReturnValue(actionQueue, node, returnValue);\\n    } catch (error) {\\n      onActionError(actionQueue, node, error);\\n    } finally {\\n      ReactSharedInternals.T = prevTransition;\\n    }\\n  } else\\n    try {\\n      (prevTransition = action(prevState, payload)),\\n        handleActionReturnValue(actionQueue, node, prevTransition);\\n    } catch (error$38) {\\n      onActionError(actionQueue, node, error$38);\\n    }\\n}\\nfunction handleActionReturnValue(actionQueue, node, returnValue) {\\n  null !== returnValue &&\\n  \"object\" === typeof returnValue &&\\n  \"function\" === typeof returnValue.then\\n    ? returnValue.then(\\n        function (nextState) {\\n          onActionSuccess(actionQueue, node, nextState);\\n        },\\n        function (error) {\\n          return onActionError(actionQueue, node, error);\\n        }\\n      )\\n    : onActionSuccess(actionQueue, node, returnValue);\\n}\\nfunction onActionSuccess(actionQueue, actionNode, nextState) {\\n  actionNode.status = \"fulfilled\";\\n  actionNode.value = nextState;\\n  notifyActionListeners(actionNode);\\n  actionQueue.state = nextState;\\n  actionNode = actionQueue.pending;\\n  null !== actionNode &&\\n    ((nextState = actionNode.next),\\n    nextState === actionNode\\n      ? (actionQueue.pending = null)\\n      : ((nextState = nextState.next),\\n        (actionNode.next = nextState),\\n        runActionStateAction(actionQueue, nextState)));\\n}\\nfunction onActionError(actionQueue, actionNode, error) {\\n  var last = actionQueue.pending;\\n  actionQueue.pending = null;\\n  if (null !== last) {\\n    last = last.next;\\n    do\\n      (actionNode.status = \"rejected\"),\\n        (actionNode.reason = error),\\n        notifyActionListeners(actionNode),\\n        (actionNode = actionNode.next);\\n    while (actionNode !== last);\\n  }\\n  actionQueue.action = null;\\n}\\nfunction notifyActionListeners(actionNode) {\\n  actionNode = actionNode.listeners;\\n  for (var i = 0; i < actionNode.length; i++) (0, actionNode[i])();\\n}\\nfunction actionStateReducer(oldState, newState) {\\n  return newState;\\n}\\nfunction mountActionState(action, initialStateProp) {\\n  if (isHydrating) {\\n    var ssrFormState = workInProgressRoot.formState;\\n    if (null !== ssrFormState) {\\n      a: {\\n        var JSCompiler_inline_result = currentlyRenderingFiber;\\n        if (isHydrating) {\\n          if (nextHydratableInstance) {\\n            b: {\\n              var JSCompiler_inline_result$jscomp$0 = nextHydratableInstance;\\n              for (\\n                var inRootOrSingleton = rootOrSingletonContext;\\n                8 !== JSCompiler_inline_result$jscomp$0.nodeType;\\n\\n              ) {\\n                if (!inRootOrSingleton) {\\n                  JSCompiler_inline_result$jscomp$0 = null;\\n                  break b;\\n                }\\n                JSCompiler_inline_result$jscomp$0 = getNextHydratable(\\n                  JSCompiler_inline_result$jscomp$0.nextSibling\\n                );\\n                if (null === JSCompiler_inline_result$jscomp$0) {\\n                  JSCompiler_inline_result$jscomp$0 = null;\\n                  break b;\\n                }\\n              }\\n              inRootOrSingleton = JSCompiler_inline_result$jscomp$0.data;\\n              JSCompiler_inline_result$jscomp$0 =\\n                \"F!\" === inRootOrSingleton || \"F\" === inRootOrSingleton\\n                  ? JSCompiler_inline_result$jscomp$0\\n                  : null;\\n            }\\n            if (JSCompiler_inline_result$jscomp$0) {\\n              nextHydratableInstance = getNextHydratable(\\n                JSCompiler_inline_result$jscomp$0.nextSibling\\n              );\\n              JSCompiler_inline_result =\\n                \"F!\" === JSCompiler_inline_result$jscomp$0.data;\\n              break a;\\n            }\\n          }\\n          throwOnHydrationMismatch(JSCompiler_inline_result);\\n        }\\n        JSCompiler_inline_result = !1;\\n      }\\n      JSCompiler_inline_result && (initialStateProp = ssrFormState[0]);\\n    }\\n  }\\n  ssrFormState = mountWorkInProgressHook();\\n  ssrFormState.memoizedState = ssrFormState.baseState = initialStateProp;\\n  JSCompiler_inline_result = {\\n    pending: null,\\n    lanes: 0,\\n    dispatch: null,\\n    lastRenderedReducer: actionStateReducer,\\n    lastRenderedState: initialStateProp\\n  };\\n  ssrFormState.queue = JSCompiler_inline_result;\\n  ssrFormState = dispatchSetState.bind(\\n    null,\\n    currentlyRenderingFiber,\\n    JSCompiler_inline_result\\n  );\\n  JSCompiler_inline_result.dispatch = ssrFormState;\\n  JSCompiler_inline_result = mountStateImpl(!1);\\n  inRootOrSingleton = dispatchOptimisticSetState.bind(\\n    null,\\n    currentlyRenderingFiber,\\n    !1,\\n    JSCompiler_inline_result.queue\\n  );\\n  JSCompiler_inline_result = mountWorkInProgressHook();\\n  JSCompiler_inline_result$jscomp$0 = {\\n    state: initialStateProp,\\n    dispatch: null,\\n    action: action,\\n    pending: null\\n  };\\n  JSCompiler_inline_result.queue = JSCompiler_inline_result$jscomp$0;\\n  ssrFormState = dispatchActionState.bind(\\n    null,\\n    currentlyRenderingFiber,\\n    JSCompiler_inline_result$jscomp$0,\\n    inRootOrSingleton,\\n    ssrFormState\\n  );\\n  JSCompiler_inline_result$jscomp$0.dispatch = ssrFormState;\\n  JSCompiler_inline_result.memoizedState = action;\\n  return [initialStateProp, ssrFormState, !1];\\n}\\nfunction updateActionState(action) {\\n  var stateHook = updateWorkInProgressHook();\\n  return updateActionStateImpl(stateHook, currentHook, action);\\n}\\nfunction updateActionStateImpl(stateHook, currentStateHook, action) {\\n  currentStateHook = updateReducerImpl(\\n    stateHook,\\n    currentStateHook,\\n    actionStateReducer\\n  )[0];\\n  stateHook = updateReducer(basicStateReducer)[0];\\n  if (\\n    \"object\" === typeof currentStateHook &&\\n    null !== currentStateHook &&\\n    \"function\" === typeof currentStateHook.then\\n  )\\n    try {\\n      var state = useThenable(currentStateHook);\\n    } catch (x) {\\n      if (x === SuspenseException) throw SuspenseActionException;\\n      throw x;\\n    }\\n  else state = currentStateHook;\\n  currentStateHook = updateWorkInProgressHook();\\n  var actionQueue = currentStateHook.queue,\\n    dispatch = actionQueue.dispatch;\\n  action !== currentStateHook.memoizedState &&\\n    ((currentlyRenderingFiber.flags |= 2048),\\n    pushSimpleEffect(\\n      9,\\n      createEffectInstance(),\\n      actionStateActionEffect.bind(null, actionQueue, action),\\n      null\\n    ));\\n  return [state, dispatch, stateHook];\\n}\\nfunction actionStateActionEffect(actionQueue, action) {\\n  actionQueue.action = action;\\n}\\nfunction rerenderActionState(action) {\\n  var stateHook = updateWorkInProgressHook(),\\n    currentStateHook = currentHook;\\n  if (null !== currentStateHook)\\n    return updateActionStateImpl(stateHook, currentStateHook, action);\\n  updateWorkInProgressHook();\\n  stateHook = stateHook.memoizedState;\\n  currentStateHook = updateWorkInProgressHook();\\n  var dispatch = currentStateHook.queue.dispatch;\\n  currentStateHook.memoizedState = action;\\n  return [stateHook, dispatch, !1];\\n}\\nfunction pushSimpleEffect(tag, inst, create, createDeps) {\\n  tag = { tag: tag, create: create, deps: createDeps, inst: inst, next: null };\\n  inst = currentlyRenderingFiber.updateQueue;\\n  null === inst &&\\n    ((inst = createFunctionComponentUpdateQueue()),\\n    (currentlyRenderingFiber.updateQueue = inst));\\n  create = inst.lastEffect;\\n  null === create\\n    ? (inst.lastEffect = tag.next = tag)\\n    : ((createDeps = create.next),\\n      (create.next = tag),\\n      (tag.next = createDeps),\\n      (inst.lastEffect = tag));\\n  return tag;\\n}\\nfunction createEffectInstance() {\\n  return { destroy: void 0, resource: void 0 };\\n}\\nfunction updateRef() {\\n  return updateWorkInProgressHook().memoizedState;\\n}\\nfunction mountEffectImpl(fiberFlags, hookFlags, create, createDeps) {\\n  var hook = mountWorkInProgressHook();\\n  createDeps = void 0 === createDeps ? null : createDeps;\\n  currentlyRenderingFiber.flags |= fiberFlags;\\n  hook.memoizedState = pushSimpleEffect(\\n    1 | hookFlags,\\n    createEffectInstance(),\\n    create,\\n    createDeps\\n  );\\n}\\nfunction updateEffectImpl(fiberFlags, hookFlags, create, deps) {\\n  var hook = updateWorkInProgressHook();\\n  deps = void 0 === deps ? null : deps;\\n  var inst = hook.memoizedState.inst;\\n  null !== currentHook &&\\n  null !== deps &&\\n  areHookInputsEqual(deps, currentHook.memoizedState.deps)\\n    ? (hook.memoizedState = pushSimpleEffect(hookFlags, inst, create, deps))\\n    : ((currentlyRenderingFiber.flags |= fiberFlags),\\n      (hook.memoizedState = pushSimpleEffect(\\n        1 | hookFlags,\\n        inst,\\n        create,\\n        deps\\n      )));\\n}\\nfunction mountEffect(create, createDeps) {\\n  mountEffectImpl(8390656, 8, create, createDeps);\\n}\\nfunction updateEffect(create, createDeps) {\\n  updateEffectImpl(2048, 8, create, createDeps);\\n}\\nfunction updateInsertionEffect(create, deps) {\\n  return updateEffectImpl(4, 2, create, deps);\\n}\\nfunction updateLayoutEffect(create, deps) {\\n  return updateEffectImpl(4, 4, create, deps);\\n}\\nfunction imperativeHandleEffect(create, ref) {\\n  if (\"function\" === typeof ref) {\\n    create = create();\\n    var refCleanup = ref(create);\\n    return function () {\\n      \"function\" === typeof refCleanup ? refCleanup() : ref(null);\\n    };\\n  }\\n  if (null !== ref && void 0 !== ref)\\n    return (\\n      (create = create()),\\n      (ref.current = create),\\n      function () {\\n        ref.current = null;\\n      }\\n    );\\n}\\nfunction updateImperativeHandle(ref, create, deps) {\\n  deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;\\n  updateEffectImpl(4, 4, imperativeHandleEffect.bind(null, create, ref), deps);\\n}\\nfunction mountDebugValue() {}\\nfunction updateCallback(callback, deps) {\\n  var hook = updateWorkInProgressHook();\\n  deps = void 0 === deps ? null : deps;\\n  var prevState = hook.memoizedState;\\n  if (null !== deps && areHookInputsEqual(deps, prevState[1]))\\n    return prevState[0];\\n  hook.memoizedState = [callback, deps];\\n  return callback;\\n}\\nfunction updateMemo(nextCreate, deps) {\\n  var hook = updateWorkInProgressHook();\\n  deps = void 0 === deps ? null : deps;\\n  var prevState = hook.memoizedState;\\n  if (null !== deps && areHookInputsEqual(deps, prevState[1]))\\n    return prevState[0];\\n  prevState = nextCreate();\\n  if (shouldDoubleInvokeUserFnsInHooksDEV) {\\n    setIsStrictModeForDevtools(!0);\\n    try {\\n      nextCreate();\\n    } finally {\\n      setIsStrictModeForDevtools(!1);\\n    }\\n  }\\n  hook.memoizedState = [prevState, deps];\\n  return prevState;\\n}\\nfunction mountDeferredValueImpl(hook, value, initialValue) {\\n  if (void 0 === initialValue || 0 !== (renderLanes & 1073741824))\\n    return (hook.memoizedState = value);\\n  hook.memoizedState = initialValue;\\n  hook = requestDeferredLane();\\n  currentlyRenderingFiber.lanes |= hook;\\n  workInProgressRootSkippedLanes |= hook;\\n  return initialValue;\\n}\\nfunction updateDeferredValueImpl(hook, prevValue, value, initialValue) {\\n  if (objectIs(value, prevValue)) return value;\\n  if (null !== currentTreeHiddenStackCursor.current)\\n    return (\\n      (hook = mountDeferredValueImpl(hook, value, initialValue)),\\n      objectIs(hook, prevValue) || (didReceiveUpdate = !0),\\n      hook\\n    );\\n  if (0 === (renderLanes & 42))\\n    return (didReceiveUpdate = !0), (hook.memoizedState = value);\\n  hook = requestDeferredLane();\\n  currentlyRenderingFiber.lanes |= hook;\\n  workInProgressRootSkippedLanes |= hook;\\n  return prevValue;\\n}\\nfunction startTransition(fiber, queue, pendingState, finishedState, callback) {\\n  var previousPriority = ReactDOMSharedInternals.p;\\n  ReactDOMSharedInternals.p =\\n    0 !== previousPriority && 8 > previousPriority ? previousPriority : 8;\\n  var prevTransition = ReactSharedInternals.T,\\n    currentTransition = {};\\n  ReactSharedInternals.T = currentTransition;\\n  dispatchOptimisticSetState(fiber, !1, queue, pendingState);\\n  try {\\n    var returnValue = callback(),\\n      onStartTransitionFinish = ReactSharedInternals.S;\\n    null !== onStartTransitionFinish &&\\n      onStartTransitionFinish(currentTransition, returnValue);\\n    if (\\n      null !== returnValue &&\\n      \"object\" === typeof returnValue &&\\n      \"function\" === typeof returnValue.then\\n    ) {\\n      var thenableForFinishedState = chainThenableValue(\\n        returnValue,\\n        finishedState\\n      );\\n      dispatchSetStateInternal(\\n        fiber,\\n        queue,\\n        thenableForFinishedState,\\n        requestUpdateLane(fiber)\\n      );\\n    } else\\n      dispatchSetStateInternal(\\n        fiber,\\n        queue,\\n        finishedState,\\n        requestUpdateLane(fiber)\\n      );\\n  } catch (error) {\\n    dispatchSetStateInternal(\\n      fiber,\\n      queue,\\n      { then: function () {}, status: \"rejected\", reason: error },\\n      requestUpdateLane()\\n    );\\n  } finally {\\n    (ReactDOMSharedInternals.p = previousPriority),\\n      (ReactSharedInternals.T = prevTransition);\\n  }\\n}\\nfunction noop$2() {}\\nfunction startHostTransition(formFiber, pendingState, action, formData) {\\n  if (5 !== formFiber.tag) throw Error(formatProdErrorMessage(476));\\n  var queue = ensureFormComponentIsStateful(formFiber).queue;\\n  startTransition(\\n    formFiber,\\n    queue,\\n    pendingState,\\n    sharedNotPendingObject,\\n    null === action\\n      ? noop$2\\n      : function () {\\n          requestFormReset$1(formFiber);\\n          return action(formData);\\n        }\\n  );\\n}\\nfunction ensureFormComponentIsStateful(formFiber) {\\n  var existingStateHook = formFiber.memoizedState;\\n  if (null !== existingStateHook) return existingStateHook;\\n  existingStateHook = {\\n    memoizedState: sharedNotPendingObject,\\n    baseState: sharedNotPendingObject,\\n    baseQueue: null,\\n    queue: {\\n      pending: null,\\n      lanes: 0,\\n      dispatch: null,\\n      lastRenderedReducer: basicStateReducer,\\n      lastRenderedState: sharedNotPendingObject\\n    },\\n    next: null\\n  };\\n  var initialResetState = {};\\n  existingStateHook.next = {\\n    memoizedState: initialResetState,\\n    baseState: initialResetState,\\n    baseQueue: null,\\n    queue: {\\n      pending: null,\\n      lanes: 0,\\n      dispatch: null,\\n      lastRenderedReducer: basicStateReducer,\\n      lastRenderedState: initialResetState\\n    },\\n    next: null\\n  };\\n  formFiber.memoizedState = existingStateHook;\\n  formFiber = formFiber.alternate;\\n  null !== formFiber && (formFiber.memoizedState = existingStateHook);\\n  return existingStateHook;\\n}\\nfunction requestFormReset$1(formFiber) {\\n  var resetStateQueue = ensureFormComponentIsStateful(formFiber).next.queue;\\n  dispatchSetStateInternal(formFiber, resetStateQueue, {}, requestUpdateLane());\\n}\\nfunction useHostTransitionStatus() {\\n  return readContext(HostTransitionContext);\\n}\\nfunction updateId() {\\n  return updateWorkInProgressHook().memoizedState;\\n}\\nfunction updateRefresh() {\\n  return updateWorkInProgressHook().memoizedState;\\n}\\nfunction refreshCache(fiber) {\\n  for (var provider = fiber.return; null !== provider; ) {\\n    switch (provider.tag) {\\n      case 24:\\n      case 3:\\n        var lane = requestUpdateLane();\\n        fiber = createUpdate(lane);\\n        var root$41 = enqueueUpdate(provider, fiber, lane);\\n        null !== root$41 &&\\n          (scheduleUpdateOnFiber(root$41, provider, lane),\\n          entangleTransitions(root$41, provider, lane));\\n        provider = { cache: createCache() };\\n        fiber.payload = provider;\\n        return;\\n    }\\n    provider = provider.return;\\n  }\\n}\\nfunction dispatchReducerAction(fiber, queue, action) {\\n  var lane = requestUpdateLane();\\n  action = {\\n    lane: lane,\\n    revertLane: 0,\\n    action: action,\\n    hasEagerState: !1,\\n    eagerState: null,\\n    next: null\\n  };\\n  isRenderPhaseUpdate(fiber)\\n    ? enqueueRenderPhaseUpdate(queue, action)\\n    : ((action = enqueueConcurrentHookUpdate(fiber, queue, action, lane)),\\n      null !== action &&\\n        (scheduleUpdateOnFiber(action, fiber, lane),\\n        entangleTransitionUpdate(action, queue, lane)));\\n}\\nfunction dispatchSetState(fiber, queue, action) {\\n  var lane = requestUpdateLane();\\n  dispatchSetStateInternal(fiber, queue, action, lane);\\n}\\nfunction dispatchSetStateInternal(fiber, queue, action, lane) {\\n  var update = {\\n    lane: lane,\\n    revertLane: 0,\\n    action: action,\\n    hasEagerState: !1,\\n    eagerState: null,\\n    next: null\\n  };\\n  if (isRenderPhaseUpdate(fiber)) enqueueRenderPhaseUpdate(queue, update);\\n  else {\\n    var alternate = fiber.alternate;\\n    if (\\n      0 === fiber.lanes &&\\n      (null === alternate || 0 === alternate.lanes) &&\\n      ((alternate = queue.lastRenderedReducer), null !== alternate)\\n    )\\n      try {\\n        var currentState = queue.lastRenderedState,\\n          eagerState = alternate(currentState, action);\\n        update.hasEagerState = !0;\\n        update.eagerState = eagerState;\\n        if (objectIs(eagerState, currentState))\\n          return (\\n            enqueueUpdate$1(fiber, queue, update, 0),\\n            null === workInProgressRoot && finishQueueingConcurrentUpdates(),\\n            !1\\n          );\\n      } catch (error) {\\n      } finally {\\n      }\\n    action = enqueueConcurrentHookUpdate(fiber, queue, update, lane);\\n    if (null !== action)\\n      return (\\n        scheduleUpdateOnFiber(action, fiber, lane),\\n        entangleTransitionUpdate(action, queue, lane),\\n        !0\\n      );\\n  }\\n  return !1;\\n}\\nfunction dispatchOptimisticSetState(fiber, throwIfDuringRender, queue, action) {\\n  action = {\\n    lane: 2,\\n    revertLane: requestTransitionLane(),\\n    action: action,\\n    hasEagerState: !1,\\n    eagerState: null,\\n    next: null\\n  };\\n  if (isRenderPhaseUpdate(fiber)) {\\n    if (throwIfDuringRender) throw Error(formatProdErrorMessage(479));\\n  } else\\n    (throwIfDuringRender = enqueueConcurrentHookUpdate(\\n      fiber,\\n      queue,\\n      action,\\n      2\\n    )),\\n      null !== throwIfDuringRender &&\\n        scheduleUpdateOnFiber(throwIfDuringRender, fiber, 2);\\n}\\nfunction isRenderPhaseUpdate(fiber) {\\n  var alternate = fiber.alternate;\\n  return (\\n    fiber === currentlyRenderingFiber ||\\n    (null !== alternate && alternate === currentlyRenderingFiber)\\n  );\\n}\\nfunction enqueueRenderPhaseUpdate(queue, update) {\\n  didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate =\\n    !0;\\n  var pending = queue.pending;\\n  null === pending\\n    ? (update.next = update)\\n    : ((update.next = pending.next), (pending.next = update));\\n  queue.pending = update;\\n}\\nfunction entangleTransitionUpdate(root, queue, lane) {\\n  if (0 !== (lane & 4194048)) {\\n    var queueLanes = queue.lanes;\\n    queueLanes &= root.pendingLanes;\\n    lane |= queueLanes;\\n    queue.lanes = lane;\\n    markRootEntangled(root, lane);\\n  }\\n}\\nvar ContextOnlyDispatcher = {\\n    readContext: readContext,\\n    use: use,\\n    useCallback: throwInvalidHookError,\\n    useContext: throwInvalidHookError,\\n    useEffect: throwInvalidHookError,\\n    useImperativeHandle: throwInvalidHookError,\\n    useLayoutEffect: throwInvalidHookError,\\n    useInsertionEffect: throwInvalidHookError,\\n    useMemo: throwInvalidHookError,\\n    useReducer: throwInvalidHookError,\\n    useRef: throwInvalidHookError,\\n    useState: throwInvalidHookError,\\n    useDebugValue: throwInvalidHookError,\\n    useDeferredValue: throwInvalidHookError,\\n    useTransition: throwInvalidHookError,\\n    useSyncExternalStore: throwInvalidHookError,\\n    useId: throwInvalidHookError,\\n    useHostTransitionStatus: throwInvalidHookError,\\n    useFormState: throwInvalidHookError,\\n    useActionState: throwInvalidHookError,\\n    useOptimistic: throwInvalidHookError,\\n    useMemoCache: throwInvalidHookError,\\n    useCacheRefresh: throwInvalidHookError\\n  },\\n  HooksDispatcherOnMount = {\\n    readContext: readContext,\\n    use: use,\\n    useCallback: function (callback, deps) {\\n      mountWorkInProgressHook().memoizedState = [\\n        callback,\\n        void 0 === deps ? null : deps\\n      ];\\n      return callback;\\n    },\\n    useContext: readContext,\\n    useEffect: mountEffect,\\n    useImperativeHandle: function (ref, create, deps) {\\n      deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;\\n      mountEffectImpl(\\n        4194308,\\n        4,\\n        imperativeHandleEffect.bind(null, create, ref),\\n        deps\\n      );\\n    },\\n    useLayoutEffect: function (create, deps) {\\n      return mountEffectImpl(4194308, 4, create, deps);\\n    },\\n    useInsertionEffect: function (create, deps) {\\n      mountEffectImpl(4, 2, create, deps);\\n    },\\n    useMemo: function (nextCreate, deps) {\\n      var hook = mountWorkInProgressHook();\\n      deps = void 0 === deps ? null : deps;\\n      var nextValue = nextCreate();\\n      if (shouldDoubleInvokeUserFnsInHooksDEV) {\\n        setIsStrictModeForDevtools(!0);\\n        try {\\n          nextCreate();\\n        } finally {\\n          setIsStrictModeForDevtools(!1);\\n        }\\n      }\\n      hook.memoizedState = [nextValue, deps];\\n      return nextValue;\\n    },\\n    useReducer: function (reducer, initialArg, init) {\\n      var hook = mountWorkInProgressHook();\\n      if (void 0 !== init) {\\n        var initialState = init(initialArg);\\n        if (shouldDoubleInvokeUserFnsInHooksDEV) {\\n          setIsStrictModeForDevtools(!0);\\n          try {\\n            init(initialArg);\\n          } finally {\\n            setIsStrictModeForDevtools(!1);\\n          }\\n        }\\n      } else initialState = initialArg;\\n      hook.memoizedState = hook.baseState = initialState;\\n      reducer = {\\n        pending: null,\\n        lanes: 0,\\n        dispatch: null,\\n        lastRenderedReducer: reducer,\\n        lastRenderedState: initialState\\n      };\\n      hook.queue = reducer;\\n      reducer = reducer.dispatch = dispatchReducerAction.bind(\\n        null,\\n        currentlyRenderingFiber,\\n        reducer\\n      );\\n      return [hook.memoizedState, reducer];\\n    },\\n    useRef: function (initialValue) {\\n      var hook = mountWorkInProgressHook();\\n      initialValue = { current: initialValue };\\n      return (hook.memoizedState = initialValue);\\n    },\\n    useState: function (initialState) {\\n      initialState = mountStateImpl(initialState);\\n      var queue = initialState.queue,\\n        dispatch = dispatchSetState.bind(null, currentlyRenderingFiber, queue);\\n      queue.dispatch = dispatch;\\n      return [initialState.memoizedState, dispatch];\\n    },\\n    useDebugValue: mountDebugValue,\\n    useDeferredValue: function (value, initialValue) {\\n      var hook = mountWorkInProgressHook();\\n      return mountDeferredValueImpl(hook, value, initialValue);\\n    },\\n    useTransition: function () {\\n      var stateHook = mountStateImpl(!1);\\n      stateHook = startTransition.bind(\\n        null,\\n        currentlyRenderingFiber,\\n        stateHook.queue,\\n        !0,\\n        !1\\n      );\\n      mountWorkInProgressHook().memoizedState = stateHook;\\n      return [!1, stateHook];\\n    },\\n    useSyncExternalStore: function (subscribe, getSnapshot, getServerSnapshot) {\\n      var fiber = currentlyRenderingFiber,\\n        hook = mountWorkInProgressHook();\\n      if (isHydrating) {\\n        if (void 0 === getServerSnapshot)\\n          throw Error(formatProdErrorMessage(407));\\n        getServerSnapshot = getServerSnapshot();\\n      } else {\\n        getServerSnapshot = getSnapshot();\\n        if (null === workInProgressRoot)\\n          throw Error(formatProdErrorMessage(349));\\n        0 !== (workInProgressRootRenderLanes & 124) ||\\n          pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);\\n      }\\n      hook.memoizedState = getServerSnapshot;\\n      var inst = { value: getServerSnapshot, getSnapshot: getSnapshot };\\n      hook.queue = inst;\\n      mountEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [\\n        subscribe\\n      ]);\\n      fiber.flags |= 2048;\\n      pushSimpleEffect(\\n        9,\\n        createEffectInstance(),\\n        updateStoreInstance.bind(\\n          null,\\n          fiber,\\n          inst,\\n          getServerSnapshot,\\n          getSnapshot\\n        ),\\n        null\\n      );\\n      return getServerSnapshot;\\n    },\\n    useId: function () {\\n      var hook = mountWorkInProgressHook(),\\n        identifierPrefix = workInProgressRoot.identifierPrefix;\\n      if (isHydrating) {\\n        var JSCompiler_inline_result = treeContextOverflow;\\n        var idWithLeadingBit = treeContextId;\\n        JSCompiler_inline_result =\\n          (\\n            idWithLeadingBit & ~(1 << (32 - clz32(idWithLeadingBit) - 1))\\n          ).toString(32) + JSCompiler_inline_result;\\n        identifierPrefix =\\n          \"\\\\u00ab\" + identifierPrefix + \"R\" + JSCompiler_inline_result;\\n        JSCompiler_inline_result = localIdCounter++;\\n        0 < JSCompiler_inline_result &&\\n          (identifierPrefix += \"H\" + JSCompiler_inline_result.toString(32));\\n        identifierPrefix += \"\\\\u00bb\";\\n      } else\\n        (JSCompiler_inline_result = globalClientIdCounter++),\\n          (identifierPrefix =\\n            \"\\\\u00ab\" +\\n            identifierPrefix +\\n            \"r\" +\\n            JSCompiler_inline_result.toString(32) +\\n            \"\\\\u00bb\");\\n      return (hook.memoizedState = identifierPrefix);\\n    },\\n    useHostTransitionStatus: useHostTransitionStatus,\\n    useFormState: mountActionState,\\n    useActionState: mountActionState,\\n    useOptimistic: function (passthrough) {\\n      var hook = mountWorkInProgressHook();\\n      hook.memoizedState = hook.baseState = passthrough;\\n      var queue = {\\n        pending: null,\\n        lanes: 0,\\n        dispatch: null,\\n        lastRenderedReducer: null,\\n        lastRenderedState: null\\n      };\\n      hook.queue = queue;\\n      hook = dispatchOptimisticSetState.bind(\\n        null,\\n        currentlyRenderingFiber,\\n        !0,\\n        queue\\n      );\\n      queue.dispatch = hook;\\n      return [passthrough, hook];\\n    },\\n    useMemoCache: useMemoCache,\\n    useCacheRefresh: function () {\\n      return (mountWorkInProgressHook().memoizedState = refreshCache.bind(\\n        null,\\n        currentlyRenderingFiber\\n      ));\\n    }\\n  },\\n  HooksDispatcherOnUpdate = {\\n    readContext: readContext,\\n    use: use,\\n    useCallback: updateCallback,\\n    useContext: readContext,\\n    useEffect: updateEffect,\\n    useImperativeHandle: updateImperativeHandle,\\n    useInsertionEffect: updateInsertionEffect,\\n    useLayoutEffect: updateLayoutEffect,\\n    useMemo: updateMemo,\\n    useReducer: updateReducer,\\n    useRef: updateRef,\\n    useState: function () {\\n      return updateReducer(basicStateReducer);\\n    },\\n    useDebugValue: mountDebugValue,\\n    useDeferredValue: function (value, initialValue) {\\n      var hook = updateWorkInProgressHook();\\n      return updateDeferredValueImpl(\\n        hook,\\n        currentHook.memoizedState,\\n        value,\\n        initialValue\\n      );\\n    },\\n    useTransition: function () {\\n      var booleanOrThenable = updateReducer(basicStateReducer)[0],\\n        start = updateWorkInProgressHook().memoizedState;\\n      return [\\n        \"boolean\" === typeof booleanOrThenable\\n          ? booleanOrThenable\\n          : useThenable(booleanOrThenable),\\n        start\\n      ];\\n    },\\n    useSyncExternalStore: updateSyncExternalStore,\\n    useId: updateId,\\n    useHostTransitionStatus: useHostTransitionStatus,\\n    useFormState: updateActionState,\\n    useActionState: updateActionState,\\n    useOptimistic: function (passthrough, reducer) {\\n      var hook = updateWorkInProgressHook();\\n      return updateOptimisticImpl(hook, currentHook, passthrough, reducer);\\n    },\\n    useMemoCache: useMemoCache,\\n    useCacheRefresh: updateRefresh\\n  },\\n  HooksDispatcherOnRerender = {\\n    readContext: readContext,\\n    use: use,\\n    useCallback: updateCallback,\\n    useContext: readContext,\\n    useEffect: updateEffect,\\n    useImperativeHandle: updateImperativeHandle,\\n    useInsertionEffect: updateInsertionEffect,\\n    useLayoutEffect: updateLayoutEffect,\\n    useMemo: updateMemo,\\n    useReducer: rerenderReducer,\\n    useRef: updateRef,\\n    useState: function () {\\n      return rerenderReducer(basicStateReducer);\\n    },\\n    useDebugValue: mountDebugValue,\\n    useDeferredValue: function (value, initialValue) {\\n      var hook = updateWorkInProgressHook();\\n      return null === currentHook\\n        ? mountDeferredValueImpl(hook, value, initialValue)\\n        : updateDeferredValueImpl(\\n            hook,\\n            currentHook.memoizedState,\\n            value,\\n            initialValue\\n          );\\n    },\\n    useTransition: function () {\\n      var booleanOrThenable = rerenderReducer(basicStateReducer)[0],\\n        start = updateWorkInProgressHook().memoizedState;\\n      return [\\n        \"boolean\" === typeof booleanOrThenable\\n          ? booleanOrThenable\\n          : useThenable(booleanOrThenable),\\n        start\\n      ];\\n    },\\n    useSyncExternalStore: updateSyncExternalStore,\\n    useId: updateId,\\n    useHostTransitionStatus: useHostTransitionStatus,\\n    useFormState: rerenderActionState,\\n    useActionState: rerenderActionState,\\n    useOptimistic: function (passthrough, reducer) {\\n      var hook = updateWorkInProgressHook();\\n      if (null !== currentHook)\\n        return updateOptimisticImpl(hook, currentHook, passthrough, reducer);\\n      hook.baseState = passthrough;\\n      return [passthrough, hook.queue.dispatch];\\n    },\\n    useMemoCache: useMemoCache,\\n    useCacheRefresh: updateRefresh\\n  },\\n  thenableState = null,\\n  thenableIndexCounter = 0;\\nfunction unwrapThenable(thenable) {\\n  var index = thenableIndexCounter;\\n  thenableIndexCounter += 1;\\n  null === thenableState && (thenableState = []);\\n  return trackUsedThenable(thenableState, thenable, index);\\n}\\nfunction coerceRef(workInProgress, element) {\\n  element = element.props.ref;\\n  workInProgress.ref = void 0 !== element ? element : null;\\n}\\nfunction throwOnInvalidObjectType(returnFiber, newChild) {\\n  if (newChild.$$typeof === REACT_LEGACY_ELEMENT_TYPE)\\n    throw Error(formatProdErrorMessage(525));\\n  returnFiber = Object.prototype.toString.call(newChild);\\n  throw Error(\\n    formatProdErrorMessage(\\n      31,\\n      \"[object Object]\" === returnFiber\\n        ? \"object with keys {\" + Object.keys(newChild).join(\", \") + \"}\"\\n        : returnFiber\\n    )\\n  );\\n}\\nfunction resolveLazy(lazyType) {\\n  var init = lazyType._init;\\n  return init(lazyType._payload);\\n}\\nfunction createChildReconciler(shouldTrackSideEffects) {\\n  function deleteChild(returnFiber, childToDelete) {\\n    if (shouldTrackSideEffects) {\\n      var deletions = returnFiber.deletions;\\n      null === deletions\\n        ? ((returnFiber.deletions = [childToDelete]), (returnFiber.flags |= 16))\\n        : deletions.push(childToDelete);\\n    }\\n  }\\n  function deleteRemainingChildren(returnFiber, currentFirstChild) {\\n    if (!shouldTrackSideEffects) return null;\\n    for (; null !== currentFirstChild; )\\n      deleteChild(returnFiber, currentFirstChild),\\n        (currentFirstChild = currentFirstChild.sibling);\\n    return null;\\n  }\\n  function mapRemainingChildren(currentFirstChild) {\\n    for (var existingChildren = new Map(); null !== currentFirstChild; )\\n      null !== currentFirstChild.key\\n        ? existingChildren.set(currentFirstChild.key, currentFirstChild)\\n        : existingChildren.set(currentFirstChild.index, currentFirstChild),\\n        (currentFirstChild = currentFirstChild.sibling);\\n    return existingChildren;\\n  }\\n  function useFiber(fiber, pendingProps) {\\n    fiber = createWorkInProgress(fiber, pendingProps);\\n    fiber.index = 0;\\n    fiber.sibling = null;\\n    return fiber;\\n  }\\n  function placeChild(newFiber, lastPlacedIndex, newIndex) {\\n    newFiber.index = newIndex;\\n    if (!shouldTrackSideEffects)\\n      return (newFiber.flags |= 1048576), lastPlacedIndex;\\n    newIndex = newFiber.alternate;\\n    if (null !== newIndex)\\n      return (\\n        (newIndex = newIndex.index),\\n        newIndex < lastPlacedIndex\\n          ? ((newFiber.flags |= 67108866), lastPlacedIndex)\\n          : newIndex\\n      );\\n    newFiber.flags |= 67108866;\\n    return lastPlacedIndex;\\n  }\\n  function placeSingleChild(newFiber) {\\n    shouldTrackSideEffects &&\\n      null === newFiber.alternate &&\\n      (newFiber.flags |= 67108866);\\n    return newFiber;\\n  }\\n  function updateTextNode(returnFiber, current, textContent, lanes) {\\n    if (null === current || 6 !== current.tag)\\n      return (\\n        (current = createFiberFromText(textContent, returnFiber.mode, lanes)),\\n        (current.return = returnFiber),\\n        current\\n      );\\n    current = useFiber(current, textContent);\\n    current.return = returnFiber;\\n    return current;\\n  }\\n  function updateElement(returnFiber, current, element, lanes) {\\n    var elementType = element.type;\\n    if (elementType === REACT_FRAGMENT_TYPE)\\n      return updateFragment(\\n        returnFiber,\\n        current,\\n        element.props.children,\\n        lanes,\\n        element.key\\n      );\\n    if (\\n      null !== current &&\\n      (current.elementType === elementType ||\\n        (\"object\" === typeof elementType &&\\n          null !== elementType &&\\n          elementType.$$typeof === REACT_LAZY_TYPE &&\\n          resolveLazy(elementType) === current.type))\\n    )\\n      return (\\n        (current = useFiber(current, element.props)),\\n        coerceRef(current, element),\\n        (current.return = returnFiber),\\n        current\\n      );\\n    current = createFiberFromTypeAndProps(\\n      element.type,\\n      element.key,\\n      element.props,\\n      null,\\n      returnFiber.mode,\\n      lanes\\n    );\\n    coerceRef(current, element);\\n    current.return = returnFiber;\\n    return current;\\n  }\\n  function updatePortal(returnFiber, current, portal, lanes) {\\n    if (\\n      null === current ||\\n      4 !== current.tag ||\\n      current.stateNode.containerInfo !== portal.containerInfo ||\\n      current.stateNode.implementation !== portal.implementation\\n    )\\n      return (\\n        (current = createFiberFromPortal(portal, returnFiber.mode, lanes)),\\n        (current.return = returnFiber),\\n        current\\n      );\\n    current = useFiber(current, portal.children || []);\\n    current.return = returnFiber;\\n    return current;\\n  }\\n  function updateFragment(returnFiber, current, fragment, lanes, key) {\\n    if (null === current || 7 !== current.tag)\\n      return (\\n        (current = createFiberFromFragment(\\n          fragment,\\n          returnFiber.mode,\\n          lanes,\\n          key\\n        )),\\n        (current.return = returnFiber),\\n        current\\n      );\\n    current = useFiber(current, fragment);\\n    current.return = returnFiber;\\n    return current;\\n  }\\n  function createChild(returnFiber, newChild, lanes) {\\n    if (\\n      (\"string\" === typeof newChild && \"\" !== newChild) ||\\n      \"number\" === typeof newChild ||\\n      \"bigint\" === typeof newChild\\n    )\\n      return (\\n        (newChild = createFiberFromText(\\n          \"\" + newChild,\\n          returnFiber.mode,\\n          lanes\\n        )),\\n        (newChild.return = returnFiber),\\n        newChild\\n      );\\n    if (\"object\" === typeof newChild && null !== newChild) {\\n      switch (newChild.$$typeof) {\\n        case REACT_ELEMENT_TYPE:\\n          return (\\n            (lanes = createFiberFromTypeAndProps(\\n              newChild.type,\\n              newChild.key,\\n              newChild.props,\\n              null,\\n              returnFiber.mode,\\n              lanes\\n            )),\\n            coerceRef(lanes, newChild),\\n            (lanes.return = returnFiber),\\n            lanes\\n          );\\n        case REACT_PORTAL_TYPE:\\n          return (\\n            (newChild = createFiberFromPortal(\\n              newChild,\\n              returnFiber.mode,\\n              lanes\\n            )),\\n            (newChild.return = returnFiber),\\n            newChild\\n          );\\n        case REACT_LAZY_TYPE:\\n          var init = newChild._init;\\n          newChild = init(newChild._payload);\\n          return createChild(returnFiber, newChild, lanes);\\n      }\\n      if (isArrayImpl(newChild) || getIteratorFn(newChild))\\n        return (\\n          (newChild = createFiberFromFragment(\\n            newChild,\\n            returnFiber.mode,\\n            lanes,\\n            null\\n          )),\\n          (newChild.return = returnFiber),\\n          newChild\\n        );\\n      if (\"function\" === typeof newChild.then)\\n        return createChild(returnFiber, unwrapThenable(newChild), lanes);\\n      if (newChild.$$typeof === REACT_CONTEXT_TYPE)\\n        return createChild(\\n          returnFiber,\\n          readContextDuringReconciliation(returnFiber, newChild),\\n          lanes\\n        );\\n      throwOnInvalidObjectType(returnFiber, newChild);\\n    }\\n    return null;\\n  }\\n  function updateSlot(returnFiber, oldFiber, newChild, lanes) {\\n    var key = null !== oldFiber ? oldFiber.key : null;\\n    if (\\n      (\"string\" === typeof newChild && \"\" !== newChild) ||\\n      \"number\" === typeof newChild ||\\n      \"bigint\" === typeof newChild\\n    )\\n      return null !== key\\n        ? null\\n        : updateTextNode(returnFiber, oldFiber, \"\" + newChild, lanes);\\n    if (\"object\" === typeof newChild && null !== newChild) {\\n      switch (newChild.$$typeof) {\\n        case REACT_ELEMENT_TYPE:\\n          return newChild.key === key\\n            ? updateElement(returnFiber, oldFiber, newChild, lanes)\\n            : null;\\n        case REACT_PORTAL_TYPE:\\n          return newChild.key === key\\n            ? updatePortal(returnFiber, oldFiber, newChild, lanes)\\n            : null;\\n        case REACT_LAZY_TYPE:\\n          return (\\n            (key = newChild._init),\\n            (newChild = key(newChild._payload)),\\n            updateSlot(returnFiber, oldFiber, newChild, lanes)\\n          );\\n      }\\n      if (isArrayImpl(newChild) || getIteratorFn(newChild))\\n        return null !== key\\n          ? null\\n          : updateFragment(returnFiber, oldFiber, newChild, lanes, null);\\n      if (\"function\" === typeof newChild.then)\\n        return updateSlot(\\n          returnFiber,\\n          oldFiber,\\n          unwrapThenable(newChild),\\n          lanes\\n        );\\n      if (newChild.$$typeof === REACT_CONTEXT_TYPE)\\n        return updateSlot(\\n          returnFiber,\\n          oldFiber,\\n          readContextDuringReconciliation(returnFiber, newChild),\\n          lanes\\n        );\\n      throwOnInvalidObjectType(returnFiber, newChild);\\n    }\\n    return null;\\n  }\\n  function updateFromMap(\\n    existingChildren,\\n    returnFiber,\\n    newIdx,\\n    newChild,\\n    lanes\\n  ) {\\n    if (\\n      (\"string\" === typeof newChild && \"\" !== newChild) ||\\n      \"number\" === typeof newChild ||\\n      \"bigint\" === typeof newChild\\n    )\\n      return (\\n        (existingChildren = existingChildren.get(newIdx) || null),\\n        updateTextNode(returnFiber, existingChildren, \"\" + newChild, lanes)\\n      );\\n    if (\"object\" === typeof newChild && null !== newChild) {\\n      switch (newChild.$$typeof) {\\n        case REACT_ELEMENT_TYPE:\\n          return (\\n            (existingChildren =\\n              existingChildren.get(\\n                null === newChild.key ? newIdx : newChild.key\\n              ) || null),\\n            updateElement(returnFiber, existingChildren, newChild, lanes)\\n          );\\n        case REACT_PORTAL_TYPE:\\n          return (\\n            (existingChildren =\\n              existingChildren.get(\\n                null === newChild.key ? newIdx : newChild.key\\n              ) || null),\\n            updatePortal(returnFiber, existingChildren, newChild, lanes)\\n          );\\n        case REACT_LAZY_TYPE:\\n          var init = newChild._init;\\n          newChild = init(newChild._payload);\\n          return updateFromMap(\\n            existingChildren,\\n            returnFiber,\\n            newIdx,\\n            newChild,\\n            lanes\\n          );\\n      }\\n      if (isArrayImpl(newChild) || getIteratorFn(newChild))\\n        return (\\n          (existingChildren = existingChildren.get(newIdx) || null),\\n          updateFragment(returnFiber, existingChildren, newChild, lanes, null)\\n        );\\n      if (\"function\" === typeof newChild.then)\\n        return updateFromMap(\\n          existingChildren,\\n          returnFiber,\\n          newIdx,\\n          unwrapThenable(newChild),\\n          lanes\\n        );\\n      if (newChild.$$typeof === REACT_CONTEXT_TYPE)\\n        return updateFromMap(\\n          existingChildren,\\n          returnFiber,\\n          newIdx,\\n          readContextDuringReconciliation(returnFiber, newChild),\\n          lanes\\n        );\\n      throwOnInvalidObjectType(returnFiber, newChild);\\n    }\\n    return null;\\n  }\\n  function reconcileChildrenArray(\\n    returnFiber,\\n    currentFirstChild,\\n    newChildren,\\n    lanes\\n  ) {\\n    for (\\n      var resultingFirstChild = null,\\n        previousNewFiber = null,\\n        oldFiber = currentFirstChild,\\n        newIdx = (currentFirstChild = 0),\\n        nextOldFiber = null;\\n      null !== oldFiber && newIdx < newChildren.length;\\n      newIdx++\\n    ) {\\n      oldFiber.index > newIdx\\n        ? ((nextOldFiber = oldFiber), (oldFiber = null))\\n        : (nextOldFiber = oldFiber.sibling);\\n      var newFiber = updateSlot(\\n        returnFiber,\\n        oldFiber,\\n        newChildren[newIdx],\\n        lanes\\n      );\\n      if (null === newFiber) {\\n        null === oldFiber && (oldFiber = nextOldFiber);\\n        break;\\n      }\\n      shouldTrackSideEffects &&\\n        oldFiber &&\\n        null === newFiber.alternate &&\\n        deleteChild(returnFiber, oldFiber);\\n      currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);\\n      null === previousNewFiber\\n        ? (resultingFirstChild = newFiber)\\n        : (previousNewFiber.sibling = newFiber);\\n      previousNewFiber = newFiber;\\n      oldFiber = nextOldFiber;\\n    }\\n    if (newIdx === newChildren.length)\\n      return (\\n        deleteRemainingChildren(returnFiber, oldFiber),\\n        isHydrating && pushTreeFork(returnFiber, newIdx),\\n        resultingFirstChild\\n      );\\n    if (null === oldFiber) {\\n      for (; newIdx < newChildren.length; newIdx++)\\n        (oldFiber = createChild(returnFiber, newChildren[newIdx], lanes)),\\n          null !== oldFiber &&\\n            ((currentFirstChild = placeChild(\\n              oldFiber,\\n              currentFirstChild,\\n              newIdx\\n            )),\\n            null === previousNewFiber\\n              ? (resultingFirstChild = oldFiber)\\n              : (previousNewFiber.sibling = oldFiber),\\n            (previousNewFiber = oldFiber));\\n      isHydrating && pushTreeFork(returnFiber, newIdx);\\n      return resultingFirstChild;\\n    }\\n    for (\\n      oldFiber = mapRemainingChildren(oldFiber);\\n      newIdx < newChildren.length;\\n      newIdx++\\n    )\\n      (nextOldFiber = updateFromMap(\\n        oldFiber,\\n        returnFiber,\\n        newIdx,\\n        newChildren[newIdx],\\n        lanes\\n      )),\\n        null !== nextOldFiber &&\\n          (shouldTrackSideEffects &&\\n            null !== nextOldFiber.alternate &&\\n            oldFiber.delete(\\n              null === nextOldFiber.key ? newIdx : nextOldFiber.key\\n            ),\\n          (currentFirstChild = placeChild(\\n            nextOldFiber,\\n            currentFirstChild,\\n            newIdx\\n          )),\\n          null === previousNewFiber\\n            ? (resultingFirstChild = nextOldFiber)\\n            : (previousNewFiber.sibling = nextOldFiber),\\n          (previousNewFiber = nextOldFiber));\\n    shouldTrackSideEffects &&\\n      oldFiber.forEach(function (child) {\\n        return deleteChild(returnFiber, child);\\n      });\\n    isHydrating && pushTreeFork(returnFiber, newIdx);\\n    return resultingFirstChild;\\n  }\\n  function reconcileChildrenIterator(\\n    returnFiber,\\n    currentFirstChild,\\n    newChildren,\\n    lanes\\n  ) {\\n    if (null == newChildren) throw Error(formatProdErrorMessage(151));\\n    for (\\n      var resultingFirstChild = null,\\n        previousNewFiber = null,\\n        oldFiber = currentFirstChild,\\n        newIdx = (currentFirstChild = 0),\\n        nextOldFiber = null,\\n        step = newChildren.next();\\n      null !== oldFiber && !step.done;\\n      newIdx++, step = newChildren.next()\\n    ) {\\n      oldFiber.index > newIdx\\n        ? ((nextOldFiber = oldFiber), (oldFiber = null))\\n        : (nextOldFiber = oldFiber.sibling);\\n      var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);\\n      if (null === newFiber) {\\n        null === oldFiber && (oldFiber = nextOldFiber);\\n        break;\\n      }\\n      shouldTrackSideEffects &&\\n        oldFiber &&\\n        null === newFiber.alternate &&\\n        deleteChild(returnFiber, oldFiber);\\n      currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);\\n      null === previousNewFiber\\n        ? (resultingFirstChild = newFiber)\\n        : (previousNewFiber.sibling = newFiber);\\n      previousNewFiber = newFiber;\\n      oldFiber = nextOldFiber;\\n    }\\n    if (step.done)\\n      return (\\n        deleteRemainingChildren(returnFiber, oldFiber),\\n        isHydrating && pushTreeFork(returnFiber, newIdx),\\n        resultingFirstChild\\n      );\\n    if (null === oldFiber) {\\n      for (; !step.done; newIdx++, step = newChildren.next())\\n        (step = createChild(returnFiber, step.value, lanes)),\\n          null !== step &&\\n            ((currentFirstChild = placeChild(step, currentFirstChild, newIdx)),\\n            null === previousNewFiber\\n              ? (resultingFirstChild = step)\\n              : (previousNewFiber.sibling = step),\\n            (previousNewFiber = step));\\n      isHydrating && pushTreeFork(returnFiber, newIdx);\\n      return resultingFirstChild;\\n    }\\n    for (\\n      oldFiber = mapRemainingChildren(oldFiber);\\n      !step.done;\\n      newIdx++, step = newChildren.next()\\n    )\\n      (step = updateFromMap(oldFiber, returnFiber, newIdx, step.value, lanes)),\\n        null !== step &&\\n          (shouldTrackSideEffects &&\\n            null !== step.alternate &&\\n            oldFiber.delete(null === step.key ? newIdx : step.key),\\n          (currentFirstChild = placeChild(step, currentFirstChild, newIdx)),\\n          null === previousNewFiber\\n            ? (resultingFirstChild = step)\\n            : (previousNewFiber.sibling = step),\\n          (previousNewFiber = step));\\n    shouldTrackSideEffects &&\\n      oldFiber.forEach(function (child) {\\n        return deleteChild(returnFiber, child);\\n      });\\n    isHydrating && pushTreeFork(returnFiber, newIdx);\\n    return resultingFirstChild;\\n  }\\n  function reconcileChildFibersImpl(\\n    returnFiber,\\n    currentFirstChild,\\n    newChild,\\n    lanes\\n  ) {\\n    \"object\" === typeof newChild &&\\n      null !== newChild &&\\n      newChild.type === REACT_FRAGMENT_TYPE &&\\n      null === newChild.key &&\\n      (newChild = newChild.props.children);\\n    if (\"object\" === typeof newChild && null !== newChild) {\\n      switch (newChild.$$typeof) {\\n        case REACT_ELEMENT_TYPE:\\n          a: {\\n            for (var key = newChild.key; null !== currentFirstChild; ) {\\n              if (currentFirstChild.key === key) {\\n                key = newChild.type;\\n                if (key === REACT_FRAGMENT_TYPE) {\\n                  if (7 === currentFirstChild.tag) {\\n                    deleteRemainingChildren(\\n                      returnFiber,\\n                      currentFirstChild.sibling\\n                    );\\n                    lanes = useFiber(\\n                      currentFirstChild,\\n                      newChild.props.children\\n                    );\\n                    lanes.return = returnFiber;\\n                    returnFiber = lanes;\\n                    break a;\\n                  }\\n                } else if (\\n                  currentFirstChild.elementType === key ||\\n                  (\"object\" === typeof key &&\\n                    null !== key &&\\n                    key.$$typeof === REACT_LAZY_TYPE &&\\n                    resolveLazy(key) === currentFirstChild.type)\\n                ) {\\n                  deleteRemainingChildren(\\n                    returnFiber,\\n                    currentFirstChild.sibling\\n                  );\\n                  lanes = useFiber(currentFirstChild, newChild.props);\\n                  coerceRef(lanes, newChild);\\n                  lanes.return = returnFiber;\\n                  returnFiber = lanes;\\n                  break a;\\n                }\\n                deleteRemainingChildren(returnFiber, currentFirstChild);\\n                break;\\n              } else deleteChild(returnFiber, currentFirstChild);\\n              currentFirstChild = currentFirstChild.sibling;\\n            }\\n            newChild.type === REACT_FRAGMENT_TYPE\\n              ? ((lanes = createFiberFromFragment(\\n                  newChild.props.children,\\n                  returnFiber.mode,\\n                  lanes,\\n                  newChild.key\\n                )),\\n                (lanes.return = returnFiber),\\n                (returnFiber = lanes))\\n              : ((lanes = createFiberFromTypeAndProps(\\n                  newChild.type,\\n                  newChild.key,\\n                  newChild.props,\\n                  null,\\n                  returnFiber.mode,\\n                  lanes\\n                )),\\n                coerceRef(lanes, newChild),\\n                (lanes.return = returnFiber),\\n                (returnFiber = lanes));\\n          }\\n          return placeSingleChild(returnFiber);\\n        case REACT_PORTAL_TYPE:\\n          a: {\\n            for (key = newChild.key; null !== currentFirstChild; ) {\\n              if (currentFirstChild.key === key)\\n                if (\\n                  4 === currentFirstChild.tag &&\\n                  currentFirstChild.stateNode.containerInfo ===\\n                    newChild.containerInfo &&\\n                  currentFirstChild.stateNode.implementation ===\\n                    newChild.implementation\\n                ) {\\n                  deleteRemainingChildren(\\n                    returnFiber,\\n                    currentFirstChild.sibling\\n                  );\\n                  lanes = useFiber(currentFirstChild, newChild.children || []);\\n                  lanes.return = returnFiber;\\n                  returnFiber = lanes;\\n                  break a;\\n                } else {\\n                  deleteRemainingChildren(returnFiber, currentFirstChild);\\n                  break;\\n                }\\n              else deleteChild(returnFiber, currentFirstChild);\\n              currentFirstChild = currentFirstChild.sibling;\\n            }\\n            lanes = createFiberFromPortal(newChild, returnFiber.mode, lanes);\\n            lanes.return = returnFiber;\\n            returnFiber = lanes;\\n          }\\n          return placeSingleChild(returnFiber);\\n        case REACT_LAZY_TYPE:\\n          return (\\n            (key = newChild._init),\\n            (newChild = key(newChild._payload)),\\n            reconcileChildFibersImpl(\\n              returnFiber,\\n              currentFirstChild,\\n              newChild,\\n              lanes\\n            )\\n          );\\n      }\\n      if (isArrayImpl(newChild))\\n        return reconcileChildrenArray(\\n          returnFiber,\\n          currentFirstChild,\\n          newChild,\\n          lanes\\n        );\\n      if (getIteratorFn(newChild)) {\\n        key = getIteratorFn(newChild);\\n        if (\"function\" !== typeof key) throw Error(formatProdErrorMessage(150));\\n        newChild = key.call(newChild);\\n        return reconcileChildrenIterator(\\n          returnFiber,\\n          currentFirstChild,\\n          newChild,\\n          lanes\\n        );\\n      }\\n      if (\"function\" === typeof newChild.then)\\n        return reconcileChildFibersImpl(\\n          returnFiber,\\n          currentFirstChild,\\n          unwrapThenable(newChild),\\n          lanes\\n        );\\n      if (newChild.$$typeof === REACT_CONTEXT_TYPE)\\n        return reconcileChildFibersImpl(\\n          returnFiber,\\n          currentFirstChild,\\n          readContextDuringReconciliation(returnFiber, newChild),\\n          lanes\\n        );\\n      throwOnInvalidObjectType(returnFiber, newChild);\\n    }\\n    return (\"string\" === typeof newChild && \"\" !== newChild) ||\\n      \"number\" === typeof newChild ||\\n      \"bigint\" === typeof newChild\\n      ? ((newChild = \"\" + newChild),\\n        null !== currentFirstChild && 6 === currentFirstChild.tag\\n          ? (deleteRemainingChildren(returnFiber, currentFirstChild.sibling),\\n            (lanes = useFiber(currentFirstChild, newChild)),\\n            (lanes.return = returnFiber),\\n            (returnFiber = lanes))\\n          : (deleteRemainingChildren(returnFiber, currentFirstChild),\\n            (lanes = createFiberFromText(newChild, returnFiber.mode, lanes)),\\n            (lanes.return = returnFiber),\\n            (returnFiber = lanes)),\\n        placeSingleChild(returnFiber))\\n      : deleteRemainingChildren(returnFiber, currentFirstChild);\\n  }\\n  return function (returnFiber, currentFirstChild, newChild, lanes) {\\n    try {\\n      thenableIndexCounter = 0;\\n      var firstChildFiber = reconcileChildFibersImpl(\\n        returnFiber,\\n        currentFirstChild,\\n        newChild,\\n        lanes\\n      );\\n      thenableState = null;\\n      return firstChildFiber;\\n    } catch (x) {\\n      if (x === SuspenseException || x === SuspenseActionException) throw x;\\n      var fiber = createFiberImplClass(29, x, null, returnFiber.mode);\\n      fiber.lanes = lanes;\\n      fiber.return = returnFiber;\\n      return fiber;\\n    } finally {\\n    }\\n  };\\n}\\nvar reconcileChildFibers = createChildReconciler(!0),\\n  mountChildFibers = createChildReconciler(!1),\\n  suspenseHandlerStackCursor = createCursor(null),\\n  shellBoundary = null;\\nfunction pushPrimaryTreeSuspenseHandler(handler) {\\n  var current = handler.alternate;\\n  push(suspenseStackCursor, suspenseStackCursor.current & 1);\\n  push(suspenseHandlerStackCursor, handler);\\n  null === shellBoundary &&\\n    (null === current || null !== currentTreeHiddenStackCursor.current\\n      ? (shellBoundary = handler)\\n      : null !== current.memoizedState && (shellBoundary = handler));\\n}\\nfunction pushOffscreenSuspenseHandler(fiber) {\\n  if (22 === fiber.tag) {\\n    if (\\n      (push(suspenseStackCursor, suspenseStackCursor.current),\\n      push(suspenseHandlerStackCursor, fiber),\\n      null === shellBoundary)\\n    ) {\\n      var current = fiber.alternate;\\n      null !== current &&\\n        null !== current.memoizedState &&\\n        (shellBoundary = fiber);\\n    }\\n  } else reuseSuspenseHandlerOnStack(fiber);\\n}\\nfunction reuseSuspenseHandlerOnStack() {\\n  push(suspenseStackCursor, suspenseStackCursor.current);\\n  push(suspenseHandlerStackCursor, suspenseHandlerStackCursor.current);\\n}\\nfunction popSuspenseHandler(fiber) {\\n  pop(suspenseHandlerStackCursor);\\n  shellBoundary === fiber && (shellBoundary = null);\\n  pop(suspenseStackCursor);\\n}\\nvar suspenseStackCursor = createCursor(0);\\nfunction findFirstSuspended(row) {\\n  for (var node = row; null !== node; ) {\\n    if (13 === node.tag) {\\n      var state = node.memoizedState;\\n      if (\\n        null !== state &&\\n        ((state = state.dehydrated),\\n        null === state ||\\n          \"$?\" === state.data ||\\n          isSuspenseInstanceFallback(state))\\n      )\\n        return node;\\n    } else if (19 === node.tag && void 0 !== node.memoizedProps.revealOrder) {\\n      if (0 !== (node.flags & 128)) return node;\\n    } else if (null !== node.child) {\\n      node.child.return = node;\\n      node = node.child;\\n      continue;\\n    }\\n    if (node === row) break;\\n    for (; null === node.sibling; ) {\\n      if (null === node.return || node.return === row) return null;\\n      node = node.return;\\n    }\\n    node.sibling.return = node.return;\\n    node = node.sibling;\\n  }\\n  return null;\\n}\\nfunction applyDerivedStateFromProps(\\n  workInProgress,\\n  ctor,\\n  getDerivedStateFromProps,\\n  nextProps\\n) {\\n  ctor = workInProgress.memoizedState;\\n  getDerivedStateFromProps = getDerivedStateFromProps(nextProps, ctor);\\n  getDerivedStateFromProps =\\n    null === getDerivedStateFromProps || void 0 === getDerivedStateFromProps\\n      ? ctor\\n      : assign({}, ctor, getDerivedStateFromProps);\\n  workInProgress.memoizedState = getDerivedStateFromProps;\\n  0 === workInProgress.lanes &&\\n    (workInProgress.updateQueue.baseState = getDerivedStateFromProps);\\n}\\nvar classComponentUpdater = {\\n  enqueueSetState: function (inst, payload, callback) {\\n    inst = inst._reactInternals;\\n    var lane = requestUpdateLane(),\\n      update = createUpdate(lane);\\n    update.payload = payload;\\n    void 0 !== callback && null !== callback && (update.callback = callback);\\n    payload = enqueueUpdate(inst, update, lane);\\n    null !== payload &&\\n      (scheduleUpdateOnFiber(payload, inst, lane),\\n      entangleTransitions(payload, inst, lane));\\n  },\\n  enqueueReplaceState: function (inst, payload, callback) {\\n    inst = inst._reactInternals;\\n    var lane = requestUpdateLane(),\\n      update = createUpdate(lane);\\n    update.tag = 1;\\n    update.payload = payload;\\n    void 0 !== callback && null !== callback && (update.callback = callback);\\n    payload = enqueueUpdate(inst, update, lane);\\n    null !== payload &&\\n      (scheduleUpdateOnFiber(payload, inst, lane),\\n      entangleTransitions(payload, inst, lane));\\n  },\\n  enqueueForceUpdate: function (inst, callback) {\\n    inst = inst._reactInternals;\\n    var lane = requestUpdateLane(),\\n      update = createUpdate(lane);\\n    update.tag = 2;\\n    void 0 !== callback && null !== callback && (update.callback = callback);\\n    callback = enqueueUpdate(inst, update, lane);\\n    null !== callback &&\\n      (scheduleUpdateOnFiber(callback, inst, lane),\\n      entangleTransitions(callback, inst, lane));\\n  }\\n};\\nfunction checkShouldComponentUpdate(\\n  workInProgress,\\n  ctor,\\n  oldProps,\\n  newProps,\\n  oldState,\\n  newState,\\n  nextContext\\n) {\\n  workInProgress = workInProgress.stateNode;\\n  return \"function\" === typeof workInProgress.shouldComponentUpdate\\n    ? workInProgress.shouldComponentUpdate(newProps, newState, nextContext)\\n    : ctor.prototype && ctor.prototype.isPureReactComponent\\n      ? !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState)\\n      : !0;\\n}\\nfunction callComponentWillReceiveProps(\\n  workInProgress,\\n  instance,\\n  newProps,\\n  nextContext\\n) {\\n  workInProgress = instance.state;\\n  \"function\" === typeof instance.componentWillReceiveProps &&\\n    instance.componentWillReceiveProps(newProps, nextContext);\\n  \"function\" === typeof instance.UNSAFE_componentWillReceiveProps &&\\n    instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);\\n  instance.state !== workInProgress &&\\n    classComponentUpdater.enqueueReplaceState(instance, instance.state, null);\\n}\\nfunction resolveClassComponentProps(Component, baseProps) {\\n  var newProps = baseProps;\\n  if (\"ref\" in baseProps) {\\n    newProps = {};\\n    for (var propName in baseProps)\\n      \"ref\" !== propName && (newProps[propName] = baseProps[propName]);\\n  }\\n  if ((Component = Component.defaultProps)) {\\n    newProps === baseProps && (newProps = assign({}, newProps));\\n    for (var propName$73 in Component)\\n      void 0 === newProps[propName$73] &&\\n        (newProps[propName$73] = Component[propName$73]);\\n  }\\n  return newProps;\\n}\\nvar reportGlobalError =\\n  \"function\" === typeof reportError\\n    ? reportError\\n    : function (error) {\\n        if (\\n          \"object\" === typeof window &&\\n          \"function\" === typeof window.ErrorEvent\\n        ) {\\n          var event = new window.ErrorEvent(\"error\", {\\n            bubbles: !0,\\n            cancelable: !0,\\n            message:\\n              \"object\" === typeof error &&\\n              null !== error &&\\n              \"string\" === typeof error.message\\n                ? String(error.message)\\n                : String(error),\\n            error: error\\n          });\\n          if (!window.dispatchEvent(event)) return;\\n        } else if (\\n          \"object\" === typeof process &&\\n          \"function\" === typeof process.emit\\n        ) {\\n          process.emit(\"uncaughtException\", error);\\n          return;\\n        }\\n        console.error(error);\\n      };\\nfunction defaultOnUncaughtError(error) {\\n  reportGlobalError(error);\\n}\\nfunction defaultOnCaughtError(error) {\\n  console.error(error);\\n}\\nfunction defaultOnRecoverableError(error) {\\n  reportGlobalError(error);\\n}\\nfunction logUncaughtError(root, errorInfo) {\\n  try {\\n    var onUncaughtError = root.onUncaughtError;\\n    onUncaughtError(errorInfo.value, { componentStack: errorInfo.stack });\\n  } catch (e$74) {\\n    setTimeout(function () {\\n      throw e$74;\\n    });\\n  }\\n}\\nfunction logCaughtError(root, boundary, errorInfo) {\\n  try {\\n    var onCaughtError = root.onCaughtError;\\n    onCaughtError(errorInfo.value, {\\n      componentStack: errorInfo.stack,\\n      errorBoundary: 1 === boundary.tag ? boundary.stateNode : null\\n    });\\n  } catch (e$75) {\\n    setTimeout(function () {\\n      throw e$75;\\n    });\\n  }\\n}\\nfunction createRootErrorUpdate(root, errorInfo, lane) {\\n  lane = createUpdate(lane);\\n  lane.tag = 3;\\n  lane.payload = { element: null };\\n  lane.callback = function () {\\n    logUncaughtError(root, errorInfo);\\n  };\\n  return lane;\\n}\\nfunction createClassErrorUpdate(lane) {\\n  lane = createUpdate(lane);\\n  lane.tag = 3;\\n  return lane;\\n}\\nfunction initializeClassErrorUpdate(update, root, fiber, errorInfo) {\\n  var getDerivedStateFromError = fiber.type.getDerivedStateFromError;\\n  if (\"function\" === typeof getDerivedStateFromError) {\\n    var error = errorInfo.value;\\n    update.payload = function () {\\n      return getDerivedStateFromError(error);\\n    };\\n    update.callback = function () {\\n      logCaughtError(root, fiber, errorInfo);\\n    };\\n  }\\n  var inst = fiber.stateNode;\\n  null !== inst &&\\n    \"function\" === typeof inst.componentDidCatch &&\\n    (update.callback = function () {\\n      logCaughtError(root, fiber, errorInfo);\\n      \"function\" !== typeof getDerivedStateFromError &&\\n        (null === legacyErrorBoundariesThatAlreadyFailed\\n          ? (legacyErrorBoundariesThatAlreadyFailed = new Set([this]))\\n          : legacyErrorBoundariesThatAlreadyFailed.add(this));\\n      var stack = errorInfo.stack;\\n      this.componentDidCatch(errorInfo.value, {\\n        componentStack: null !== stack ? stack : \"\"\\n      });\\n    });\\n}\\nfunction throwException(\\n  root,\\n  returnFiber,\\n  sourceFiber,\\n  value,\\n  rootRenderLanes\\n) {\\n  sourceFiber.flags |= 32768;\\n  if (\\n    null !== value &&\\n    \"object\" === typeof value &&\\n    \"function\" === typeof value.then\\n  ) {\\n    returnFiber = sourceFiber.alternate;\\n    null !== returnFiber &&\\n      propagateParentContextChanges(\\n        returnFiber,\\n        sourceFiber,\\n        rootRenderLanes,\\n        !0\\n      );\\n    sourceFiber = suspenseHandlerStackCursor.current;\\n    if (null !== sourceFiber) {\\n      switch (sourceFiber.tag) {\\n        case 13:\\n          return (\\n            null === shellBoundary\\n              ? renderDidSuspendDelayIfPossible()\\n              : null === sourceFiber.alternate &&\\n                0 === workInProgressRootExitStatus &&\\n                (workInProgressRootExitStatus = 3),\\n            (sourceFiber.flags &= -257),\\n            (sourceFiber.flags |= 65536),\\n            (sourceFiber.lanes = rootRenderLanes),\\n            value === noopSuspenseyCommitThenable\\n              ? (sourceFiber.flags |= 16384)\\n              : ((returnFiber = sourceFiber.updateQueue),\\n                null === returnFiber\\n                  ? (sourceFiber.updateQueue = new Set([value]))\\n                  : returnFiber.add(value),\\n                attachPingListener(root, value, rootRenderLanes)),\\n            !1\\n          );\\n        case 22:\\n          return (\\n            (sourceFiber.flags |= 65536),\\n            value === noopSuspenseyCommitThenable\\n              ? (sourceFiber.flags |= 16384)\\n              : ((returnFiber = sourceFiber.updateQueue),\\n                null === returnFiber\\n                  ? ((returnFiber = {\\n                      transitions: null,\\n                      markerInstances: null,\\n                      retryQueue: new Set([value])\\n                    }),\\n                    (sourceFiber.updateQueue = returnFiber))\\n                  : ((sourceFiber = returnFiber.retryQueue),\\n                    null === sourceFiber\\n                      ? (returnFiber.retryQueue = new Set([value]))\\n                      : sourceFiber.add(value)),\\n                attachPingListener(root, value, rootRenderLanes)),\\n            !1\\n          );\\n      }\\n      throw Error(formatProdErrorMessage(435, sourceFiber.tag));\\n    }\\n    attachPingListener(root, value, rootRenderLanes);\\n    renderDidSuspendDelayIfPossible();\\n    return !1;\\n  }\\n  if (isHydrating)\\n    return (\\n      (returnFiber = suspenseHandlerStackCursor.current),\\n      null !== returnFiber\\n        ? (0 === (returnFiber.flags & 65536) && (returnFiber.flags |= 256),\\n          (returnFiber.flags |= 65536),\\n          (returnFiber.lanes = rootRenderLanes),\\n          value !== HydrationMismatchException &&\\n            ((root = Error(formatProdErrorMessage(422), { cause: value })),\\n            queueHydrationError(createCapturedValueAtFiber(root, sourceFiber))))\\n        : (value !== HydrationMismatchException &&\\n            ((returnFiber = Error(formatProdErrorMessage(423), {\\n              cause: value\\n            })),\\n            queueHydrationError(\\n              createCapturedValueAtFiber(returnFiber, sourceFiber)\\n            )),\\n          (root = root.current.alternate),\\n          (root.flags |= 65536),\\n          (rootRenderLanes &= -rootRenderLanes),\\n          (root.lanes |= rootRenderLanes),\\n          (value = createCapturedValueAtFiber(value, sourceFiber)),\\n          (rootRenderLanes = createRootErrorUpdate(\\n            root.stateNode,\\n            value,\\n            rootRenderLanes\\n          )),\\n          enqueueCapturedUpdate(root, rootRenderLanes),\\n          4 !== workInProgressRootExitStatus &&\\n            (workInProgressRootExitStatus = 2)),\\n      !1\\n    );\\n  var wrapperError = Error(formatProdErrorMessage(520), { cause: value });\\n  wrapperError = createCapturedValueAtFiber(wrapperError, sourceFiber);\\n  null === workInProgressRootConcurrentErrors\\n    ? (workInProgressRootConcurrentErrors = [wrapperError])\\n    : workInProgressRootConcurrentErrors.push(wrapperError);\\n  4 !== workInProgressRootExitStatus && (workInProgressRootExitStatus = 2);\\n  if (null === returnFiber) return !0;\\n  value = createCapturedValueAtFiber(value, sourceFiber);\\n  sourceFiber = returnFiber;\\n  do {\\n    switch (sourceFiber.tag) {\\n      case 3:\\n        return (\\n          (sourceFiber.flags |= 65536),\\n          (root = rootRenderLanes & -rootRenderLanes),\\n          (sourceFiber.lanes |= root),\\n          (root = createRootErrorUpdate(sourceFiber.stateNode, value, root)),\\n          enqueueCapturedUpdate(sourceFiber, root),\\n          !1\\n        );\\n      case 1:\\n        if (\\n          ((returnFiber = sourceFiber.type),\\n          (wrapperError = sourceFiber.stateNode),\\n          0 === (sourceFiber.flags & 128) &&\\n            (\"function\" === typeof returnFiber.getDerivedStateFromError ||\\n              (null !== wrapperError &&\\n                \"function\" === typeof wrapperError.componentDidCatch &&\\n                (null === legacyErrorBoundariesThatAlreadyFailed ||\\n                  !legacyErrorBoundariesThatAlreadyFailed.has(wrapperError)))))\\n        )\\n          return (\\n            (sourceFiber.flags |= 65536),\\n            (rootRenderLanes &= -rootRenderLanes),\\n            (sourceFiber.lanes |= rootRenderLanes),\\n            (rootRenderLanes = createClassErrorUpdate(rootRenderLanes)),\\n            initializeClassErrorUpdate(\\n              rootRenderLanes,\\n              root,\\n              sourceFiber,\\n              value\\n            ),\\n            enqueueCapturedUpdate(sourceFiber, rootRenderLanes),\\n            !1\\n          );\\n    }\\n    sourceFiber = sourceFiber.return;\\n  } while (null !== sourceFiber);\\n  return !1;\\n}\\nvar SelectiveHydrationException = Error(formatProdErrorMessage(461)),\\n  didReceiveUpdate = !1;\\nfunction reconcileChildren(current, workInProgress, nextChildren, renderLanes) {\\n  workInProgress.child =\\n    null === current\\n      ? mountChildFibers(workInProgress, null, nextChildren, renderLanes)\\n      : reconcileChildFibers(\\n          workInProgress,\\n          current.child,\\n          nextChildren,\\n          renderLanes\\n        );\\n}\\nfunction updateForwardRef(\\n  current,\\n  workInProgress,\\n  Component,\\n  nextProps,\\n  renderLanes\\n) {\\n  Component = Component.render;\\n  var ref = workInProgress.ref;\\n  if (\"ref\" in nextProps) {\\n    var propsWithoutRef = {};\\n    for (var key in nextProps)\\n      \"ref\" !== key && (propsWithoutRef[key] = nextProps[key]);\\n  } else propsWithoutRef = nextProps;\\n  prepareToReadContext(workInProgress);\\n  nextProps = renderWithHooks(\\n    current,\\n    workInProgress,\\n    Component,\\n    propsWithoutRef,\\n    ref,\\n    renderLanes\\n  );\\n  key = checkDidRenderIdHook();\\n  if (null !== current && !didReceiveUpdate)\\n    return (\\n      bailoutHooks(current, workInProgress, renderLanes),\\n      bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)\\n    );\\n  isHydrating && key && pushMaterializedTreeId(workInProgress);\\n  workInProgress.flags |= 1;\\n  reconcileChildren(current, workInProgress, nextProps, renderLanes);\\n  return workInProgress.child;\\n}\\nfunction updateMemoComponent(\\n  current,\\n  workInProgress,\\n  Component,\\n  nextProps,\\n  renderLanes\\n) {\\n  if (null === current) {\\n    var type = Component.type;\\n    if (\\n      \"function\" === typeof type &&\\n      !shouldConstruct(type) &&\\n      void 0 === type.defaultProps &&\\n      null === Component.compare\\n    )\\n      return (\\n        (workInProgress.tag = 15),\\n        (workInProgress.type = type),\\n        updateSimpleMemoComponent(\\n          current,\\n          workInProgress,\\n          type,\\n          nextProps,\\n          renderLanes\\n        )\\n      );\\n    current = createFiberFromTypeAndProps(\\n      Component.type,\\n      null,\\n      nextProps,\\n      workInProgress,\\n      workInProgress.mode,\\n      renderLanes\\n    );\\n    current.ref = workInProgress.ref;\\n    current.return = workInProgress;\\n    return (workInProgress.child = current);\\n  }\\n  type = current.child;\\n  if (!checkScheduledUpdateOrContext(current, renderLanes)) {\\n    var prevProps = type.memoizedProps;\\n    Component = Component.compare;\\n    Component = null !== Component ? Component : shallowEqual;\\n    if (Component(prevProps, nextProps) && current.ref === workInProgress.ref)\\n      return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\\n  }\\n  workInProgress.flags |= 1;\\n  current = createWorkInProgress(type, nextProps);\\n  current.ref = workInProgress.ref;\\n  current.return = workInProgress;\\n  return (workInProgress.child = current);\\n}\\nfunction updateSimpleMemoComponent(\\n  current,\\n  workInProgress,\\n  Component,\\n  nextProps,\\n  renderLanes\\n) {\\n  if (null !== current) {\\n    var prevProps = current.memoizedProps;\\n    if (\\n      shallowEqual(prevProps, nextProps) &&\\n      current.ref === workInProgress.ref\\n    )\\n      if (\\n        ((didReceiveUpdate = !1),\\n        (workInProgress.pendingProps = nextProps = prevProps),\\n        checkScheduledUpdateOrContext(current, renderLanes))\\n      )\\n        0 !== (current.flags & 131072) && (didReceiveUpdate = !0);\\n      else\\n        return (\\n          (workInProgress.lanes = current.lanes),\\n          bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)\\n        );\\n  }\\n  return updateFunctionComponent(\\n    current,\\n    workInProgress,\\n    Component,\\n    nextProps,\\n    renderLanes\\n  );\\n}\\nfunction updateOffscreenComponent(current, workInProgress, renderLanes) {\\n  var nextProps = workInProgress.pendingProps,\\n    nextChildren = nextProps.children,\\n    prevState = null !== current ? current.memoizedState : null;\\n  if (\"hidden\" === nextProps.mode) {\\n    if (0 !== (workInProgress.flags & 128)) {\\n      nextProps =\\n        null !== prevState ? prevState.baseLanes | renderLanes : renderLanes;\\n      if (null !== current) {\\n        nextChildren = workInProgress.child = current.child;\\n        for (prevState = 0; null !== nextChildren; )\\n          (prevState =\\n            prevState | nextChildren.lanes | nextChildren.childLanes),\\n            (nextChildren = nextChildren.sibling);\\n        workInProgress.childLanes = prevState & ~nextProps;\\n      } else (workInProgress.childLanes = 0), (workInProgress.child = null);\\n      return deferHiddenOffscreenComponent(\\n        current,\\n        workInProgress,\\n        nextProps,\\n        renderLanes\\n      );\\n    }\\n    if (0 !== (renderLanes & 536870912))\\n      (workInProgress.memoizedState = { baseLanes: 0, cachePool: null }),\\n        null !== current &&\\n          pushTransition(\\n            workInProgress,\\n            null !== prevState ? prevState.cachePool : null\\n          ),\\n        null !== prevState\\n          ? pushHiddenContext(workInProgress, prevState)\\n          : reuseHiddenContextOnStack(),\\n        pushOffscreenSuspenseHandler(workInProgress);\\n    else\\n      return (\\n        (workInProgress.lanes = workInProgress.childLanes = 536870912),\\n        deferHiddenOffscreenComponent(\\n          current,\\n          workInProgress,\\n          null !== prevState ? prevState.baseLanes | renderLanes : renderLanes,\\n          renderLanes\\n        )\\n      );\\n  } else\\n    null !== prevState\\n      ? (pushTransition(workInProgress, prevState.cachePool),\\n        pushHiddenContext(workInProgress, prevState),\\n        reuseSuspenseHandlerOnStack(workInProgress),\\n        (workInProgress.memoizedState = null))\\n      : (null !== current && pushTransition(workInProgress, null),\\n        reuseHiddenContextOnStack(),\\n        reuseSuspenseHandlerOnStack(workInProgress));\\n  reconcileChildren(current, workInProgress, nextChildren, renderLanes);\\n  return workInProgress.child;\\n}\\nfunction deferHiddenOffscreenComponent(\\n  current,\\n  workInProgress,\\n  nextBaseLanes,\\n  renderLanes\\n) {\\n  var JSCompiler_inline_result = peekCacheFromPool();\\n  JSCompiler_inline_result =\\n    null === JSCompiler_inline_result\\n      ? null\\n      : { parent: CacheContext._currentValue, pool: JSCompiler_inline_result };\\n  workInProgress.memoizedState = {\\n    baseLanes: nextBaseLanes,\\n    cachePool: JSCompiler_inline_result\\n  };\\n  null !== current && pushTransition(workInProgress, null);\\n  reuseHiddenContextOnStack();\\n  pushOffscreenSuspenseHandler(workInProgress);\\n  null !== current &&\\n    propagateParentContextChanges(current, workInProgress, renderLanes, !0);\\n  return null;\\n}\\nfunction markRef(current, workInProgress) {\\n  var ref = workInProgress.ref;\\n  if (null === ref)\\n    null !== current &&\\n      null !== current.ref &&\\n      (workInProgress.flags |= 4194816);\\n  else {\\n    if (\"function\" !== typeof ref && \"object\" !== typeof ref)\\n      throw Error(formatProdErrorMessage(284));\\n    if (null === current || current.ref !== ref)\\n      workInProgress.flags |= 4194816;\\n  }\\n}\\nfunction updateFunctionComponent(\\n  current,\\n  workInProgress,\\n  Component,\\n  nextProps,\\n  renderLanes\\n) {\\n  prepareToReadContext(workInProgress);\\n  Component = renderWithHooks(\\n    current,\\n    workInProgress,\\n    Component,\\n    nextProps,\\n    void 0,\\n    renderLanes\\n  );\\n  nextProps = checkDidRenderIdHook();\\n  if (null !== current && !didReceiveUpdate)\\n    return (\\n      bailoutHooks(current, workInProgress, renderLanes),\\n      bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)\\n    );\\n  isHydrating && nextProps && pushMaterializedTreeId(workInProgress);\\n  workInProgress.flags |= 1;\\n  reconcileChildren(current, workInProgress, Component, renderLanes);\\n  return workInProgress.child;\\n}\\nfunction replayFunctionComponent(\\n  current,\\n  workInProgress,\\n  nextProps,\\n  Component,\\n  secondArg,\\n  renderLanes\\n) {\\n  prepareToReadContext(workInProgress);\\n  workInProgress.updateQueue = null;\\n  nextProps = renderWithHooksAgain(\\n    workInProgress,\\n    Component,\\n    nextProps,\\n    secondArg\\n  );\\n  finishRenderingHooks(current);\\n  Component = checkDidRenderIdHook();\\n  if (null !== current && !didReceiveUpdate)\\n    return (\\n      bailoutHooks(current, workInProgress, renderLanes),\\n      bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)\\n    );\\n  isHydrating && Component && pushMaterializedTreeId(workInProgress);\\n  workInProgress.flags |= 1;\\n  reconcileChildren(current, workInProgress, nextProps, renderLanes);\\n  return workInProgress.child;\\n}\\nfunction updateClassComponent(\\n  current,\\n  workInProgress,\\n  Component,\\n  nextProps,\\n  renderLanes\\n) {\\n  prepareToReadContext(workInProgress);\\n  if (null === workInProgress.stateNode) {\\n    var context = emptyContextObject,\\n      contextType = Component.contextType;\\n    \"object\" === typeof contextType &&\\n      null !== contextType &&\\n      (context = readContext(contextType));\\n    context = new Component(nextProps, context);\\n    workInProgress.memoizedState =\\n      null !== context.state && void 0 !== context.state ? context.state : null;\\n    context.updater = classComponentUpdater;\\n    workInProgress.stateNode = context;\\n    context._reactInternals = workInProgress;\\n    context = workInProgress.stateNode;\\n    context.props = nextProps;\\n    context.state = workInProgress.memoizedState;\\n    context.refs = {};\\n    initializeUpdateQueue(workInProgress);\\n    contextType = Component.contextType;\\n    context.context =\\n      \"object\" === typeof contextType && null !== contextType\\n        ? readContext(contextType)\\n        : emptyContextObject;\\n    context.state = workInProgress.memoizedState;\\n    contextType = Component.getDerivedStateFromProps;\\n    \"function\" === typeof contextType &&\\n      (applyDerivedStateFromProps(\\n        workInProgress,\\n        Component,\\n        contextType,\\n        nextProps\\n      ),\\n      (context.state = workInProgress.memoizedState));\\n    \"function\" === typeof Component.getDerivedStateFromProps ||\\n      \"function\" === typeof context.getSnapshotBeforeUpdate ||\\n      (\"function\" !== typeof context.UNSAFE_componentWillMount &&\\n        \"function\" !== typeof context.componentWillMount) ||\\n      ((contextType = context.state),\\n      \"function\" === typeof context.componentWillMount &&\\n        context.componentWillMount(),\\n      \"function\" === typeof context.UNSAFE_componentWillMount &&\\n        context.UNSAFE_componentWillMount(),\\n      contextType !== context.state &&\\n        classComponentUpdater.enqueueReplaceState(context, context.state, null),\\n      processUpdateQueue(workInProgress, nextProps, context, renderLanes),\\n      suspendIfUpdateReadFromEntangledAsyncAction(),\\n      (context.state = workInProgress.memoizedState));\\n    \"function\" === typeof context.componentDidMount &&\\n      (workInProgress.flags |= 4194308);\\n    nextProps = !0;\\n  } else if (null === current) {\\n    context = workInProgress.stateNode;\\n    var unresolvedOldProps = workInProgress.memoizedProps,\\n      oldProps = resolveClassComponentProps(Component, unresolvedOldProps);\\n    context.props = oldProps;\\n    var oldContext = context.context,\\n      contextType$jscomp$0 = Component.contextType;\\n    contextType = emptyContextObject;\\n    \"object\" === typeof contextType$jscomp$0 &&\\n      null !== contextType$jscomp$0 &&\\n      (contextType = readContext(contextType$jscomp$0));\\n    var getDerivedStateFromProps = Component.getDerivedStateFromProps;\\n    contextType$jscomp$0 =\\n      \"function\" === typeof getDerivedStateFromProps ||\\n      \"function\" === typeof context.getSnapshotBeforeUpdate;\\n    unresolvedOldProps = workInProgress.pendingProps !== unresolvedOldProps;\\n    contextType$jscomp$0 ||\\n      (\"function\" !== typeof context.UNSAFE_componentWillReceiveProps &&\\n        \"function\" !== typeof context.componentWillReceiveProps) ||\\n      ((unresolvedOldProps || oldContext !== contextType) &&\\n        callComponentWillReceiveProps(\\n          workInProgress,\\n          context,\\n          nextProps,\\n          contextType\\n        ));\\n    hasForceUpdate = !1;\\n    var oldState = workInProgress.memoizedState;\\n    context.state = oldState;\\n    processUpdateQueue(workInProgress, nextProps, context, renderLanes);\\n    suspendIfUpdateReadFromEntangledAsyncAction();\\n    oldContext = workInProgress.memoizedState;\\n    unresolvedOldProps || oldState !== oldContext || hasForceUpdate\\n      ? (\"function\" === typeof getDerivedStateFromProps &&\\n          (applyDerivedStateFromProps(\\n            workInProgress,\\n            Component,\\n            getDerivedStateFromProps,\\n            nextProps\\n          ),\\n          (oldContext = workInProgress.memoizedState)),\\n        (oldProps =\\n          hasForceUpdate ||\\n          checkShouldComponentUpdate(\\n            workInProgress,\\n            Component,\\n            oldProps,\\n            nextProps,\\n            oldState,\\n            oldContext,\\n            contextType\\n          ))\\n          ? (contextType$jscomp$0 ||\\n              (\"function\" !== typeof context.UNSAFE_componentWillMount &&\\n                \"function\" !== typeof context.componentWillMount) ||\\n              (\"function\" === typeof context.componentWillMount &&\\n                context.componentWillMount(),\\n              \"function\" === typeof context.UNSAFE_componentWillMount &&\\n                context.UNSAFE_componentWillMount()),\\n            \"function\" === typeof context.componentDidMount &&\\n              (workInProgress.flags |= 4194308))\\n          : (\"function\" === typeof context.componentDidMount &&\\n              (workInProgress.flags |= 4194308),\\n            (workInProgress.memoizedProps = nextProps),\\n            (workInProgress.memoizedState = oldContext)),\\n        (context.props = nextProps),\\n        (context.state = oldContext),\\n        (context.context = contextType),\\n        (nextProps = oldProps))\\n      : (\"function\" === typeof context.componentDidMount &&\\n          (workInProgress.flags |= 4194308),\\n        (nextProps = !1));\\n  } else {\\n    context = workInProgress.stateNode;\\n    cloneUpdateQueue(current, workInProgress);\\n    contextType = workInProgress.memoizedProps;\\n    contextType$jscomp$0 = resolveClassComponentProps(Component, contextType);\\n    context.props = contextType$jscomp$0;\\n    getDerivedStateFromProps = workInProgress.pendingProps;\\n    oldState = context.context;\\n    oldContext = Component.contextType;\\n    oldProps = emptyContextObject;\\n    \"object\" === typeof oldContext &&\\n      null !== oldContext &&\\n      (oldProps = readContext(oldContext));\\n    unresolvedOldProps = Component.getDerivedStateFromProps;\\n    (oldContext =\\n      \"function\" === typeof unresolvedOldProps ||\\n      \"function\" === typeof context.getSnapshotBeforeUpdate) ||\\n      (\"function\" !== typeof context.UNSAFE_componentWillReceiveProps &&\\n        \"function\" !== typeof context.componentWillReceiveProps) ||\\n      ((contextType !== getDerivedStateFromProps || oldState !== oldProps) &&\\n        callComponentWillReceiveProps(\\n          workInProgress,\\n          context,\\n          nextProps,\\n          oldProps\\n        ));\\n    hasForceUpdate = !1;\\n    oldState = workInProgress.memoizedState;\\n    context.state = oldState;\\n    processUpdateQueue(workInProgress, nextProps, context, renderLanes);\\n    suspendIfUpdateReadFromEntangledAsyncAction();\\n    var newState = workInProgress.memoizedState;\\n    contextType !== getDerivedStateFromProps ||\\n    oldState !== newState ||\\n    hasForceUpdate ||\\n    (null !== current &&\\n      null !== current.dependencies &&\\n      checkIfContextChanged(current.dependencies))\\n      ? (\"function\" === typeof unresolvedOldProps &&\\n          (applyDerivedStateFromProps(\\n            workInProgress,\\n            Component,\\n            unresolvedOldProps,\\n            nextProps\\n          ),\\n          (newState = workInProgress.memoizedState)),\\n        (contextType$jscomp$0 =\\n          hasForceUpdate ||\\n          checkShouldComponentUpdate(\\n            workInProgress,\\n            Component,\\n            contextType$jscomp$0,\\n            nextProps,\\n            oldState,\\n            newState,\\n            oldProps\\n          ) ||\\n          (null !== current &&\\n            null !== current.dependencies &&\\n            checkIfContextChanged(current.dependencies)))\\n          ? (oldContext ||\\n              (\"function\" !== typeof context.UNSAFE_componentWillUpdate &&\\n                \"function\" !== typeof context.componentWillUpdate) ||\\n              (\"function\" === typeof context.componentWillUpdate &&\\n                context.componentWillUpdate(nextProps, newState, oldProps),\\n              \"function\" === typeof context.UNSAFE_componentWillUpdate &&\\n                context.UNSAFE_componentWillUpdate(\\n                  nextProps,\\n                  newState,\\n                  oldProps\\n                )),\\n            \"function\" === typeof context.componentDidUpdate &&\\n              (workInProgress.flags |= 4),\\n            \"function\" === typeof context.getSnapshotBeforeUpdate &&\\n              (workInProgress.flags |= 1024))\\n          : (\"function\" !== typeof context.componentDidUpdate ||\\n              (contextType === current.memoizedProps &&\\n                oldState === current.memoizedState) ||\\n              (workInProgress.flags |= 4),\\n            \"function\" !== typeof context.getSnapshotBeforeUpdate ||\\n              (contextType === current.memoizedProps &&\\n                oldState === current.memoizedState) ||\\n              (workInProgress.flags |= 1024),\\n            (workInProgress.memoizedProps = nextProps),\\n            (workInProgress.memoizedState = newState)),\\n        (context.props = nextProps),\\n        (context.state = newState),\\n        (context.context = oldProps),\\n        (nextProps = contextType$jscomp$0))\\n      : (\"function\" !== typeof context.componentDidUpdate ||\\n          (contextType === current.memoizedProps &&\\n            oldState === current.memoizedState) ||\\n          (workInProgress.flags |= 4),\\n        \"function\" !== typeof context.getSnapshotBeforeUpdate ||\\n          (contextType === current.memoizedProps &&\\n            oldState === current.memoizedState) ||\\n          (workInProgress.flags |= 1024),\\n        (nextProps = !1));\\n  }\\n  context = nextProps;\\n  markRef(current, workInProgress);\\n  nextProps = 0 !== (workInProgress.flags & 128);\\n  context || nextProps\\n    ? ((context = workInProgress.stateNode),\\n      (Component =\\n        nextProps && \"function\" !== typeof Component.getDerivedStateFromError\\n          ? null\\n          : context.render()),\\n      (workInProgress.flags |= 1),\\n      null !== current && nextProps\\n        ? ((workInProgress.child = reconcileChildFibers(\\n            workInProgress,\\n            current.child,\\n            null,\\n            renderLanes\\n          )),\\n          (workInProgress.child = reconcileChildFibers(\\n            workInProgress,\\n            null,\\n            Component,\\n            renderLanes\\n          )))\\n        : reconcileChildren(current, workInProgress, Component, renderLanes),\\n      (workInProgress.memoizedState = context.state),\\n      (current = workInProgress.child))\\n    : (current = bailoutOnAlreadyFinishedWork(\\n        current,\\n        workInProgress,\\n        renderLanes\\n      ));\\n  return current;\\n}\\nfunction mountHostRootWithoutHydrating(\\n  current,\\n  workInProgress,\\n  nextChildren,\\n  renderLanes\\n) {\\n  resetHydrationState();\\n  workInProgress.flags |= 256;\\n  reconcileChildren(current, workInProgress, nextChildren, renderLanes);\\n  return workInProgress.child;\\n}\\nvar SUSPENDED_MARKER = {\\n  dehydrated: null,\\n  treeContext: null,\\n  retryLane: 0,\\n  hydrationErrors: null\\n};\\nfunction mountSuspenseOffscreenState(renderLanes) {\\n  return { baseLanes: renderLanes, cachePool: getSuspendedCache() };\\n}\\nfunction getRemainingWorkInPrimaryTree(\\n  current,\\n  primaryTreeDidDefer,\\n  renderLanes\\n) {\\n  current = null !== current ? current.childLanes & ~renderLanes : 0;\\n  primaryTreeDidDefer && (current |= workInProgressDeferredLane);\\n  return current;\\n}\\nfunction updateSuspenseComponent(current, workInProgress, renderLanes) {\\n  var nextProps = workInProgress.pendingProps,\\n    showFallback = !1,\\n    didSuspend = 0 !== (workInProgress.flags & 128),\\n    JSCompiler_temp;\\n  (JSCompiler_temp = didSuspend) ||\\n    (JSCompiler_temp =\\n      null !== current && null === current.memoizedState\\n        ? !1\\n        : 0 !== (suspenseStackCursor.current & 2));\\n  JSCompiler_temp && ((showFallback = !0), (workInProgress.flags &= -129));\\n  JSCompiler_temp = 0 !== (workInProgress.flags & 32);\\n  workInProgress.flags &= -33;\\n  if (null === current) {\\n    if (isHydrating) {\\n      showFallback\\n        ? pushPrimaryTreeSuspenseHandler(workInProgress)\\n        : reuseSuspenseHandlerOnStack(workInProgress);\\n      if (isHydrating) {\\n        var nextInstance = nextHydratableInstance,\\n          JSCompiler_temp$jscomp$0;\\n        if ((JSCompiler_temp$jscomp$0 = nextInstance)) {\\n          c: {\\n            JSCompiler_temp$jscomp$0 = nextInstance;\\n            for (\\n              nextInstance = rootOrSingletonContext;\\n              8 !== JSCompiler_temp$jscomp$0.nodeType;\\n\\n            ) {\\n              if (!nextInstance) {\\n                nextInstance = null;\\n                break c;\\n              }\\n              JSCompiler_temp$jscomp$0 = getNextHydratable(\\n                JSCompiler_temp$jscomp$0.nextSibling\\n              );\\n              if (null === JSCompiler_temp$jscomp$0) {\\n                nextInstance = null;\\n                break c;\\n              }\\n            }\\n            nextInstance = JSCompiler_temp$jscomp$0;\\n          }\\n          null !== nextInstance\\n            ? ((workInProgress.memoizedState = {\\n                dehydrated: nextInstance,\\n                treeContext:\\n                  null !== treeContextProvider\\n                    ? { id: treeContextId, overflow: treeContextOverflow }\\n                    : null,\\n                retryLane: 536870912,\\n                hydrationErrors: null\\n              }),\\n              (JSCompiler_temp$jscomp$0 = createFiberImplClass(\\n                18,\\n                null,\\n                null,\\n                0\\n              )),\\n              (JSCompiler_temp$jscomp$0.stateNode = nextInstance),\\n              (JSCompiler_temp$jscomp$0.return = workInProgress),\\n              (workInProgress.child = JSCompiler_temp$jscomp$0),\\n              (hydrationParentFiber = workInProgress),\\n              (nextHydratableInstance = null),\\n              (JSCompiler_temp$jscomp$0 = !0))\\n            : (JSCompiler_temp$jscomp$0 = !1);\\n        }\\n        JSCompiler_temp$jscomp$0 || throwOnHydrationMismatch(workInProgress);\\n      }\\n      nextInstance = workInProgress.memoizedState;\\n      if (\\n        null !== nextInstance &&\\n        ((nextInstance = nextInstance.dehydrated), null !== nextInstance)\\n      )\\n        return (\\n          isSuspenseInstanceFallback(nextInstance)\\n            ? (workInProgress.lanes = 32)\\n            : (workInProgress.lanes = 536870912),\\n          null\\n        );\\n      popSuspenseHandler(workInProgress);\\n    }\\n    nextInstance = nextProps.children;\\n    nextProps = nextProps.fallback;\\n    if (showFallback)\\n      return (\\n        reuseSuspenseHandlerOnStack(workInProgress),\\n        (showFallback = workInProgress.mode),\\n        (nextInstance = mountWorkInProgressOffscreenFiber(\\n          { mode: \"hidden\", children: nextInstance },\\n          showFallback\\n        )),\\n        (nextProps = createFiberFromFragment(\\n          nextProps,\\n          showFallback,\\n          renderLanes,\\n          null\\n        )),\\n        (nextInstance.return = workInProgress),\\n        (nextProps.return = workInProgress),\\n        (nextInstance.sibling = nextProps),\\n        (workInProgress.child = nextInstance),\\n        (showFallback = workInProgress.child),\\n        (showFallback.memoizedState = mountSuspenseOffscreenState(renderLanes)),\\n        (showFallback.childLanes = getRemainingWorkInPrimaryTree(\\n          current,\\n          JSCompiler_temp,\\n          renderLanes\\n        )),\\n        (workInProgress.memoizedState = SUSPENDED_MARKER),\\n        nextProps\\n      );\\n    pushPrimaryTreeSuspenseHandler(workInProgress);\\n    return mountSuspensePrimaryChildren(workInProgress, nextInstance);\\n  }\\n  JSCompiler_temp$jscomp$0 = current.memoizedState;\\n  if (\\n    null !== JSCompiler_temp$jscomp$0 &&\\n    ((nextInstance = JSCompiler_temp$jscomp$0.dehydrated),\\n    null !== nextInstance)\\n  ) {\\n    if (didSuspend)\\n      workInProgress.flags & 256\\n        ? (pushPrimaryTreeSuspenseHandler(workInProgress),\\n          (workInProgress.flags &= -257),\\n          (workInProgress = retrySuspenseComponentWithoutHydrating(\\n            current,\\n            workInProgress,\\n            renderLanes\\n          )))\\n        : null !== workInProgress.memoizedState\\n          ? (reuseSuspenseHandlerOnStack(workInProgress),\\n            (workInProgress.child = current.child),\\n            (workInProgress.flags |= 128),\\n            (workInProgress = null))\\n          : (reuseSuspenseHandlerOnStack(workInProgress),\\n            (showFallback = nextProps.fallback),\\n            (nextInstance = workInProgress.mode),\\n            (nextProps = mountWorkInProgressOffscreenFiber(\\n              { mode: \"visible\", children: nextProps.children },\\n              nextInstance\\n            )),\\n            (showFallback = createFiberFromFragment(\\n              showFallback,\\n              nextInstance,\\n              renderLanes,\\n              null\\n            )),\\n            (showFallback.flags |= 2),\\n            (nextProps.return = workInProgress),\\n            (showFallback.return = workInProgress),\\n            (nextProps.sibling = showFallback),\\n            (workInProgress.child = nextProps),\\n            reconcileChildFibers(\\n              workInProgress,\\n              current.child,\\n              null,\\n              renderLanes\\n            ),\\n            (nextProps = workInProgress.child),\\n            (nextProps.memoizedState =\\n              mountSuspenseOffscreenState(renderLanes)),\\n            (nextProps.childLanes = getRemainingWorkInPrimaryTree(\\n              current,\\n              JSCompiler_temp,\\n              renderLanes\\n            )),\\n            (workInProgress.memoizedState = SUSPENDED_MARKER),\\n            (workInProgress = showFallback));\\n    else if (\\n      (pushPrimaryTreeSuspenseHandler(workInProgress),\\n      isSuspenseInstanceFallback(nextInstance))\\n    ) {\\n      JSCompiler_temp =\\n        nextInstance.nextSibling && nextInstance.nextSibling.dataset;\\n      if (JSCompiler_temp) var digest = JSCompiler_temp.dgst;\\n      JSCompiler_temp = digest;\\n      nextProps = Error(formatProdErrorMessage(419));\\n      nextProps.stack = \"\";\\n      nextProps.digest = JSCompiler_temp;\\n      queueHydrationError({ value: nextProps, source: null, stack: null });\\n      workInProgress = retrySuspenseComponentWithoutHydrating(\\n        current,\\n        workInProgress,\\n        renderLanes\\n      );\\n    } else if (\\n      (didReceiveUpdate ||\\n        propagateParentContextChanges(current, workInProgress, renderLanes, !1),\\n      (JSCompiler_temp = 0 !== (renderLanes & current.childLanes)),\\n      didReceiveUpdate || JSCompiler_temp)\\n    ) {\\n      JSCompiler_temp = workInProgressRoot;\\n      if (\\n        null !== JSCompiler_temp &&\\n        ((nextProps = renderLanes & -renderLanes),\\n        (nextProps =\\n          0 !== (nextProps & 42)\\n            ? 1\\n            : getBumpedLaneForHydrationByLane(nextProps)),\\n        (nextProps =\\n          0 !== (nextProps & (JSCompiler_temp.suspendedLanes | renderLanes))\\n            ? 0\\n            : nextProps),\\n        0 !== nextProps && nextProps !== JSCompiler_temp$jscomp$0.retryLane)\\n      )\\n        throw (\\n          ((JSCompiler_temp$jscomp$0.retryLane = nextProps),\\n          enqueueConcurrentRenderForLane(current, nextProps),\\n          scheduleUpdateOnFiber(JSCompiler_temp, current, nextProps),\\n          SelectiveHydrationException)\\n        );\\n      \"$?\" === nextInstance.data || renderDidSuspendDelayIfPossible();\\n      workInProgress = retrySuspenseComponentWithoutHydrating(\\n        current,\\n        workInProgress,\\n        renderLanes\\n      );\\n    } else\\n      \"$?\" === nextInstance.data\\n        ? ((workInProgress.flags |= 192),\\n          (workInProgress.child = current.child),\\n          (workInProgress = null))\\n        : ((current = JSCompiler_temp$jscomp$0.treeContext),\\n          (nextHydratableInstance = getNextHydratable(\\n            nextInstance.nextSibling\\n          )),\\n          (hydrationParentFiber = workInProgress),\\n          (isHydrating = !0),\\n          (hydrationErrors = null),\\n          (rootOrSingletonContext = !1),\\n          null !== current &&\\n            ((idStack[idStackIndex++] = treeContextId),\\n            (idStack[idStackIndex++] = treeContextOverflow),\\n            (idStack[idStackIndex++] = treeContextProvider),\\n            (treeContextId = current.id),\\n            (treeContextOverflow = current.overflow),\\n            (treeContextProvider = workInProgress)),\\n          (workInProgress = mountSuspensePrimaryChildren(\\n            workInProgress,\\n            nextProps.children\\n          )),\\n          (workInProgress.flags |= 4096));\\n    return workInProgress;\\n  }\\n  if (showFallback)\\n    return (\\n      reuseSuspenseHandlerOnStack(workInProgress),\\n      (showFallback = nextProps.fallback),\\n      (nextInstance = workInProgress.mode),\\n      (JSCompiler_temp$jscomp$0 = current.child),\\n      (digest = JSCompiler_temp$jscomp$0.sibling),\\n      (nextProps = createWorkInProgress(JSCompiler_temp$jscomp$0, {\\n        mode: \"hidden\",\\n        children: nextProps.children\\n      })),\\n      (nextProps.subtreeFlags =\\n        JSCompiler_temp$jscomp$0.subtreeFlags & 65011712),\\n      null !== digest\\n        ? (showFallback = createWorkInProgress(digest, showFallback))\\n        : ((showFallback = createFiberFromFragment(\\n            showFallback,\\n            nextInstance,\\n            renderLanes,\\n            null\\n          )),\\n          (showFallback.flags |= 2)),\\n      (showFallback.return = workInProgress),\\n      (nextProps.return = workInProgress),\\n      (nextProps.sibling = showFallback),\\n      (workInProgress.child = nextProps),\\n      (nextProps = showFallback),\\n      (showFallback = workInProgress.child),\\n      (nextInstance = current.child.memoizedState),\\n      null === nextInstance\\n        ? (nextInstance = mountSuspenseOffscreenState(renderLanes))\\n        : ((JSCompiler_temp$jscomp$0 = nextInstance.cachePool),\\n          null !== JSCompiler_temp$jscomp$0\\n            ? ((digest = CacheContext._currentValue),\\n              (JSCompiler_temp$jscomp$0 =\\n                JSCompiler_temp$jscomp$0.parent !== digest\\n                  ? { parent: digest, pool: digest }\\n                  : JSCompiler_temp$jscomp$0))\\n            : (JSCompiler_temp$jscomp$0 = getSuspendedCache()),\\n          (nextInstance = {\\n            baseLanes: nextInstance.baseLanes | renderLanes,\\n            cachePool: JSCompiler_temp$jscomp$0\\n          })),\\n      (showFallback.memoizedState = nextInstance),\\n      (showFallback.childLanes = getRemainingWorkInPrimaryTree(\\n        current,\\n        JSCompiler_temp,\\n        renderLanes\\n      )),\\n      (workInProgress.memoizedState = SUSPENDED_MARKER),\\n      nextProps\\n    );\\n  pushPrimaryTreeSuspenseHandler(workInProgress);\\n  renderLanes = current.child;\\n  current = renderLanes.sibling;\\n  renderLanes = createWorkInProgress(renderLanes, {\\n    mode: \"visible\",\\n    children: nextProps.children\\n  });\\n  renderLanes.return = workInProgress;\\n  renderLanes.sibling = null;\\n  null !== current &&\\n    ((JSCompiler_temp = workInProgress.deletions),\\n    null === JSCompiler_temp\\n      ? ((workInProgress.deletions = [current]), (workInProgress.flags |= 16))\\n      : JSCompiler_temp.push(current));\\n  workInProgress.child = renderLanes;\\n  workInProgress.memoizedState = null;\\n  return renderLanes;\\n}\\nfunction mountSuspensePrimaryChildren(workInProgress, primaryChildren) {\\n  primaryChildren = mountWorkInProgressOffscreenFiber(\\n    { mode: \"visible\", children: primaryChildren },\\n    workInProgress.mode\\n  );\\n  primaryChildren.return = workInProgress;\\n  return (workInProgress.child = primaryChildren);\\n}\\nfunction mountWorkInProgressOffscreenFiber(offscreenProps, mode) {\\n  offscreenProps = createFiberImplClass(22, offscreenProps, null, mode);\\n  offscreenProps.lanes = 0;\\n  offscreenProps.stateNode = {\\n    _visibility: 1,\\n    _pendingMarkers: null,\\n    _retryCache: null,\\n    _transitions: null\\n  };\\n  return offscreenProps;\\n}\\nfunction retrySuspenseComponentWithoutHydrating(\\n  current,\\n  workInProgress,\\n  renderLanes\\n) {\\n  reconcileChildFibers(workInProgress, current.child, null, renderLanes);\\n  current = mountSuspensePrimaryChildren(\\n    workInProgress,\\n    workInProgress.pendingProps.children\\n  );\\n  current.flags |= 2;\\n  workInProgress.memoizedState = null;\\n  return current;\\n}\\nfunction scheduleSuspenseWorkOnFiber(fiber, renderLanes, propagationRoot) {\\n  fiber.lanes |= renderLanes;\\n  var alternate = fiber.alternate;\\n  null !== alternate && (alternate.lanes |= renderLanes);\\n  scheduleContextWorkOnParentPath(fiber.return, renderLanes, propagationRoot);\\n}\\nfunction initSuspenseListRenderState(\\n  workInProgress,\\n  isBackwards,\\n  tail,\\n  lastContentRow,\\n  tailMode\\n) {\\n  var renderState = workInProgress.memoizedState;\\n  null === renderState\\n    ? (workInProgress.memoizedState = {\\n        isBackwards: isBackwards,\\n        rendering: null,\\n        renderingStartTime: 0,\\n        last: lastContentRow,\\n        tail: tail,\\n        tailMode: tailMode\\n      })\\n    : ((renderState.isBackwards = isBackwards),\\n      (renderState.rendering = null),\\n      (renderState.renderingStartTime = 0),\\n      (renderState.last = lastContentRow),\\n      (renderState.tail = tail),\\n      (renderState.tailMode = tailMode));\\n}\\nfunction updateSuspenseListComponent(current, workInProgress, renderLanes) {\\n  var nextProps = workInProgress.pendingProps,\\n    revealOrder = nextProps.revealOrder,\\n    tailMode = nextProps.tail;\\n  reconcileChildren(current, workInProgress, nextProps.children, renderLanes);\\n  nextProps = suspenseStackCursor.current;\\n  if (0 !== (nextProps & 2))\\n    (nextProps = (nextProps & 1) | 2), (workInProgress.flags |= 128);\\n  else {\\n    if (null !== current && 0 !== (current.flags & 128))\\n      a: for (current = workInProgress.child; null !== current; ) {\\n        if (13 === current.tag)\\n          null !== current.memoizedState &&\\n            scheduleSuspenseWorkOnFiber(current, renderLanes, workInProgress);\\n        else if (19 === current.tag)\\n          scheduleSuspenseWorkOnFiber(current, renderLanes, workInProgress);\\n        else if (null !== current.child) {\\n          current.child.return = current;\\n          current = current.child;\\n          continue;\\n        }\\n        if (current === workInProgress) break a;\\n        for (; null === current.sibling; ) {\\n          if (null === current.return || current.return === workInProgress)\\n            break a;\\n          current = current.return;\\n        }\\n        current.sibling.return = current.return;\\n        current = current.sibling;\\n      }\\n    nextProps &= 1;\\n  }\\n  push(suspenseStackCursor, nextProps);\\n  switch (revealOrder) {\\n    case \"forwards\":\\n      renderLanes = workInProgress.child;\\n      for (revealOrder = null; null !== renderLanes; )\\n        (current = renderLanes.alternate),\\n          null !== current &&\\n            null === findFirstSuspended(current) &&\\n            (revealOrder = renderLanes),\\n          (renderLanes = renderLanes.sibling);\\n      renderLanes = revealOrder;\\n      null === renderLanes\\n        ? ((revealOrder = workInProgress.child), (workInProgress.child = null))\\n        : ((revealOrder = renderLanes.sibling), (renderLanes.sibling = null));\\n      initSuspenseListRenderState(\\n        workInProgress,\\n        !1,\\n        revealOrder,\\n        renderLanes,\\n        tailMode\\n      );\\n      break;\\n    case \"backwards\":\\n      renderLanes = null;\\n      revealOrder = workInProgress.child;\\n      for (workInProgress.child = null; null !== revealOrder; ) {\\n        current = revealOrder.alternate;\\n        if (null !== current && null === findFirstSuspended(current)) {\\n          workInProgress.child = revealOrder;\\n          break;\\n        }\\n        current = revealOrder.sibling;\\n        revealOrder.sibling = renderLanes;\\n        renderLanes = revealOrder;\\n        revealOrder = current;\\n      }\\n      initSuspenseListRenderState(\\n        workInProgress,\\n        !0,\\n        renderLanes,\\n        null,\\n        tailMode\\n      );\\n      break;\\n    case \"together\":\\n      initSuspenseListRenderState(workInProgress, !1, null, null, void 0);\\n      break;\\n    default:\\n      workInProgress.memoizedState = null;\\n  }\\n  return workInProgress.child;\\n}\\nfunction bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes) {\\n  null !== current && (workInProgress.dependencies = current.dependencies);\\n  workInProgressRootSkippedLanes |= workInProgress.lanes;\\n  if (0 === (renderLanes & workInProgress.childLanes))\\n    if (null !== current) {\\n      if (\\n        (propagateParentContextChanges(\\n          current,\\n          workInProgress,\\n          renderLanes,\\n          !1\\n        ),\\n        0 === (renderLanes & workInProgress.childLanes))\\n      )\\n        return null;\\n    } else return null;\\n  if (null !== current && workInProgress.child !== current.child)\\n    throw Error(formatProdErrorMessage(153));\\n  if (null !== workInProgress.child) {\\n    current = workInProgress.child;\\n    renderLanes = createWorkInProgress(current, current.pendingProps);\\n    workInProgress.child = renderLanes;\\n    for (renderLanes.return = workInProgress; null !== current.sibling; )\\n      (current = current.sibling),\\n        (renderLanes = renderLanes.sibling =\\n          createWorkInProgress(current, current.pendingProps)),\\n        (renderLanes.return = workInProgress);\\n    renderLanes.sibling = null;\\n  }\\n  return workInProgress.child;\\n}\\nfunction checkScheduledUpdateOrContext(current, renderLanes) {\\n  if (0 !== (current.lanes & renderLanes)) return !0;\\n  current = current.dependencies;\\n  return null !== current && checkIfContextChanged(current) ? !0 : !1;\\n}\\nfunction attemptEarlyBailoutIfNoScheduledUpdate(\\n  current,\\n  workInProgress,\\n  renderLanes\\n) {\\n  switch (workInProgress.tag) {\\n    case 3:\\n      pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);\\n      pushProvider(workInProgress, CacheContext, current.memoizedState.cache);\\n      resetHydrationState();\\n      break;\\n    case 27:\\n    case 5:\\n      pushHostContext(workInProgress);\\n      break;\\n    case 4:\\n      pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);\\n      break;\\n    case 10:\\n      pushProvider(\\n        workInProgress,\\n        workInProgress.type,\\n        workInProgress.memoizedProps.value\\n      );\\n      break;\\n    case 13:\\n      var state = workInProgress.memoizedState;\\n      if (null !== state) {\\n        if (null !== state.dehydrated)\\n          return (\\n            pushPrimaryTreeSuspenseHandler(workInProgress),\\n            (workInProgress.flags |= 128),\\n            null\\n          );\\n        if (0 !== (renderLanes & workInProgress.child.childLanes))\\n          return updateSuspenseComponent(current, workInProgress, renderLanes);\\n        pushPrimaryTreeSuspenseHandler(workInProgress);\\n        current = bailoutOnAlreadyFinishedWork(\\n          current,\\n          workInProgress,\\n          renderLanes\\n        );\\n        return null !== current ? current.sibling : null;\\n      }\\n      pushPrimaryTreeSuspenseHandler(workInProgress);\\n      break;\\n    case 19:\\n      var didSuspendBefore = 0 !== (current.flags & 128);\\n      state = 0 !== (renderLanes & workInProgress.childLanes);\\n      state ||\\n        (propagateParentContextChanges(\\n          current,\\n          workInProgress,\\n          renderLanes,\\n          !1\\n        ),\\n        (state = 0 !== (renderLanes & workInProgress.childLanes)));\\n      if (didSuspendBefore) {\\n        if (state)\\n          return updateSuspenseListComponent(\\n            current,\\n            workInProgress,\\n            renderLanes\\n          );\\n        workInProgress.flags |= 128;\\n      }\\n      didSuspendBefore = workInProgress.memoizedState;\\n      null !== didSuspendBefore &&\\n        ((didSuspendBefore.rendering = null),\\n        (didSuspendBefore.tail = null),\\n        (didSuspendBefore.lastEffect = null));\\n      push(suspenseStackCursor, suspenseStackCursor.current);\\n      if (state) break;\\n      else return null;\\n    case 22:\\n    case 23:\\n      return (\\n        (workInProgress.lanes = 0),\\n        updateOffscreenComponent(current, workInProgress, renderLanes)\\n      );\\n    case 24:\\n      pushProvider(workInProgress, CacheContext, current.memoizedState.cache);\\n  }\\n  return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\\n}\\nfunction beginWork(current, workInProgress, renderLanes) {\\n  if (null !== current)\\n    if (current.memoizedProps !== workInProgress.pendingProps)\\n      didReceiveUpdate = !0;\\n    else {\\n      if (\\n        !checkScheduledUpdateOrContext(current, renderLanes) &&\\n        0 === (workInProgress.flags & 128)\\n      )\\n        return (\\n          (didReceiveUpdate = !1),\\n          attemptEarlyBailoutIfNoScheduledUpdate(\\n            current,\\n            workInProgress,\\n            renderLanes\\n          )\\n        );\\n      didReceiveUpdate = 0 !== (current.flags & 131072) ? !0 : !1;\\n    }\\n  else\\n    (didReceiveUpdate = !1),\\n      isHydrating &&\\n        0 !== (workInProgress.flags & 1048576) &&\\n        pushTreeId(workInProgress, treeForkCount, workInProgress.index);\\n  workInProgress.lanes = 0;\\n  switch (workInProgress.tag) {\\n    case 16:\\n      a: {\\n        current = workInProgress.pendingProps;\\n        var lazyComponent = workInProgress.elementType,\\n          init = lazyComponent._init;\\n        lazyComponent = init(lazyComponent._payload);\\n        workInProgress.type = lazyComponent;\\n        if (\"function\" === typeof lazyComponent)\\n          shouldConstruct(lazyComponent)\\n            ? ((current = resolveClassComponentProps(lazyComponent, current)),\\n              (workInProgress.tag = 1),\\n              (workInProgress = updateClassComponent(\\n                null,\\n                workInProgress,\\n                lazyComponent,\\n                current,\\n                renderLanes\\n              )))\\n            : ((workInProgress.tag = 0),\\n              (workInProgress = updateFunctionComponent(\\n                null,\\n                workInProgress,\\n                lazyComponent,\\n                current,\\n                renderLanes\\n              )));\\n        else {\\n          if (void 0 !== lazyComponent && null !== lazyComponent)\\n            if (\\n              ((init = lazyComponent.$$typeof), init === REACT_FORWARD_REF_TYPE)\\n            ) {\\n              workInProgress.tag = 11;\\n              workInProgress = updateForwardRef(\\n                null,\\n                workInProgress,\\n                lazyComponent,\\n                current,\\n                renderLanes\\n              );\\n              break a;\\n            } else if (init === REACT_MEMO_TYPE) {\\n              workInProgress.tag = 14;\\n              workInProgress = updateMemoComponent(\\n                null,\\n                workInProgress,\\n                lazyComponent,\\n                current,\\n                renderLanes\\n              );\\n              break a;\\n            }\\n          workInProgress =\\n            getComponentNameFromType(lazyComponent) || lazyComponent;\\n          throw Error(formatProdErrorMessage(306, workInProgress, \"\"));\\n        }\\n      }\\n      return workInProgress;\\n    case 0:\\n      return updateFunctionComponent(\\n        current,\\n        workInProgress,\\n        workInProgress.type,\\n        workInProgress.pendingProps,\\n        renderLanes\\n      );\\n    case 1:\\n      return (\\n        (lazyComponent = workInProgress.type),\\n        (init = resolveClassComponentProps(\\n          lazyComponent,\\n          workInProgress.pendingProps\\n        )),\\n        updateClassComponent(\\n          current,\\n          workInProgress,\\n          lazyComponent,\\n          init,\\n          renderLanes\\n        )\\n      );\\n    case 3:\\n      a: {\\n        pushHostContainer(\\n          workInProgress,\\n          workInProgress.stateNode.containerInfo\\n        );\\n        if (null === current) throw Error(formatProdErrorMessage(387));\\n        lazyComponent = workInProgress.pendingProps;\\n        var prevState = workInProgress.memoizedState;\\n        init = prevState.element;\\n        cloneUpdateQueue(current, workInProgress);\\n        processUpdateQueue(workInProgress, lazyComponent, null, renderLanes);\\n        var nextState = workInProgress.memoizedState;\\n        lazyComponent = nextState.cache;\\n        pushProvider(workInProgress, CacheContext, lazyComponent);\\n        lazyComponent !== prevState.cache &&\\n          propagateContextChanges(\\n            workInProgress,\\n            [CacheContext],\\n            renderLanes,\\n            !0\\n          );\\n        suspendIfUpdateReadFromEntangledAsyncAction();\\n        lazyComponent = nextState.element;\\n        if (prevState.isDehydrated)\\n          if (\\n            ((prevState = {\\n              element: lazyComponent,\\n              isDehydrated: !1,\\n              cache: nextState.cache\\n            }),\\n            (workInProgress.updateQueue.baseState = prevState),\\n            (workInProgress.memoizedState = prevState),\\n            workInProgress.flags & 256)\\n          ) {\\n            workInProgress = mountHostRootWithoutHydrating(\\n              current,\\n              workInProgress,\\n              lazyComponent,\\n              renderLanes\\n            );\\n            break a;\\n          } else if (lazyComponent !== init) {\\n            init = createCapturedValueAtFiber(\\n              Error(formatProdErrorMessage(424)),\\n              workInProgress\\n            );\\n            queueHydrationError(init);\\n            workInProgress = mountHostRootWithoutHydrating(\\n              current,\\n              workInProgress,\\n              lazyComponent,\\n              renderLanes\\n            );\\n            break a;\\n          } else {\\n            current = workInProgress.stateNode.containerInfo;\\n            switch (current.nodeType) {\\n              case 9:\\n                current = current.body;\\n                break;\\n              default:\\n                current =\\n                  \"HTML\" === current.nodeName\\n                    ? current.ownerDocument.body\\n                    : current;\\n            }\\n            nextHydratableInstance = getNextHydratable(current.firstChild);\\n            hydrationParentFiber = workInProgress;\\n            isHydrating = !0;\\n            hydrationErrors = null;\\n            rootOrSingletonContext = !0;\\n            renderLanes = mountChildFibers(\\n              workInProgress,\\n              null,\\n              lazyComponent,\\n              renderLanes\\n            );\\n            for (workInProgress.child = renderLanes; renderLanes; )\\n              (renderLanes.flags = (renderLanes.flags & -3) | 4096),\\n                (renderLanes = renderLanes.sibling);\\n          }\\n        else {\\n          resetHydrationState();\\n          if (lazyComponent === init) {\\n            workInProgress = bailoutOnAlreadyFinishedWork(\\n              current,\\n              workInProgress,\\n              renderLanes\\n            );\\n            break a;\\n          }\\n          reconcileChildren(\\n            current,\\n            workInProgress,\\n            lazyComponent,\\n            renderLanes\\n          );\\n        }\\n        workInProgress = workInProgress.child;\\n      }\\n      return workInProgress;\\n    case 26:\\n      return (\\n        markRef(current, workInProgress),\\n        null === current\\n          ? (renderLanes = getResource(\\n              workInProgress.type,\\n              null,\\n              workInProgress.pendingProps,\\n              null\\n            ))\\n            ? (workInProgress.memoizedState = renderLanes)\\n            : isHydrating ||\\n              ((renderLanes = workInProgress.type),\\n              (current = workInProgress.pendingProps),\\n              (lazyComponent = getOwnerDocumentFromRootContainer(\\n                rootInstanceStackCursor.current\\n              ).createElement(renderLanes)),\\n              (lazyComponent[internalInstanceKey] = workInProgress),\\n              (lazyComponent[internalPropsKey] = current),\\n              setInitialProperties(lazyComponent, renderLanes, current),\\n              markNodeAsHoistable(lazyComponent),\\n              (workInProgress.stateNode = lazyComponent))\\n          : (workInProgress.memoizedState = getResource(\\n              workInProgress.type,\\n              current.memoizedProps,\\n              workInProgress.pendingProps,\\n              current.memoizedState\\n            )),\\n        null\\n      );\\n    case 27:\\n      return (\\n        pushHostContext(workInProgress),\\n        null === current &&\\n          isHydrating &&\\n          ((lazyComponent = workInProgress.stateNode =\\n            resolveSingletonInstance(\\n              workInProgress.type,\\n              workInProgress.pendingProps,\\n              rootInstanceStackCursor.current\\n            )),\\n          (hydrationParentFiber = workInProgress),\\n          (rootOrSingletonContext = !0),\\n          (init = nextHydratableInstance),\\n          isSingletonScope(workInProgress.type)\\n            ? ((previousHydratableOnEnteringScopedSingleton = init),\\n              (nextHydratableInstance = getNextHydratable(\\n                lazyComponent.firstChild\\n              )))\\n            : (nextHydratableInstance = init)),\\n        reconcileChildren(\\n          current,\\n          workInProgress,\\n          workInProgress.pendingProps.children,\\n          renderLanes\\n        ),\\n        markRef(current, workInProgress),\\n        null === current && (workInProgress.flags |= 4194304),\\n        workInProgress.child\\n      );\\n    case 5:\\n      if (null === current && isHydrating) {\\n        if ((init = lazyComponent = nextHydratableInstance))\\n          (lazyComponent = canHydrateInstance(\\n            lazyComponent,\\n            workInProgress.type,\\n            workInProgress.pendingProps,\\n            rootOrSingletonContext\\n          )),\\n            null !== lazyComponent\\n              ? ((workInProgress.stateNode = lazyComponent),\\n                (hydrationParentFiber = workInProgress),\\n                (nextHydratableInstance = getNextHydratable(\\n                  lazyComponent.firstChild\\n                )),\\n                (rootOrSingletonContext = !1),\\n                (init = !0))\\n              : (init = !1);\\n        init || throwOnHydrationMismatch(workInProgress);\\n      }\\n      pushHostContext(workInProgress);\\n      init = workInProgress.type;\\n      prevState = workInProgress.pendingProps;\\n      nextState = null !== current ? current.memoizedProps : null;\\n      lazyComponent = prevState.children;\\n      shouldSetTextContent(init, prevState)\\n        ? (lazyComponent = null)\\n        : null !== nextState &&\\n          shouldSetTextContent(init, nextState) &&\\n          (workInProgress.flags |= 32);\\n      null !== workInProgress.memoizedState &&\\n        ((init = renderWithHooks(\\n          current,\\n          workInProgress,\\n          TransitionAwareHostComponent,\\n          null,\\n          null,\\n          renderLanes\\n        )),\\n        (HostTransitionContext._currentValue = init));\\n      markRef(current, workInProgress);\\n      reconcileChildren(current, workInProgress, lazyComponent, renderLanes);\\n      return workInProgress.child;\\n    case 6:\\n      if (null === current && isHydrating) {\\n        if ((current = renderLanes = nextHydratableInstance))\\n          (renderLanes = canHydrateTextInstance(\\n            renderLanes,\\n            workInProgress.pendingProps,\\n            rootOrSingletonContext\\n          )),\\n            null !== renderLanes\\n              ? ((workInProgress.stateNode = renderLanes),\\n                (hydrationParentFiber = workInProgress),\\n                (nextHydratableInstance = null),\\n                (current = !0))\\n              : (current = !1);\\n        current || throwOnHydrationMismatch(workInProgress);\\n      }\\n      return null;\\n    case 13:\\n      return updateSuspenseComponent(current, workInProgress, renderLanes);\\n    case 4:\\n      return (\\n        pushHostContainer(\\n          workInProgress,\\n          workInProgress.stateNode.containerInfo\\n        ),\\n        (lazyComponent = workInProgress.pendingProps),\\n        null === current\\n          ? (workInProgress.child = reconcileChildFibers(\\n              workInProgress,\\n              null,\\n              lazyComponent,\\n              renderLanes\\n            ))\\n          : reconcileChildren(\\n              current,\\n              workInProgress,\\n              lazyComponent,\\n              renderLanes\\n            ),\\n        workInProgress.child\\n      );\\n    case 11:\\n      return updateForwardRef(\\n        current,\\n        workInProgress,\\n        workInProgress.type,\\n        workInProgress.pendingProps,\\n        renderLanes\\n      );\\n    case 7:\\n      return (\\n        reconcileChildren(\\n          current,\\n          workInProgress,\\n          workInProgress.pendingProps,\\n          renderLanes\\n        ),\\n        workInProgress.child\\n      );\\n    case 8:\\n      return (\\n        reconcileChildren(\\n          current,\\n          workInProgress,\\n          workInProgress.pendingProps.children,\\n          renderLanes\\n        ),\\n        workInProgress.child\\n      );\\n    case 12:\\n      return (\\n        reconcileChildren(\\n          current,\\n          workInProgress,\\n          workInProgress.pendingProps.children,\\n          renderLanes\\n        ),\\n        workInProgress.child\\n      );\\n    case 10:\\n      return (\\n        (lazyComponent = workInProgress.pendingProps),\\n        pushProvider(workInProgress, workInProgress.type, lazyComponent.value),\\n        reconcileChildren(\\n          current,\\n          workInProgress,\\n          lazyComponent.children,\\n          renderLanes\\n        ),\\n        workInProgress.child\\n      );\\n    case 9:\\n      return (\\n        (init = workInProgress.type._context),\\n        (lazyComponent = workInProgress.pendingProps.children),\\n        prepareToReadContext(workInProgress),\\n        (init = readContext(init)),\\n        (lazyComponent = lazyComponent(init)),\\n        (workInProgress.flags |= 1),\\n        reconcileChildren(current, workInProgress, lazyComponent, renderLanes),\\n        workInProgress.child\\n      );\\n    case 14:\\n      return updateMemoComponent(\\n        current,\\n        workInProgress,\\n        workInProgress.type,\\n        workInProgress.pendingProps,\\n        renderLanes\\n      );\\n    case 15:\\n      return updateSimpleMemoComponent(\\n        current,\\n        workInProgress,\\n        workInProgress.type,\\n        workInProgress.pendingProps,\\n        renderLanes\\n      );\\n    case 19:\\n      return updateSuspenseListComponent(current, workInProgress, renderLanes);\\n    case 31:\\n      return (\\n        (lazyComponent = workInProgress.pendingProps),\\n        (renderLanes = workInProgress.mode),\\n        (lazyComponent = {\\n          mode: lazyComponent.mode,\\n          children: lazyComponent.children\\n        }),\\n        null === current\\n          ? ((renderLanes = mountWorkInProgressOffscreenFiber(\\n              lazyComponent,\\n              renderLanes\\n            )),\\n            (renderLanes.ref = workInProgress.ref),\\n            (workInProgress.child = renderLanes),\\n            (renderLanes.return = workInProgress),\\n            (workInProgress = renderLanes))\\n          : ((renderLanes = createWorkInProgress(current.child, lazyComponent)),\\n            (renderLanes.ref = workInProgress.ref),\\n            (workInProgress.child = renderLanes),\\n            (renderLanes.return = workInProgress),\\n            (workInProgress = renderLanes)),\\n        workInProgress\\n      );\\n    case 22:\\n      return updateOffscreenComponent(current, workInProgress, renderLanes);\\n    case 24:\\n      return (\\n        prepareToReadContext(workInProgress),\\n        (lazyComponent = readContext(CacheContext)),\\n        null === current\\n          ? ((init = peekCacheFromPool()),\\n            null === init &&\\n              ((init = workInProgressRoot),\\n              (prevState = createCache()),\\n              (init.pooledCache = prevState),\\n              prevState.refCount++,\\n              null !== prevState && (init.pooledCacheLanes |= renderLanes),\\n              (init = prevState)),\\n            (workInProgress.memoizedState = {\\n              parent: lazyComponent,\\n              cache: init\\n            }),\\n            initializeUpdateQueue(workInProgress),\\n            pushProvider(workInProgress, CacheContext, init))\\n          : (0 !== (current.lanes & renderLanes) &&\\n              (cloneUpdateQueue(current, workInProgress),\\n              processUpdateQueue(workInProgress, null, null, renderLanes),\\n              suspendIfUpdateReadFromEntangledAsyncAction()),\\n            (init = current.memoizedState),\\n            (prevState = workInProgress.memoizedState),\\n            init.parent !== lazyComponent\\n              ? ((init = { parent: lazyComponent, cache: lazyComponent }),\\n                (workInProgress.memoizedState = init),\\n                0 === workInProgress.lanes &&\\n                  (workInProgress.memoizedState =\\n                    workInProgress.updateQueue.baseState =\\n                      init),\\n                pushProvider(workInProgress, CacheContext, lazyComponent))\\n              : ((lazyComponent = prevState.cache),\\n                pushProvider(workInProgress, CacheContext, lazyComponent),\\n                lazyComponent !== init.cache &&\\n                  propagateContextChanges(\\n                    workInProgress,\\n                    [CacheContext],\\n                    renderLanes,\\n                    !0\\n                  ))),\\n        reconcileChildren(\\n          current,\\n          workInProgress,\\n          workInProgress.pendingProps.children,\\n          renderLanes\\n        ),\\n        workInProgress.child\\n      );\\n    case 29:\\n      throw workInProgress.pendingProps;\\n  }\\n  throw Error(formatProdErrorMessage(156, workInProgress.tag));\\n}\\nfunction markUpdate(workInProgress) {\\n  workInProgress.flags |= 4;\\n}\\nfunction preloadResourceAndSuspendIfNeeded(workInProgress, resource) {\\n  if (\"stylesheet\" !== resource.type || 0 !== (resource.state.loading & 4))\\n    workInProgress.flags &= -16777217;\\n  else if (((workInProgress.flags |= 16777216), !preloadResource(resource))) {\\n    resource = suspenseHandlerStackCursor.current;\\n    if (\\n      null !== resource &&\\n      ((workInProgressRootRenderLanes & 4194048) ===\\n      workInProgressRootRenderLanes\\n        ? null !== shellBoundary\\n        : ((workInProgressRootRenderLanes & 62914560) !==\\n            workInProgressRootRenderLanes &&\\n            0 === (workInProgressRootRenderLanes & 536870912)) ||\\n          resource !== shellBoundary)\\n    )\\n      throw (\\n        ((suspendedThenable = noopSuspenseyCommitThenable),\\n        SuspenseyCommitException)\\n      );\\n    workInProgress.flags |= 8192;\\n  }\\n}\\nfunction scheduleRetryEffect(workInProgress, retryQueue) {\\n  null !== retryQueue && (workInProgress.flags |= 4);\\n  workInProgress.flags & 16384 &&\\n    ((retryQueue =\\n      22 !== workInProgress.tag ? claimNextRetryLane() : 536870912),\\n    (workInProgress.lanes |= retryQueue),\\n    (workInProgressSuspendedRetryLanes |= retryQueue));\\n}\\nfunction cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {\\n  if (!isHydrating)\\n    switch (renderState.tailMode) {\\n      case \"hidden\":\\n        hasRenderedATailFallback = renderState.tail;\\n        for (var lastTailNode = null; null !== hasRenderedATailFallback; )\\n          null !== hasRenderedATailFallback.alternate &&\\n            (lastTailNode = hasRenderedATailFallback),\\n            (hasRenderedATailFallback = hasRenderedATailFallback.sibling);\\n        null === lastTailNode\\n          ? (renderState.tail = null)\\n          : (lastTailNode.sibling = null);\\n        break;\\n      case \"collapsed\":\\n        lastTailNode = renderState.tail;\\n        for (var lastTailNode$113 = null; null !== lastTailNode; )\\n          null !== lastTailNode.alternate && (lastTailNode$113 = lastTailNode),\\n            (lastTailNode = lastTailNode.sibling);\\n        null === lastTailNode$113\\n          ? hasRenderedATailFallback || null === renderState.tail\\n            ? (renderState.tail = null)\\n            : (renderState.tail.sibling = null)\\n          : (lastTailNode$113.sibling = null);\\n    }\\n}\\nfunction bubbleProperties(completedWork) {\\n  var didBailout =\\n      null !== completedWork.alternate &&\\n      completedWork.alternate.child === completedWork.child,\\n    newChildLanes = 0,\\n    subtreeFlags = 0;\\n  if (didBailout)\\n    for (var child$114 = completedWork.child; null !== child$114; )\\n      (newChildLanes |= child$114.lanes | child$114.childLanes),\\n        (subtreeFlags |= child$114.subtreeFlags & 65011712),\\n        (subtreeFlags |= child$114.flags & 65011712),\\n        (child$114.return = completedWork),\\n        (child$114 = child$114.sibling);\\n  else\\n    for (child$114 = completedWork.child; null !== child$114; )\\n      (newChildLanes |= child$114.lanes | child$114.childLanes),\\n        (subtreeFlags |= child$114.subtreeFlags),\\n        (subtreeFlags |= child$114.flags),\\n        (child$114.return = completedWork),\\n        (child$114 = child$114.sibling);\\n  completedWork.subtreeFlags |= subtreeFlags;\\n  completedWork.childLanes = newChildLanes;\\n  return didBailout;\\n}\\nfunction completeWork(current, workInProgress, renderLanes) {\\n  var newProps = workInProgress.pendingProps;\\n  popTreeContext(workInProgress);\\n  switch (workInProgress.tag) {\\n    case 31:\\n    case 16:\\n    case 15:\\n    case 0:\\n    case 11:\\n    case 7:\\n    case 8:\\n    case 12:\\n    case 9:\\n    case 14:\\n      return bubbleProperties(workInProgress), null;\\n    case 1:\\n      return bubbleProperties(workInProgress), null;\\n    case 3:\\n      renderLanes = workInProgress.stateNode;\\n      newProps = null;\\n      null !== current && (newProps = current.memoizedState.cache);\\n      workInProgress.memoizedState.cache !== newProps &&\\n        (workInProgress.flags |= 2048);\\n      popProvider(CacheContext);\\n      popHostContainer();\\n      renderLanes.pendingContext &&\\n        ((renderLanes.context = renderLanes.pendingContext),\\n        (renderLanes.pendingContext = null));\\n      if (null === current || null === current.child)\\n        popHydrationState(workInProgress)\\n          ? markUpdate(workInProgress)\\n          : null === current ||\\n            (current.memoizedState.isDehydrated &&\\n              0 === (workInProgress.flags & 256)) ||\\n            ((workInProgress.flags |= 1024),\\n            upgradeHydrationErrorsToRecoverable());\\n      bubbleProperties(workInProgress);\\n      return null;\\n    case 26:\\n      return (\\n        (renderLanes = workInProgress.memoizedState),\\n        null === current\\n          ? (markUpdate(workInProgress),\\n            null !== renderLanes\\n              ? (bubbleProperties(workInProgress),\\n                preloadResourceAndSuspendIfNeeded(workInProgress, renderLanes))\\n              : (bubbleProperties(workInProgress),\\n                (workInProgress.flags &= -16777217)))\\n          : renderLanes\\n            ? renderLanes !== current.memoizedState\\n              ? (markUpdate(workInProgress),\\n                bubbleProperties(workInProgress),\\n                preloadResourceAndSuspendIfNeeded(workInProgress, renderLanes))\\n              : (bubbleProperties(workInProgress),\\n                (workInProgress.flags &= -16777217))\\n            : (current.memoizedProps !== newProps && markUpdate(workInProgress),\\n              bubbleProperties(workInProgress),\\n              (workInProgress.flags &= -16777217)),\\n        null\\n      );\\n    case 27:\\n      popHostContext(workInProgress);\\n      renderLanes = rootInstanceStackCursor.current;\\n      var type = workInProgress.type;\\n      if (null !== current && null != workInProgress.stateNode)\\n        current.memoizedProps !== newProps && markUpdate(workInProgress);\\n      else {\\n        if (!newProps) {\\n          if (null === workInProgress.stateNode)\\n            throw Error(formatProdErrorMessage(166));\\n          bubbleProperties(workInProgress);\\n          return null;\\n        }\\n        current = contextStackCursor.current;\\n        popHydrationState(workInProgress)\\n          ? prepareToHydrateHostInstance(workInProgress, current)\\n          : ((current = resolveSingletonInstance(type, newProps, renderLanes)),\\n            (workInProgress.stateNode = current),\\n            markUpdate(workInProgress));\\n      }\\n      bubbleProperties(workInProgress);\\n      return null;\\n    case 5:\\n      popHostContext(workInProgress);\\n      renderLanes = workInProgress.type;\\n      if (null !== current && null != workInProgress.stateNode)\\n        current.memoizedProps !== newProps && markUpdate(workInProgress);\\n      else {\\n        if (!newProps) {\\n          if (null === workInProgress.stateNode)\\n            throw Error(formatProdErrorMessage(166));\\n          bubbleProperties(workInProgress);\\n          return null;\\n        }\\n        current = contextStackCursor.current;\\n        if (popHydrationState(workInProgress))\\n          prepareToHydrateHostInstance(workInProgress, current);\\n        else {\\n          type = getOwnerDocumentFromRootContainer(\\n            rootInstanceStackCursor.current\\n          );\\n          switch (current) {\\n            case 1:\\n              current = type.createElementNS(\\n                \"http://www.w3.org/2000/svg\",\\n                renderLanes\\n              );\\n              break;\\n            case 2:\\n              current = type.createElementNS(\\n                \"http://www.w3.org/1998/Math/MathML\",\\n                renderLanes\\n              );\\n              break;\\n            default:\\n              switch (renderLanes) {\\n                case \"svg\":\\n                  current = type.createElementNS(\\n                    \"http://www.w3.org/2000/svg\",\\n                    renderLanes\\n                  );\\n                  break;\\n                case \"math\":\\n                  current = type.createElementNS(\\n                    \"http://www.w3.org/1998/Math/MathML\",\\n                    renderLanes\\n                  );\\n                  break;\\n                case \"script\":\\n                  current = type.createElement(\"div\");\\n                  current.innerHTML = \"<script>\\\\x3c/script>\";\\n                  current = current.removeChild(current.firstChild);\\n                  break;\\n                case \"select\":\\n                  current =\\n                    \"string\" === typeof newProps.is\\n                      ? type.createElement(\"select\", { is: newProps.is })\\n                      : type.createElement(\"select\");\\n                  newProps.multiple\\n                    ? (current.multiple = !0)\\n                    : newProps.size && (current.size = newProps.size);\\n                  break;\\n                default:\\n                  current =\\n                    \"string\" === typeof newProps.is\\n                      ? type.createElement(renderLanes, { is: newProps.is })\\n                      : type.createElement(renderLanes);\\n              }\\n          }\\n          current[internalInstanceKey] = workInProgress;\\n          current[internalPropsKey] = newProps;\\n          a: for (type = workInProgress.child; null !== type; ) {\\n            if (5 === type.tag || 6 === type.tag)\\n              current.appendChild(type.stateNode);\\n            else if (4 !== type.tag && 27 !== type.tag && null !== type.child) {\\n              type.child.return = type;\\n              type = type.child;\\n              continue;\\n            }\\n            if (type === workInProgress) break a;\\n            for (; null === type.sibling; ) {\\n              if (null === type.return || type.return === workInProgress)\\n                break a;\\n              type = type.return;\\n            }\\n            type.sibling.return = type.return;\\n            type = type.sibling;\\n          }\\n          workInProgress.stateNode = current;\\n          a: switch (\\n            (setInitialProperties(current, renderLanes, newProps), renderLanes)\\n          ) {\\n            case \"button\":\\n            case \"input\":\\n            case \"select\":\\n            case \"textarea\":\\n              current = !!newProps.autoFocus;\\n              break a;\\n            case \"img\":\\n              current = !0;\\n              break a;\\n            default:\\n              current = !1;\\n          }\\n          current && markUpdate(workInProgress);\\n        }\\n      }\\n      bubbleProperties(workInProgress);\\n      workInProgress.flags &= -16777217;\\n      return null;\\n    case 6:\\n      if (current && null != workInProgress.stateNode)\\n        current.memoizedProps !== newProps && markUpdate(workInProgress);\\n      else {\\n        if (\"string\" !== typeof newProps && null === workInProgress.stateNode)\\n          throw Error(formatProdErrorMessage(166));\\n        current = rootInstanceStackCursor.current;\\n        if (popHydrationState(workInProgress)) {\\n          current = workInProgress.stateNode;\\n          renderLanes = workInProgress.memoizedProps;\\n          newProps = null;\\n          type = hydrationParentFiber;\\n          if (null !== type)\\n            switch (type.tag) {\\n              case 27:\\n              case 5:\\n                newProps = type.memoizedProps;\\n            }\\n          current[internalInstanceKey] = workInProgress;\\n          current =\\n            current.nodeValue === renderLanes ||\\n            (null !== newProps && !0 === newProps.suppressHydrationWarning) ||\\n            checkForUnmatchedText(current.nodeValue, renderLanes)\\n              ? !0\\n              : !1;\\n          current || throwOnHydrationMismatch(workInProgress);\\n        } else\\n          (current =\\n            getOwnerDocumentFromRootContainer(current).createTextNode(\\n              newProps\\n            )),\\n            (current[internalInstanceKey] = workInProgress),\\n            (workInProgress.stateNode = current);\\n      }\\n      bubbleProperties(workInProgress);\\n      return null;\\n    case 13:\\n      newProps = workInProgress.memoizedState;\\n      if (\\n        null === current ||\\n        (null !== current.memoizedState &&\\n          null !== current.memoizedState.dehydrated)\\n      ) {\\n        type = popHydrationState(workInProgress);\\n        if (null !== newProps && null !== newProps.dehydrated) {\\n          if (null === current) {\\n            if (!type) throw Error(formatProdErrorMessage(318));\\n            type = workInProgress.memoizedState;\\n            type = null !== type ? type.dehydrated : null;\\n            if (!type) throw Error(formatProdErrorMessage(317));\\n            type[internalInstanceKey] = workInProgress;\\n          } else\\n            resetHydrationState(),\\n              0 === (workInProgress.flags & 128) &&\\n                (workInProgress.memoizedState = null),\\n              (workInProgress.flags |= 4);\\n          bubbleProperties(workInProgress);\\n          type = !1;\\n        } else\\n          (type = upgradeHydrationErrorsToRecoverable()),\\n            null !== current &&\\n              null !== current.memoizedState &&\\n              (current.memoizedState.hydrationErrors = type),\\n            (type = !0);\\n        if (!type) {\\n          if (workInProgress.flags & 256)\\n            return popSuspenseHandler(workInProgress), workInProgress;\\n          popSuspenseHandler(workInProgress);\\n          return null;\\n        }\\n      }\\n      popSuspenseHandler(workInProgress);\\n      if (0 !== (workInProgress.flags & 128))\\n        return (workInProgress.lanes = renderLanes), workInProgress;\\n      renderLanes = null !== newProps;\\n      current = null !== current && null !== current.memoizedState;\\n      if (renderLanes) {\\n        newProps = workInProgress.child;\\n        type = null;\\n        null !== newProps.alternate &&\\n          null !== newProps.alternate.memoizedState &&\\n          null !== newProps.alternate.memoizedState.cachePool &&\\n          (type = newProps.alternate.memoizedState.cachePool.pool);\\n        var cache$127 = null;\\n        null !== newProps.memoizedState &&\\n          null !== newProps.memoizedState.cachePool &&\\n          (cache$127 = newProps.memoizedState.cachePool.pool);\\n        cache$127 !== type && (newProps.flags |= 2048);\\n      }\\n      renderLanes !== current &&\\n        renderLanes &&\\n        (workInProgress.child.flags |= 8192);\\n      scheduleRetryEffect(workInProgress, workInProgress.updateQueue);\\n      bubbleProperties(workInProgress);\\n      return null;\\n    case 4:\\n      return (\\n        popHostContainer(),\\n        null === current &&\\n          listenToAllSupportedEvents(workInProgress.stateNode.containerInfo),\\n        bubbleProperties(workInProgress),\\n        null\\n      );\\n    case 10:\\n      return (\\n        popProvider(workInProgress.type), bubbleProperties(workInProgress), null\\n      );\\n    case 19:\\n      pop(suspenseStackCursor);\\n      type = workInProgress.memoizedState;\\n      if (null === type) return bubbleProperties(workInProgress), null;\\n      newProps = 0 !== (workInProgress.flags & 128);\\n      cache$127 = type.rendering;\\n      if (null === cache$127)\\n        if (newProps) cutOffTailIfNeeded(type, !1);\\n        else {\\n          if (\\n            0 !== workInProgressRootExitStatus ||\\n            (null !== current && 0 !== (current.flags & 128))\\n          )\\n            for (current = workInProgress.child; null !== current; ) {\\n              cache$127 = findFirstSuspended(current);\\n              if (null !== cache$127) {\\n                workInProgress.flags |= 128;\\n                cutOffTailIfNeeded(type, !1);\\n                current = cache$127.updateQueue;\\n                workInProgress.updateQueue = current;\\n                scheduleRetryEffect(workInProgress, current);\\n                workInProgress.subtreeFlags = 0;\\n                current = renderLanes;\\n                for (renderLanes = workInProgress.child; null !== renderLanes; )\\n                  resetWorkInProgress(renderLanes, current),\\n                    (renderLanes = renderLanes.sibling);\\n                push(\\n                  suspenseStackCursor,\\n                  (suspenseStackCursor.current & 1) | 2\\n                );\\n                return workInProgress.child;\\n              }\\n              current = current.sibling;\\n            }\\n          null !== type.tail &&\\n            now() > workInProgressRootRenderTargetTime &&\\n            ((workInProgress.flags |= 128),\\n            (newProps = !0),\\n            cutOffTailIfNeeded(type, !1),\\n            (workInProgress.lanes = 4194304));\\n        }\\n      else {\\n        if (!newProps)\\n          if (((current = findFirstSuspended(cache$127)), null !== current)) {\\n            if (\\n              ((workInProgress.flags |= 128),\\n              (newProps = !0),\\n              (current = current.updateQueue),\\n              (workInProgress.updateQueue = current),\\n              scheduleRetryEffect(workInProgress, current),\\n              cutOffTailIfNeeded(type, !0),\\n              null === type.tail &&\\n                \"hidden\" === type.tailMode &&\\n                !cache$127.alternate &&\\n                !isHydrating)\\n            )\\n              return bubbleProperties(workInProgress), null;\\n          } else\\n            2 * now() - type.renderingStartTime >\\n              workInProgressRootRenderTargetTime &&\\n              536870912 !== renderLanes &&\\n              ((workInProgress.flags |= 128),\\n              (newProps = !0),\\n              cutOffTailIfNeeded(type, !1),\\n              (workInProgress.lanes = 4194304));\\n        type.isBackwards\\n          ? ((cache$127.sibling = workInProgress.child),\\n            (workInProgress.child = cache$127))\\n          : ((current = type.last),\\n            null !== current\\n              ? (current.sibling = cache$127)\\n              : (workInProgress.child = cache$127),\\n            (type.last = cache$127));\\n      }\\n      if (null !== type.tail)\\n        return (\\n          (workInProgress = type.tail),\\n          (type.rendering = workInProgress),\\n          (type.tail = workInProgress.sibling),\\n          (type.renderingStartTime = now()),\\n          (workInProgress.sibling = null),\\n          (current = suspenseStackCursor.current),\\n          push(suspenseStackCursor, newProps ? (current & 1) | 2 : current & 1),\\n          workInProgress\\n        );\\n      bubbleProperties(workInProgress);\\n      return null;\\n    case 22:\\n    case 23:\\n      return (\\n        popSuspenseHandler(workInProgress),\\n        popHiddenContext(),\\n        (newProps = null !== workInProgress.memoizedState),\\n        null !== current\\n          ? (null !== current.memoizedState) !== newProps &&\\n            (workInProgress.flags |= 8192)\\n          : newProps && (workInProgress.flags |= 8192),\\n        newProps\\n          ? 0 !== (renderLanes & 536870912) &&\\n            0 === (workInProgress.flags & 128) &&\\n            (bubbleProperties(workInProgress),\\n            workInProgress.subtreeFlags & 6 && (workInProgress.flags |= 8192))\\n          : bubbleProperties(workInProgress),\\n        (renderLanes = workInProgress.updateQueue),\\n        null !== renderLanes &&\\n          scheduleRetryEffect(workInProgress, renderLanes.retryQueue),\\n        (renderLanes = null),\\n        null !== current &&\\n          null !== current.memoizedState &&\\n          null !== current.memoizedState.cachePool &&\\n          (renderLanes = current.memoizedState.cachePool.pool),\\n        (newProps = null),\\n        null !== workInProgress.memoizedState &&\\n          null !== workInProgress.memoizedState.cachePool &&\\n          (newProps = workInProgress.memoizedState.cachePool.pool),\\n        newProps !== renderLanes && (workInProgress.flags |= 2048),\\n        null !== current && pop(resumedCache),\\n        null\\n      );\\n    case 24:\\n      return (\\n        (renderLanes = null),\\n        null !== current && (renderLanes = current.memoizedState.cache),\\n        workInProgress.memoizedState.cache !== renderLanes &&\\n          (workInProgress.flags |= 2048),\\n        popProvider(CacheContext),\\n        bubbleProperties(workInProgress),\\n        null\\n      );\\n    case 25:\\n      return null;\\n    case 30:\\n      return null;\\n  }\\n  throw Error(formatProdErrorMessage(156, workInProgress.tag));\\n}\\nfunction unwindWork(current, workInProgress) {\\n  popTreeContext(workInProgress);\\n  switch (workInProgress.tag) {\\n    case 1:\\n      return (\\n        (current = workInProgress.flags),\\n        current & 65536\\n          ? ((workInProgress.flags = (current & -65537) | 128), workInProgress)\\n          : null\\n      );\\n    case 3:\\n      return (\\n        popProvider(CacheContext),\\n        popHostContainer(),\\n        (current = workInProgress.flags),\\n        0 !== (current & 65536) && 0 === (current & 128)\\n          ? ((workInProgress.flags = (current & -65537) | 128), workInProgress)\\n          : null\\n      );\\n    case 26:\\n    case 27:\\n    case 5:\\n      return popHostContext(workInProgress), null;\\n    case 13:\\n      popSuspenseHandler(workInProgress);\\n      current = workInProgress.memoizedState;\\n      if (null !== current && null !== current.dehydrated) {\\n        if (null === workInProgress.alternate)\\n          throw Error(formatProdErrorMessage(340));\\n        resetHydrationState();\\n      }\\n      current = workInProgress.flags;\\n      return current & 65536\\n        ? ((workInProgress.flags = (current & -65537) | 128), workInProgress)\\n        : null;\\n    case 19:\\n      return pop(suspenseStackCursor), null;\\n    case 4:\\n      return popHostContainer(), null;\\n    case 10:\\n      return popProvider(workInProgress.type), null;\\n    case 22:\\n    case 23:\\n      return (\\n        popSuspenseHandler(workInProgress),\\n        popHiddenContext(),\\n        null !== current && pop(resumedCache),\\n        (current = workInProgress.flags),\\n        current & 65536\\n          ? ((workInProgress.flags = (current & -65537) | 128), workInProgress)\\n          : null\\n      );\\n    case 24:\\n      return popProvider(CacheContext), null;\\n    case 25:\\n      return null;\\n    default:\\n      return null;\\n  }\\n}\\nfunction unwindInterruptedWork(current, interruptedWork) {\\n  popTreeContext(interruptedWork);\\n  switch (interruptedWork.tag) {\\n    case 3:\\n      popProvider(CacheContext);\\n      popHostContainer();\\n      break;\\n    case 26:\\n    case 27:\\n    case 5:\\n      popHostContext(interruptedWork);\\n      break;\\n    case 4:\\n      popHostContainer();\\n      break;\\n    case 13:\\n      popSuspenseHandler(interruptedWork);\\n      break;\\n    case 19:\\n      pop(suspenseStackCursor);\\n      break;\\n    case 10:\\n      popProvider(interruptedWork.type);\\n      break;\\n    case 22:\\n    case 23:\\n      popSuspenseHandler(interruptedWork);\\n      popHiddenContext();\\n      null !== current && pop(resumedCache);\\n      break;\\n    case 24:\\n      popProvider(CacheContext);\\n  }\\n}\\nfunction commitHookEffectListMount(flags, finishedWork) {\\n  try {\\n    var updateQueue = finishedWork.updateQueue,\\n      lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;\\n    if (null !== lastEffect) {\\n      var firstEffect = lastEffect.next;\\n      updateQueue = firstEffect;\\n      do {\\n        if ((updateQueue.tag & flags) === flags) {\\n          lastEffect = void 0;\\n          var create = updateQueue.create,\\n            inst = updateQueue.inst;\\n          lastEffect = create();\\n          inst.destroy = lastEffect;\\n        }\\n        updateQueue = updateQueue.next;\\n      } while (updateQueue !== firstEffect);\\n    }\\n  } catch (error) {\\n    captureCommitPhaseError(finishedWork, finishedWork.return, error);\\n  }\\n}\\nfunction commitHookEffectListUnmount(\\n  flags,\\n  finishedWork,\\n  nearestMountedAncestor$jscomp$0\\n) {\\n  try {\\n    var updateQueue = finishedWork.updateQueue,\\n      lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;\\n    if (null !== lastEffect) {\\n      var firstEffect = lastEffect.next;\\n      updateQueue = firstEffect;\\n      do {\\n        if ((updateQueue.tag & flags) === flags) {\\n          var inst = updateQueue.inst,\\n            destroy = inst.destroy;\\n          if (void 0 !== destroy) {\\n            inst.destroy = void 0;\\n            lastEffect = finishedWork;\\n            var nearestMountedAncestor = nearestMountedAncestor$jscomp$0,\\n              destroy_ = destroy;\\n            try {\\n              destroy_();\\n            } catch (error) {\\n              captureCommitPhaseError(\\n                lastEffect,\\n                nearestMountedAncestor,\\n                error\\n              );\\n            }\\n          }\\n        }\\n        updateQueue = updateQueue.next;\\n      } while (updateQueue !== firstEffect);\\n    }\\n  } catch (error) {\\n    captureCommitPhaseError(finishedWork, finishedWork.return, error);\\n  }\\n}\\nfunction commitClassCallbacks(finishedWork) {\\n  var updateQueue = finishedWork.updateQueue;\\n  if (null !== updateQueue) {\\n    var instance = finishedWork.stateNode;\\n    try {\\n      commitCallbacks(updateQueue, instance);\\n    } catch (error) {\\n      captureCommitPhaseError(finishedWork, finishedWork.return, error);\\n    }\\n  }\\n}\\nfunction safelyCallComponentWillUnmount(\\n  current,\\n  nearestMountedAncestor,\\n  instance\\n) {\\n  instance.props = resolveClassComponentProps(\\n    current.type,\\n    current.memoizedProps\\n  );\\n  instance.state = current.memoizedState;\\n  try {\\n    instance.componentWillUnmount();\\n  } catch (error) {\\n    captureCommitPhaseError(current, nearestMountedAncestor, error);\\n  }\\n}\\nfunction safelyAttachRef(current, nearestMountedAncestor) {\\n  try {\\n    var ref = current.ref;\\n    if (null !== ref) {\\n      switch (current.tag) {\\n        case 26:\\n        case 27:\\n        case 5:\\n          var instanceToUse = current.stateNode;\\n          break;\\n        case 30:\\n          instanceToUse = current.stateNode;\\n          break;\\n        default:\\n          instanceToUse = current.stateNode;\\n      }\\n      \"function\" === typeof ref\\n        ? (current.refCleanup = ref(instanceToUse))\\n        : (ref.current = instanceToUse);\\n    }\\n  } catch (error) {\\n    captureCommitPhaseError(current, nearestMountedAncestor, error);\\n  }\\n}\\nfunction safelyDetachRef(current, nearestMountedAncestor) {\\n  var ref = current.ref,\\n    refCleanup = current.refCleanup;\\n  if (null !== ref)\\n    if (\"function\" === typeof refCleanup)\\n      try {\\n        refCleanup();\\n      } catch (error) {\\n        captureCommitPhaseError(current, nearestMountedAncestor, error);\\n      } finally {\\n        (current.refCleanup = null),\\n          (current = current.alternate),\\n          null != current && (current.refCleanup = null);\\n      }\\n    else if (\"function\" === typeof ref)\\n      try {\\n        ref(null);\\n      } catch (error$143) {\\n        captureCommitPhaseError(current, nearestMountedAncestor, error$143);\\n      }\\n    else ref.current = null;\\n}\\nfunction commitHostMount(finishedWork) {\\n  var type = finishedWork.type,\\n    props = finishedWork.memoizedProps,\\n    instance = finishedWork.stateNode;\\n  try {\\n    a: switch (type) {\\n      case \"button\":\\n      case \"input\":\\n      case \"select\":\\n      case \"textarea\":\\n        props.autoFocus && instance.focus();\\n        break a;\\n      case \"img\":\\n        props.src\\n          ? (instance.src = props.src)\\n          : props.srcSet && (instance.srcset = props.srcSet);\\n    }\\n  } catch (error) {\\n    captureCommitPhaseError(finishedWork, finishedWork.return, error);\\n  }\\n}\\nfunction commitHostUpdate(finishedWork, newProps, oldProps) {\\n  try {\\n    var domElement = finishedWork.stateNode;\\n    updateProperties(domElement, finishedWork.type, oldProps, newProps);\\n    domElement[internalPropsKey] = newProps;\\n  } catch (error) {\\n    captureCommitPhaseError(finishedWork, finishedWork.return, error);\\n  }\\n}\\nfunction isHostParent(fiber) {\\n  return (\\n    5 === fiber.tag ||\\n    3 === fiber.tag ||\\n    26 === fiber.tag ||\\n    (27 === fiber.tag && isSingletonScope(fiber.type)) ||\\n    4 === fiber.tag\\n  );\\n}\\nfunction getHostSibling(fiber) {\\n  a: for (;;) {\\n    for (; null === fiber.sibling; ) {\\n      if (null === fiber.return || isHostParent(fiber.return)) return null;\\n      fiber = fiber.return;\\n    }\\n    fiber.sibling.return = fiber.return;\\n    for (\\n      fiber = fiber.sibling;\\n      5 !== fiber.tag && 6 !== fiber.tag && 18 !== fiber.tag;\\n\\n    ) {\\n      if (27 === fiber.tag && isSingletonScope(fiber.type)) continue a;\\n      if (fiber.flags & 2) continue a;\\n      if (null === fiber.child || 4 === fiber.tag) continue a;\\n      else (fiber.child.return = fiber), (fiber = fiber.child);\\n    }\\n    if (!(fiber.flags & 2)) return fiber.stateNode;\\n  }\\n}\\nfunction insertOrAppendPlacementNodeIntoContainer(node, before, parent) {\\n  var tag = node.tag;\\n  if (5 === tag || 6 === tag)\\n    (node = node.stateNode),\\n      before\\n        ? (9 === parent.nodeType\\n            ? parent.body\\n            : \"HTML\" === parent.nodeName\\n              ? parent.ownerDocument.body\\n              : parent\\n          ).insertBefore(node, before)\\n        : ((before =\\n            9 === parent.nodeType\\n              ? parent.body\\n              : \"HTML\" === parent.nodeName\\n                ? parent.ownerDocument.body\\n                : parent),\\n          before.appendChild(node),\\n          (parent = parent._reactRootContainer),\\n          (null !== parent && void 0 !== parent) ||\\n            null !== before.onclick ||\\n            (before.onclick = noop$1));\\n  else if (\\n    4 !== tag &&\\n    (27 === tag &&\\n      isSingletonScope(node.type) &&\\n      ((parent = node.stateNode), (before = null)),\\n    (node = node.child),\\n    null !== node)\\n  )\\n    for (\\n      insertOrAppendPlacementNodeIntoContainer(node, before, parent),\\n        node = node.sibling;\\n      null !== node;\\n\\n    )\\n      insertOrAppendPlacementNodeIntoContainer(node, before, parent),\\n        (node = node.sibling);\\n}\\nfunction insertOrAppendPlacementNode(node, before, parent) {\\n  var tag = node.tag;\\n  if (5 === tag || 6 === tag)\\n    (node = node.stateNode),\\n      before ? parent.insertBefore(node, before) : parent.appendChild(node);\\n  else if (\\n    4 !== tag &&\\n    (27 === tag && isSingletonScope(node.type) && (parent = node.stateNode),\\n    (node = node.child),\\n    null !== node)\\n  )\\n    for (\\n      insertOrAppendPlacementNode(node, before, parent), node = node.sibling;\\n      null !== node;\\n\\n    )\\n      insertOrAppendPlacementNode(node, before, parent), (node = node.sibling);\\n}\\nfunction commitHostSingletonAcquisition(finishedWork) {\\n  var singleton = finishedWork.stateNode,\\n    props = finishedWork.memoizedProps;\\n  try {\\n    for (\\n      var type = finishedWork.type, attributes = singleton.attributes;\\n      attributes.length;\\n\\n    )\\n      singleton.removeAttributeNode(attributes[0]);\\n    setInitialProperties(singleton, type, props);\\n    singleton[internalInstanceKey] = finishedWork;\\n    singleton[internalPropsKey] = props;\\n  } catch (error) {\\n    captureCommitPhaseError(finishedWork, finishedWork.return, error);\\n  }\\n}\\nvar offscreenSubtreeIsHidden = !1,\\n  offscreenSubtreeWasHidden = !1,\\n  needsFormReset = !1,\\n  PossiblyWeakSet = \"function\" === typeof WeakSet ? WeakSet : Set,\\n  nextEffect = null;\\nfunction commitBeforeMutationEffects(root, firstChild) {\\n  root = root.containerInfo;\\n  eventsEnabled = _enabled;\\n  root = getActiveElementDeep(root);\\n  if (hasSelectionCapabilities(root)) {\\n    if (\"selectionStart\" in root)\\n      var JSCompiler_temp = {\\n        start: root.selectionStart,\\n        end: root.selectionEnd\\n      };\\n    else\\n      a: {\\n        JSCompiler_temp =\\n          ((JSCompiler_temp = root.ownerDocument) &&\\n            JSCompiler_temp.defaultView) ||\\n          window;\\n        var selection =\\n          JSCompiler_temp.getSelection && JSCompiler_temp.getSelection();\\n        if (selection && 0 !== selection.rangeCount) {\\n          JSCompiler_temp = selection.anchorNode;\\n          var anchorOffset = selection.anchorOffset,\\n            focusNode = selection.focusNode;\\n          selection = selection.focusOffset;\\n          try {\\n            JSCompiler_temp.nodeType, focusNode.nodeType;\\n          } catch (e$20) {\\n            JSCompiler_temp = null;\\n            break a;\\n          }\\n          var length = 0,\\n            start = -1,\\n            end = -1,\\n            indexWithinAnchor = 0,\\n            indexWithinFocus = 0,\\n            node = root,\\n            parentNode = null;\\n          b: for (;;) {\\n            for (var next; ; ) {\\n              node !== JSCompiler_temp ||\\n                (0 !== anchorOffset && 3 !== node.nodeType) ||\\n                (start = length + anchorOffset);\\n              node !== focusNode ||\\n                (0 !== selection && 3 !== node.nodeType) ||\\n                (end = length + selection);\\n              3 === node.nodeType && (length += node.nodeValue.length);\\n              if (null === (next = node.firstChild)) break;\\n              parentNode = node;\\n              node = next;\\n            }\\n            for (;;) {\\n              if (node === root) break b;\\n              parentNode === JSCompiler_temp &&\\n                ++indexWithinAnchor === anchorOffset &&\\n                (start = length);\\n              parentNode === focusNode &&\\n                ++indexWithinFocus === selection &&\\n                (end = length);\\n              if (null !== (next = node.nextSibling)) break;\\n              node = parentNode;\\n              parentNode = node.parentNode;\\n            }\\n            node = next;\\n          }\\n          JSCompiler_temp =\\n            -1 === start || -1 === end ? null : { start: start, end: end };\\n        } else JSCompiler_temp = null;\\n      }\\n    JSCompiler_temp = JSCompiler_temp || { start: 0, end: 0 };\\n  } else JSCompiler_temp = null;\\n  selectionInformation = { focusedElem: root, selectionRange: JSCompiler_temp };\\n  _enabled = !1;\\n  for (nextEffect = firstChild; null !== nextEffect; )\\n    if (\\n      ((firstChild = nextEffect),\\n      (root = firstChild.child),\\n      0 !== (firstChild.subtreeFlags & 1024) && null !== root)\\n    )\\n      (root.return = firstChild), (nextEffect = root);\\n    else\\n      for (; null !== nextEffect; ) {\\n        firstChild = nextEffect;\\n        focusNode = firstChild.alternate;\\n        root = firstChild.flags;\\n        switch (firstChild.tag) {\\n          case 0:\\n            break;\\n          case 11:\\n          case 15:\\n            break;\\n          case 1:\\n            if (0 !== (root & 1024) && null !== focusNode) {\\n              root = void 0;\\n              JSCompiler_temp = firstChild;\\n              anchorOffset = focusNode.memoizedProps;\\n              focusNode = focusNode.memoizedState;\\n              selection = JSCompiler_temp.stateNode;\\n              try {\\n                var resolvedPrevProps = resolveClassComponentProps(\\n                  JSCompiler_temp.type,\\n                  anchorOffset,\\n                  JSCompiler_temp.elementType === JSCompiler_temp.type\\n                );\\n                root = selection.getSnapshotBeforeUpdate(\\n                  resolvedPrevProps,\\n                  focusNode\\n                );\\n                selection.__reactInternalSnapshotBeforeUpdate = root;\\n              } catch (error) {\\n                captureCommitPhaseError(\\n                  JSCompiler_temp,\\n                  JSCompiler_temp.return,\\n                  error\\n                );\\n              }\\n            }\\n            break;\\n          case 3:\\n            if (0 !== (root & 1024))\\n              if (\\n                ((root = firstChild.stateNode.containerInfo),\\n                (JSCompiler_temp = root.nodeType),\\n                9 === JSCompiler_temp)\\n              )\\n                clearContainerSparingly(root);\\n              else if (1 === JSCompiler_temp)\\n                switch (root.nodeName) {\\n                  case \"HEAD\":\\n                  case \"HTML\":\\n                  case \"BODY\":\\n                    clearContainerSparingly(root);\\n                    break;\\n                  default:\\n                    root.textContent = \"\";\\n                }\\n            break;\\n          case 5:\\n          case 26:\\n          case 27:\\n          case 6:\\n          case 4:\\n          case 17:\\n            break;\\n          default:\\n            if (0 !== (root & 1024)) throw Error(formatProdErrorMessage(163));\\n        }\\n        root = firstChild.sibling;\\n        if (null !== root) {\\n          root.return = firstChild.return;\\n          nextEffect = root;\\n          break;\\n        }\\n        nextEffect = firstChild.return;\\n      }\\n}\\nfunction commitLayoutEffectOnFiber(finishedRoot, current, finishedWork) {\\n  var flags = finishedWork.flags;\\n  switch (finishedWork.tag) {\\n    case 0:\\n    case 11:\\n    case 15:\\n      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\\n      flags & 4 && commitHookEffectListMount(5, finishedWork);\\n      break;\\n    case 1:\\n      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\\n      if (flags & 4)\\n        if (((finishedRoot = finishedWork.stateNode), null === current))\\n          try {\\n            finishedRoot.componentDidMount();\\n          } catch (error) {\\n            captureCommitPhaseError(finishedWork, finishedWork.return, error);\\n          }\\n        else {\\n          var prevProps = resolveClassComponentProps(\\n            finishedWork.type,\\n            current.memoizedProps\\n          );\\n          current = current.memoizedState;\\n          try {\\n            finishedRoot.componentDidUpdate(\\n              prevProps,\\n              current,\\n              finishedRoot.__reactInternalSnapshotBeforeUpdate\\n            );\\n          } catch (error$142) {\\n            captureCommitPhaseError(\\n              finishedWork,\\n              finishedWork.return,\\n              error$142\\n            );\\n          }\\n        }\\n      flags & 64 && commitClassCallbacks(finishedWork);\\n      flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);\\n      break;\\n    case 3:\\n      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\\n      if (\\n        flags & 64 &&\\n        ((finishedRoot = finishedWork.updateQueue), null !== finishedRoot)\\n      ) {\\n        current = null;\\n        if (null !== finishedWork.child)\\n          switch (finishedWork.child.tag) {\\n            case 27:\\n            case 5:\\n              current = finishedWork.child.stateNode;\\n              break;\\n            case 1:\\n              current = finishedWork.child.stateNode;\\n          }\\n        try {\\n          commitCallbacks(finishedRoot, current);\\n        } catch (error) {\\n          captureCommitPhaseError(finishedWork, finishedWork.return, error);\\n        }\\n      }\\n      break;\\n    case 27:\\n      null === current &&\\n        flags & 4 &&\\n        commitHostSingletonAcquisition(finishedWork);\\n    case 26:\\n    case 5:\\n      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\\n      null === current && flags & 4 && commitHostMount(finishedWork);\\n      flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);\\n      break;\\n    case 12:\\n      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\\n      break;\\n    case 13:\\n      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\\n      flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);\\n      flags & 64 &&\\n        ((finishedRoot = finishedWork.memoizedState),\\n        null !== finishedRoot &&\\n          ((finishedRoot = finishedRoot.dehydrated),\\n          null !== finishedRoot &&\\n            ((finishedWork = retryDehydratedSuspenseBoundary.bind(\\n              null,\\n              finishedWork\\n            )),\\n            registerSuspenseInstanceRetry(finishedRoot, finishedWork))));\\n      break;\\n    case 22:\\n      flags = null !== finishedWork.memoizedState || offscreenSubtreeIsHidden;\\n      if (!flags) {\\n        current =\\n          (null !== current && null !== current.memoizedState) ||\\n          offscreenSubtreeWasHidden;\\n        prevProps = offscreenSubtreeIsHidden;\\n        var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;\\n        offscreenSubtreeIsHidden = flags;\\n        (offscreenSubtreeWasHidden = current) && !prevOffscreenSubtreeWasHidden\\n          ? recursivelyTraverseReappearLayoutEffects(\\n              finishedRoot,\\n              finishedWork,\\n              0 !== (finishedWork.subtreeFlags & 8772)\\n            )\\n          : recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\\n        offscreenSubtreeIsHidden = prevProps;\\n        offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;\\n      }\\n      break;\\n    case 30:\\n      break;\\n    default:\\n      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\\n  }\\n}\\nfunction detachFiberAfterEffects(fiber) {\\n  var alternate = fiber.alternate;\\n  null !== alternate &&\\n    ((fiber.alternate = null), detachFiberAfterEffects(alternate));\\n  fiber.child = null;\\n  fiber.deletions = null;\\n  fiber.sibling = null;\\n  5 === fiber.tag &&\\n    ((alternate = fiber.stateNode),\\n    null !== alternate && detachDeletedInstance(alternate));\\n  fiber.stateNode = null;\\n  fiber.return = null;\\n  fiber.dependencies = null;\\n  fiber.memoizedProps = null;\\n  fiber.memoizedState = null;\\n  fiber.pendingProps = null;\\n  fiber.stateNode = null;\\n  fiber.updateQueue = null;\\n}\\nvar hostParent = null,\\n  hostParentIsContainer = !1;\\nfunction recursivelyTraverseDeletionEffects(\\n  finishedRoot,\\n  nearestMountedAncestor,\\n  parent\\n) {\\n  for (parent = parent.child; null !== parent; )\\n    commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, parent),\\n      (parent = parent.sibling);\\n}\\nfunction commitDeletionEffectsOnFiber(\\n  finishedRoot,\\n  nearestMountedAncestor,\\n  deletedFiber\\n) {\\n  if (injectedHook && \"function\" === typeof injectedHook.onCommitFiberUnmount)\\n    try {\\n      injectedHook.onCommitFiberUnmount(rendererID, deletedFiber);\\n    } catch (err) {}\\n  switch (deletedFiber.tag) {\\n    case 26:\\n      offscreenSubtreeWasHidden ||\\n        safelyDetachRef(deletedFiber, nearestMountedAncestor);\\n      recursivelyTraverseDeletionEffects(\\n        finishedRoot,\\n        nearestMountedAncestor,\\n        deletedFiber\\n      );\\n      deletedFiber.memoizedState\\n        ? deletedFiber.memoizedState.count--\\n        : deletedFiber.stateNode &&\\n          ((deletedFiber = deletedFiber.stateNode),\\n          deletedFiber.parentNode.removeChild(deletedFiber));\\n      break;\\n    case 27:\\n      offscreenSubtreeWasHidden ||\\n        safelyDetachRef(deletedFiber, nearestMountedAncestor);\\n      var prevHostParent = hostParent,\\n        prevHostParentIsContainer = hostParentIsContainer;\\n      isSingletonScope(deletedFiber.type) &&\\n        ((hostParent = deletedFiber.stateNode), (hostParentIsContainer = !1));\\n      recursivelyTraverseDeletionEffects(\\n        finishedRoot,\\n        nearestMountedAncestor,\\n        deletedFiber\\n      );\\n      releaseSingletonInstance(deletedFiber.stateNode);\\n      hostParent = prevHostParent;\\n      hostParentIsContainer = prevHostParentIsContainer;\\n      break;\\n    case 5:\\n      offscreenSubtreeWasHidden ||\\n        safelyDetachRef(deletedFiber, nearestMountedAncestor);\\n    case 6:\\n      prevHostParent = hostParent;\\n      prevHostParentIsContainer = hostParentIsContainer;\\n      hostParent = null;\\n      recursivelyTraverseDeletionEffects(\\n        finishedRoot,\\n        nearestMountedAncestor,\\n        deletedFiber\\n      );\\n      hostParent = prevHostParent;\\n      hostParentIsContainer = prevHostParentIsContainer;\\n      if (null !== hostParent)\\n        if (hostParentIsContainer)\\n          try {\\n            (9 === hostParent.nodeType\\n              ? hostParent.body\\n              : \"HTML\" === hostParent.nodeName\\n                ? hostParent.ownerDocument.body\\n                : hostParent\\n            ).removeChild(deletedFiber.stateNode);\\n          } catch (error) {\\n            captureCommitPhaseError(\\n              deletedFiber,\\n              nearestMountedAncestor,\\n              error\\n            );\\n          }\\n        else\\n          try {\\n            hostParent.removeChild(deletedFiber.stateNode);\\n          } catch (error) {\\n            captureCommitPhaseError(\\n              deletedFiber,\\n              nearestMountedAncestor,\\n              error\\n            );\\n          }\\n      break;\\n    case 18:\\n      null !== hostParent &&\\n        (hostParentIsContainer\\n          ? ((finishedRoot = hostParent),\\n            clearSuspenseBoundary(\\n              9 === finishedRoot.nodeType\\n                ? finishedRoot.body\\n                : \"HTML\" === finishedRoot.nodeName\\n                  ? finishedRoot.ownerDocument.body\\n                  : finishedRoot,\\n              deletedFiber.stateNode\\n            ),\\n            retryIfBlockedOn(finishedRoot))\\n          : clearSuspenseBoundary(hostParent, deletedFiber.stateNode));\\n      break;\\n    case 4:\\n      prevHostParent = hostParent;\\n      prevHostParentIsContainer = hostParentIsContainer;\\n      hostParent = deletedFiber.stateNode.containerInfo;\\n      hostParentIsContainer = !0;\\n      recursivelyTraverseDeletionEffects(\\n        finishedRoot,\\n        nearestMountedAncestor,\\n        deletedFiber\\n      );\\n      hostParent = prevHostParent;\\n      hostParentIsContainer = prevHostParentIsContainer;\\n      break;\\n    case 0:\\n    case 11:\\n    case 14:\\n    case 15:\\n      offscreenSubtreeWasHidden ||\\n        commitHookEffectListUnmount(2, deletedFiber, nearestMountedAncestor);\\n      offscreenSubtreeWasHidden ||\\n        commitHookEffectListUnmount(4, deletedFiber, nearestMountedAncestor);\\n      recursivelyTraverseDeletionEffects(\\n        finishedRoot,\\n        nearestMountedAncestor,\\n        deletedFiber\\n      );\\n      break;\\n    case 1:\\n      offscreenSubtreeWasHidden ||\\n        (safelyDetachRef(deletedFiber, nearestMountedAncestor),\\n        (prevHostParent = deletedFiber.stateNode),\\n        \"function\" === typeof prevHostParent.componentWillUnmount &&\\n          safelyCallComponentWillUnmount(\\n            deletedFiber,\\n            nearestMountedAncestor,\\n            prevHostParent\\n          ));\\n      recursivelyTraverseDeletionEffects(\\n        finishedRoot,\\n        nearestMountedAncestor,\\n        deletedFiber\\n      );\\n      break;\\n    case 21:\\n      recursivelyTraverseDeletionEffects(\\n        finishedRoot,\\n        nearestMountedAncestor,\\n        deletedFiber\\n      );\\n      break;\\n    case 22:\\n      offscreenSubtreeWasHidden =\\n        (prevHostParent = offscreenSubtreeWasHidden) ||\\n        null !== deletedFiber.memoizedState;\\n      recursivelyTraverseDeletionEffects(\\n        finishedRoot,\\n        nearestMountedAncestor,\\n        deletedFiber\\n      );\\n      offscreenSubtreeWasHidden = prevHostParent;\\n      break;\\n    default:\\n      recursivelyTraverseDeletionEffects(\\n        finishedRoot,\\n        nearestMountedAncestor,\\n        deletedFiber\\n      );\\n  }\\n}\\nfunction commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {\\n  if (\\n    null === finishedWork.memoizedState &&\\n    ((finishedRoot = finishedWork.alternate),\\n    null !== finishedRoot &&\\n      ((finishedRoot = finishedRoot.memoizedState),\\n      null !== finishedRoot &&\\n        ((finishedRoot = finishedRoot.dehydrated), null !== finishedRoot)))\\n  )\\n    try {\\n      retryIfBlockedOn(finishedRoot);\\n    } catch (error) {\\n      captureCommitPhaseError(finishedWork, finishedWork.return, error);\\n    }\\n}\\nfunction getRetryCache(finishedWork) {\\n  switch (finishedWork.tag) {\\n    case 13:\\n    case 19:\\n      var retryCache = finishedWork.stateNode;\\n      null === retryCache &&\\n        (retryCache = finishedWork.stateNode = new PossiblyWeakSet());\\n      return retryCache;\\n    case 22:\\n      return (\\n        (finishedWork = finishedWork.stateNode),\\n        (retryCache = finishedWork._retryCache),\\n        null === retryCache &&\\n          (retryCache = finishedWork._retryCache = new PossiblyWeakSet()),\\n        retryCache\\n      );\\n    default:\\n      throw Error(formatProdErrorMessage(435, finishedWork.tag));\\n  }\\n}\\nfunction attachSuspenseRetryListeners(finishedWork, wakeables) {\\n  var retryCache = getRetryCache(finishedWork);\\n  wakeables.forEach(function (wakeable) {\\n    var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);\\n    retryCache.has(wakeable) ||\\n      (retryCache.add(wakeable), wakeable.then(retry, retry));\\n  });\\n}\\nfunction recursivelyTraverseMutationEffects(root$jscomp$0, parentFiber) {\\n  var deletions = parentFiber.deletions;\\n  if (null !== deletions)\\n    for (var i = 0; i < deletions.length; i++) {\\n      var childToDelete = deletions[i],\\n        root = root$jscomp$0,\\n        returnFiber = parentFiber,\\n        parent = returnFiber;\\n      a: for (; null !== parent; ) {\\n        switch (parent.tag) {\\n          case 27:\\n            if (isSingletonScope(parent.type)) {\\n              hostParent = parent.stateNode;\\n              hostParentIsContainer = !1;\\n              break a;\\n            }\\n            break;\\n          case 5:\\n            hostParent = parent.stateNode;\\n            hostParentIsContainer = !1;\\n            break a;\\n          case 3:\\n          case 4:\\n            hostParent = parent.stateNode.containerInfo;\\n            hostParentIsContainer = !0;\\n            break a;\\n        }\\n        parent = parent.return;\\n      }\\n      if (null === hostParent) throw Error(formatProdErrorMessage(160));\\n      commitDeletionEffectsOnFiber(root, returnFiber, childToDelete);\\n      hostParent = null;\\n      hostParentIsContainer = !1;\\n      root = childToDelete.alternate;\\n      null !== root && (root.return = null);\\n      childToDelete.return = null;\\n    }\\n  if (parentFiber.subtreeFlags & 13878)\\n    for (parentFiber = parentFiber.child; null !== parentFiber; )\\n      commitMutationEffectsOnFiber(parentFiber, root$jscomp$0),\\n        (parentFiber = parentFiber.sibling);\\n}\\nvar currentHoistableRoot = null;\\nfunction commitMutationEffectsOnFiber(finishedWork, root) {\\n  var current = finishedWork.alternate,\\n    flags = finishedWork.flags;\\n  switch (finishedWork.tag) {\\n    case 0:\\n    case 11:\\n    case 14:\\n    case 15:\\n      recursivelyTraverseMutationEffects(root, finishedWork);\\n      commitReconciliationEffects(finishedWork);\\n      flags & 4 &&\\n        (commitHookEffectListUnmount(3, finishedWork, finishedWork.return),\\n        commitHookEffectListMount(3, finishedWork),\\n        commitHookEffectListUnmount(5, finishedWork, finishedWork.return));\\n      break;\\n    case 1:\\n      recursivelyTraverseMutationEffects(root, finishedWork);\\n      commitReconciliationEffects(finishedWork);\\n      flags & 512 &&\\n        (offscreenSubtreeWasHidden ||\\n          null === current ||\\n          safelyDetachRef(current, current.return));\\n      flags & 64 &&\\n        offscreenSubtreeIsHidden &&\\n        ((finishedWork = finishedWork.updateQueue),\\n        null !== finishedWork &&\\n          ((flags = finishedWork.callbacks),\\n          null !== flags &&\\n            ((current = finishedWork.shared.hiddenCallbacks),\\n            (finishedWork.shared.hiddenCallbacks =\\n              null === current ? flags : current.concat(flags)))));\\n      break;\\n    case 26:\\n      var hoistableRoot = currentHoistableRoot;\\n      recursivelyTraverseMutationEffects(root, finishedWork);\\n      commitReconciliationEffects(finishedWork);\\n      flags & 512 &&\\n        (offscreenSubtreeWasHidden ||\\n          null === current ||\\n          safelyDetachRef(current, current.return));\\n      if (flags & 4) {\\n        var currentResource = null !== current ? current.memoizedState : null;\\n        flags = finishedWork.memoizedState;\\n        if (null === current)\\n          if (null === flags)\\n            if (null === finishedWork.stateNode) {\\n              a: {\\n                flags = finishedWork.type;\\n                current = finishedWork.memoizedProps;\\n                hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;\\n                b: switch (flags) {\\n                  case \"title\":\\n                    currentResource =\\n                      hoistableRoot.getElementsByTagName(\"title\")[0];\\n                    if (\\n                      !currentResource ||\\n                      currentResource[internalHoistableMarker] ||\\n                      currentResource[internalInstanceKey] ||\\n                      \"http://www.w3.org/2000/svg\" ===\\n                        currentResource.namespaceURI ||\\n                      currentResource.hasAttribute(\"itemprop\")\\n                    )\\n                      (currentResource = hoistableRoot.createElement(flags)),\\n                        hoistableRoot.head.insertBefore(\\n                          currentResource,\\n                          hoistableRoot.querySelector(\"head > title\")\\n                        );\\n                    setInitialProperties(currentResource, flags, current);\\n                    currentResource[internalInstanceKey] = finishedWork;\\n                    markNodeAsHoistable(currentResource);\\n                    flags = currentResource;\\n                    break a;\\n                  case \"link\":\\n                    var maybeNodes = getHydratableHoistableCache(\\n                      \"link\",\\n                      \"href\",\\n                      hoistableRoot\\n                    ).get(flags + (current.href || \"\"));\\n                    if (maybeNodes)\\n                      for (var i = 0; i < maybeNodes.length; i++)\\n                        if (\\n                          ((currentResource = maybeNodes[i]),\\n                          currentResource.getAttribute(\"href\") ===\\n                            (null == current.href || \"\" === current.href\\n                              ? null\\n                              : current.href) &&\\n                            currentResource.getAttribute(\"rel\") ===\\n                              (null == current.rel ? null : current.rel) &&\\n                            currentResource.getAttribute(\"title\") ===\\n                              (null == current.title ? null : current.title) &&\\n                            currentResource.getAttribute(\"crossorigin\") ===\\n                              (null == current.crossOrigin\\n                                ? null\\n                                : current.crossOrigin))\\n                        ) {\\n                          maybeNodes.splice(i, 1);\\n                          break b;\\n                        }\\n                    currentResource = hoistableRoot.createElement(flags);\\n                    setInitialProperties(currentResource, flags, current);\\n                    hoistableRoot.head.appendChild(currentResource);\\n                    break;\\n                  case \"meta\":\\n                    if (\\n                      (maybeNodes = getHydratableHoistableCache(\\n                        \"meta\",\\n                        \"content\",\\n                        hoistableRoot\\n                      ).get(flags + (current.content || \"\")))\\n                    )\\n                      for (i = 0; i < maybeNodes.length; i++)\\n                        if (\\n                          ((currentResource = maybeNodes[i]),\\n                          currentResource.getAttribute(\"content\") ===\\n                            (null == current.content\\n                              ? null\\n                              : \"\" + current.content) &&\\n                            currentResource.getAttribute(\"name\") ===\\n                              (null == current.name ? null : current.name) &&\\n                            currentResource.getAttribute(\"property\") ===\\n                              (null == current.property\\n                                ? null\\n                                : current.property) &&\\n                            currentResource.getAttribute(\"http-equiv\") ===\\n                              (null == current.httpEquiv\\n                                ? null\\n                                : current.httpEquiv) &&\\n                            currentResource.getAttribute(\"charset\") ===\\n                              (null == current.charSet\\n                                ? null\\n                                : current.charSet))\\n                        ) {\\n                          maybeNodes.splice(i, 1);\\n                          break b;\\n                        }\\n                    currentResource = hoistableRoot.createElement(flags);\\n                    setInitialProperties(currentResource, flags, current);\\n                    hoistableRoot.head.appendChild(currentResource);\\n                    break;\\n                  default:\\n                    throw Error(formatProdErrorMessage(468, flags));\\n                }\\n                currentResource[internalInstanceKey] = finishedWork;\\n                markNodeAsHoistable(currentResource);\\n                flags = currentResource;\\n              }\\n              finishedWork.stateNode = flags;\\n            } else\\n              mountHoistable(\\n                hoistableRoot,\\n                finishedWork.type,\\n                finishedWork.stateNode\\n              );\\n          else\\n            finishedWork.stateNode = acquireResource(\\n              hoistableRoot,\\n              flags,\\n              finishedWork.memoizedProps\\n            );\\n        else\\n          currentResource !== flags\\n            ? (null === currentResource\\n                ? null !== current.stateNode &&\\n                  ((current = current.stateNode),\\n                  current.parentNode.removeChild(current))\\n                : currentResource.count--,\\n              null === flags\\n                ? mountHoistable(\\n                    hoistableRoot,\\n                    finishedWork.type,\\n                    finishedWork.stateNode\\n                  )\\n                : acquireResource(\\n                    hoistableRoot,\\n                    flags,\\n                    finishedWork.memoizedProps\\n                  ))\\n            : null === flags &&\\n              null !== finishedWork.stateNode &&\\n              commitHostUpdate(\\n                finishedWork,\\n                finishedWork.memoizedProps,\\n                current.memoizedProps\\n              );\\n      }\\n      break;\\n    case 27:\\n      recursivelyTraverseMutationEffects(root, finishedWork);\\n      commitReconciliationEffects(finishedWork);\\n      flags & 512 &&\\n        (offscreenSubtreeWasHidden ||\\n          null === current ||\\n          safelyDetachRef(current, current.return));\\n      null !== current &&\\n        flags & 4 &&\\n        commitHostUpdate(\\n          finishedWork,\\n          finishedWork.memoizedProps,\\n          current.memoizedProps\\n        );\\n      break;\\n    case 5:\\n      recursivelyTraverseMutationEffects(root, finishedWork);\\n      commitReconciliationEffects(finishedWork);\\n      flags & 512 &&\\n        (offscreenSubtreeWasHidden ||\\n          null === current ||\\n          safelyDetachRef(current, current.return));\\n      if (finishedWork.flags & 32) {\\n        hoistableRoot = finishedWork.stateNode;\\n        try {\\n          setTextContent(hoistableRoot, \"\");\\n        } catch (error) {\\n          captureCommitPhaseError(finishedWork, finishedWork.return, error);\\n        }\\n      }\\n      flags & 4 &&\\n        null != finishedWork.stateNode &&\\n        ((hoistableRoot = finishedWork.memoizedProps),\\n        commitHostUpdate(\\n          finishedWork,\\n          hoistableRoot,\\n          null !== current ? current.memoizedProps : hoistableRoot\\n        ));\\n      flags & 1024 && (needsFormReset = !0);\\n      break;\\n    case 6:\\n      recursivelyTraverseMutationEffects(root, finishedWork);\\n      commitReconciliationEffects(finishedWork);\\n      if (flags & 4) {\\n        if (null === finishedWork.stateNode)\\n          throw Error(formatProdErrorMessage(162));\\n        flags = finishedWork.memoizedProps;\\n        current = finishedWork.stateNode;\\n        try {\\n          current.nodeValue = flags;\\n        } catch (error) {\\n          captureCommitPhaseError(finishedWork, finishedWork.return, error);\\n        }\\n      }\\n      break;\\n    case 3:\\n      tagCaches = null;\\n      hoistableRoot = currentHoistableRoot;\\n      currentHoistableRoot = getHoistableRoot(root.containerInfo);\\n      recursivelyTraverseMutationEffects(root, finishedWork);\\n      currentHoistableRoot = hoistableRoot;\\n      commitReconciliationEffects(finishedWork);\\n      if (flags & 4 && null !== current && current.memoizedState.isDehydrated)\\n        try {\\n          retryIfBlockedOn(root.containerInfo);\\n        } catch (error) {\\n          captureCommitPhaseError(finishedWork, finishedWork.return, error);\\n        }\\n      needsFormReset &&\\n        ((needsFormReset = !1), recursivelyResetForms(finishedWork));\\n      break;\\n    case 4:\\n      flags = currentHoistableRoot;\\n      currentHoistableRoot = getHoistableRoot(\\n        finishedWork.stateNode.containerInfo\\n      );\\n      recursivelyTraverseMutationEffects(root, finishedWork);\\n      commitReconciliationEffects(finishedWork);\\n      currentHoistableRoot = flags;\\n      break;\\n    case 12:\\n      recursivelyTraverseMutationEffects(root, finishedWork);\\n      commitReconciliationEffects(finishedWork);\\n      break;\\n    case 13:\\n      recursivelyTraverseMutationEffects(root, finishedWork);\\n      commitReconciliationEffects(finishedWork);\\n      finishedWork.child.flags & 8192 &&\\n        (null !== finishedWork.memoizedState) !==\\n          (null !== current && null !== current.memoizedState) &&\\n        (globalMostRecentFallbackTime = now());\\n      flags & 4 &&\\n        ((flags = finishedWork.updateQueue),\\n        null !== flags &&\\n          ((finishedWork.updateQueue = null),\\n          attachSuspenseRetryListeners(finishedWork, flags)));\\n      break;\\n    case 22:\\n      hoistableRoot = null !== finishedWork.memoizedState;\\n      var wasHidden = null !== current && null !== current.memoizedState,\\n        prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden,\\n        prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;\\n      offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden || hoistableRoot;\\n      offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || wasHidden;\\n      recursivelyTraverseMutationEffects(root, finishedWork);\\n      offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;\\n      offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;\\n      commitReconciliationEffects(finishedWork);\\n      if (flags & 8192)\\n        a: for (\\n          root = finishedWork.stateNode,\\n            root._visibility = hoistableRoot\\n              ? root._visibility & -2\\n              : root._visibility | 1,\\n            hoistableRoot &&\\n              (null === current ||\\n                wasHidden ||\\n                offscreenSubtreeIsHidden ||\\n                offscreenSubtreeWasHidden ||\\n                recursivelyTraverseDisappearLayoutEffects(finishedWork)),\\n            current = null,\\n            root = finishedWork;\\n          ;\\n\\n        ) {\\n          if (5 === root.tag || 26 === root.tag) {\\n            if (null === current) {\\n              wasHidden = current = root;\\n              try {\\n                if (((currentResource = wasHidden.stateNode), hoistableRoot))\\n                  (maybeNodes = currentResource.style),\\n                    \"function\" === typeof maybeNodes.setProperty\\n                      ? maybeNodes.setProperty(\"display\", \"none\", \"important\")\\n                      : (maybeNodes.display = \"none\");\\n                else {\\n                  i = wasHidden.stateNode;\\n                  var styleProp = wasHidden.memoizedProps.style,\\n                    display =\\n                      void 0 !== styleProp &&\\n                      null !== styleProp &&\\n                      styleProp.hasOwnProperty(\"display\")\\n                        ? styleProp.display\\n                        : null;\\n                  i.style.display =\\n                    null == display || \"boolean\" === typeof display\\n                      ? \"\"\\n                      : (\"\" + display).trim();\\n                }\\n              } catch (error) {\\n                captureCommitPhaseError(wasHidden, wasHidden.return, error);\\n              }\\n            }\\n          } else if (6 === root.tag) {\\n            if (null === current) {\\n              wasHidden = root;\\n              try {\\n                wasHidden.stateNode.nodeValue = hoistableRoot\\n                  ? \"\"\\n                  : wasHidden.memoizedProps;\\n              } catch (error) {\\n                captureCommitPhaseError(wasHidden, wasHidden.return, error);\\n              }\\n            }\\n          } else if (\\n            ((22 !== root.tag && 23 !== root.tag) ||\\n              null === root.memoizedState ||\\n              root === finishedWork) &&\\n            null !== root.child\\n          ) {\\n            root.child.return = root;\\n            root = root.child;\\n            continue;\\n          }\\n          if (root === finishedWork) break a;\\n          for (; null === root.sibling; ) {\\n            if (null === root.return || root.return === finishedWork) break a;\\n            current === root && (current = null);\\n            root = root.return;\\n          }\\n          current === root && (current = null);\\n          root.sibling.return = root.return;\\n          root = root.sibling;\\n        }\\n      flags & 4 &&\\n        ((flags = finishedWork.updateQueue),\\n        null !== flags &&\\n          ((current = flags.retryQueue),\\n          null !== current &&\\n            ((flags.retryQueue = null),\\n            attachSuspenseRetryListeners(finishedWork, current))));\\n      break;\\n    case 19:\\n      recursivelyTraverseMutationEffects(root, finishedWork);\\n      commitReconciliationEffects(finishedWork);\\n      flags & 4 &&\\n        ((flags = finishedWork.updateQueue),\\n        null !== flags &&\\n          ((finishedWork.updateQueue = null),\\n          attachSuspenseRetryListeners(finishedWork, flags)));\\n      break;\\n    case 30:\\n      break;\\n    case 21:\\n      break;\\n    default:\\n      recursivelyTraverseMutationEffects(root, finishedWork),\\n        commitReconciliationEffects(finishedWork);\\n  }\\n}\\nfunction commitReconciliationEffects(finishedWork) {\\n  var flags = finishedWork.flags;\\n  if (flags & 2) {\\n    try {\\n      for (\\n        var hostParentFiber, parentFiber = finishedWork.return;\\n        null !== parentFiber;\\n\\n      ) {\\n        if (isHostParent(parentFiber)) {\\n          hostParentFiber = parentFiber;\\n          break;\\n        }\\n        parentFiber = parentFiber.return;\\n      }\\n      if (null == hostParentFiber) throw Error(formatProdErrorMessage(160));\\n      switch (hostParentFiber.tag) {\\n        case 27:\\n          var parent = hostParentFiber.stateNode,\\n            before = getHostSibling(finishedWork);\\n          insertOrAppendPlacementNode(finishedWork, before, parent);\\n          break;\\n        case 5:\\n          var parent$144 = hostParentFiber.stateNode;\\n          hostParentFiber.flags & 32 &&\\n            (setTextContent(parent$144, \"\"), (hostParentFiber.flags &= -33));\\n          var before$145 = getHostSibling(finishedWork);\\n          insertOrAppendPlacementNo","size_bytes":360000}},"version":1}